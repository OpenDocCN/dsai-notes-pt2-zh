- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-09-08 18:42:35'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: 'Mirai: Evaluating LLM Agents for Event Forecasting'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://ar5iv.labs.arxiv.org/html/2407.01231](https://ar5iv.labs.arxiv.org/html/2407.01231)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '⁰⁰footnotetext: ^∗ Equal Contribution.Chenchen Ye^(∗1), Ziniu Hu^(∗2), Yihe
    Deng^(∗1), Zijie Huang¹,'
  prefs: []
  type: TYPE_NORMAL
- en: Mingyu Derek Ma¹, Yanqiao Zhu¹, Wei Wang¹
  prefs: []
  type: TYPE_NORMAL
- en: ¹University of California, Los Angeles
  prefs: []
  type: TYPE_NORMAL
- en: ²California Institute of Technology
  prefs: []
  type: TYPE_NORMAL
- en: '[https://mirai-llm.github.io/](https://mirai-llm.github.io/)'
  prefs: []
  type: TYPE_NORMAL
- en: Abstract
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Recent advancements in Large Language Models (LLMs) have empowered LLM agents
    to autonomously collect world information, over which to conduct reasoning to
    solve complex problems. Given this capability, increasing interests have been
    put into employing LLM agents for predicting international events, which can influence
    decision-making and shape policy development on an international scale. Despite
    such a growing interest, there is a lack of a rigorous benchmark of LLM agents’
    forecasting capability and reliability. To address this gap, we introduce Mirai,
    a novel benchmark designed to systematically evaluate LLM agents as temporal forecasters
    in the context of international events. Our benchmark features an agentic environment
    with tools for accessing an extensive database of historical, structured events
    and textual news articles. We refine the GDELT¹¹1GDELT: [https://www.gdeltproject.org/](https://www.gdeltproject.org/)
    event database with careful cleaning and parsing to curate a series of relational
    prediction tasks with varying forecasting horizons, assessing LLM agents’ abilities
    from short-term to long-term forecasting. We further implement APIs to enable
    LLM agents to utilize different tools via a code-based interface. In summary,
    Mirai comprehensively evaluates the agents’ capabilities in three dimensions:
    1) autonomously source and integrate critical information from large global databases;
    2) write codes using domain-specific APIs and libraries for tool-use; and 3) jointly
    reason over historical knowledge from diverse formats and time to accurately predict
    future events. Through comprehensive benchmarking, we aim to establish a reliable
    framework for assessing the capabilities of LLM agents in forecasting international
    events, thereby contributing to the development of more accurate and trustworthy
    models for international relation analysis.²²2Our dataset is available on [Google
    Drive](https://drive.google.com/file/d/1xmSEHZ_wqtBu1AwLpJ8wCDYmT-jRpfrN/view?usp=sharing),
    the code can be found on [GitHub](https://github.com/yecchen/MIRAI), and an interactive
    demo is provided through a [Google Colab notebook](https://colab.research.google.com/drive/1QyqT35n6NbtPaNtqQ6A7ILG_GMeRgdnO?usp=sharing).'
  prefs: []
  type: TYPE_NORMAL
- en: 1 Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Accurate forecasting of international events is crucial [[1](#bib.bib1)], as
    understanding the evolution of geopolitical developments enables stakeholders
    to make informed decisions, mitigate risks, and seize opportunities in the interconnected
    world. Traditionally, researchers in international relations rely on domain expertise [[2](#bib.bib2),
    [3](#bib.bib3)]. They conduct detailed analyses of the complex interplay among
    nations, considering alliances, trade agreements, ideological affinities, and
    historical rivalries to forecast events such as conflicts, collaborations, or
    alliance shifts [[4](#bib.bib4)]. With the rapid development of deep learning
    techniques, forecasting through data-driven neural networks becomes an attractive
    alternative. Despite their success, current methods rely on single types of information—either
    structured knowledge graphs [[5](#bib.bib5), [6](#bib.bib6), [7](#bib.bib7)] or
    textual datasets [[8](#bib.bib8), [9](#bib.bib9)]. Knowledge graphs, although
    organized, can suffer from incompleteness [[10](#bib.bib10)] or bias [[11](#bib.bib11)],
    while textual analyses may lack the necessary factual grounding for precise predictions.
    Moreover, these models are unable to ground their reasoning to historical evidence,
    which compromises the interpretability and validation of their forecasts. These
    limitations raise concerns about AI forecasters’ reliability, particularly for
    high-stake scenarios [[12](#bib.bib12)].
  prefs: []
  type: TYPE_NORMAL
- en: Large Language Model (LLM) agents present a promising path for overcoming these
    challenges [[13](#bib.bib13), [14](#bib.bib14), [15](#bib.bib15), [16](#bib.bib16),
    [17](#bib.bib17)]. These advanced AI systems exhibit the potential to mimic human
    experts by utilizing a diverse array of tools to automatically gather and process
    information from various sources, including text, knowledge graphs, and numerical
    data [[18](#bib.bib18), [19](#bib.bib19), [20](#bib.bib20), [21](#bib.bib21)].
    Trained on extensive textual data, LLMs [[22](#bib.bib22), [23](#bib.bib23), [24](#bib.bib24),
    [25](#bib.bib25)] are capable of grasping the subtleties of international relations,
    reasoning through complex relationships with linguistic explanations, and planning
    their tool usage effectively [[26](#bib.bib26), [27](#bib.bib27), [28](#bib.bib28),
    [29](#bib.bib29)]. Such capability opens up new possibilities for developing transparent
    and interpretable forecasting models that can be further scrutinized and refined.
  prefs: []
  type: TYPE_NORMAL
- en: Despite the immense potential of LLM agents for event forecasting, there is
    a lack of standardized benchmarks to assess their forecasting abilities in the
    realm of intricate international events. To address this gap, we introduce Mirai
    (Multi-Information FoRecasting Agent Interface), a novel benchmarking environment
    designed to rigorously assess and advance the capabilities of LLM agents for international
    event forecasting over time. Mirai adapts real-world international event data
    derived from the Global Database of Events, Language, and Tone (GDELT) [[30](#bib.bib30)]
    to an event-forecasting task format across different horizons, providing a robust
    assessment of LLM performance. The framework’s agentic environment enables LLMs
    to interact with both relational and textual databases through Application Programming
    Interfaces (APIs), facilitating autonomous information gathering, processing,
    and application in a contextually relevant manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'We evaluate both open and closed sourced LLMs on Mirai with ReAct-Style [[31](#bib.bib31)]
    Agents and “Single Function” and “Code Block” action types. Our extensive experiments
    revealed: 1) Temporal forecasting tasks are challenging for LLM agents, with the
    highest-performing GPT-4o agent using full suite of APIs achieves a 29.6 F1 score
    in second-level relation prediction tasks; while tasks involving long-term and
    fine-grained event forecasting are even more challenging; 2) The “Code Block”
    tool-use strategy, which allows more flexible interactions, demands robust code
    generation capabilities. Notably, GPT-4o is the only model that effectively utilizes
    and benefits from this strategy. These findings emphasize the need for ongoing
    research into temporal reasoning and the effective use of tools by LLM agents.
    We expect that Mirai could serve as a standard benchmark for evaluating LLMs in
    event forecasting. This would support the development of more precise and reliable
    models for political analysis, enhancing our understanding of global dynamics.'
  prefs: []
  type: TYPE_NORMAL
- en: 2 The Mirai Benchmark
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we introduce Mirai benchmark from: the specifics of the data
    and tasks (Sec. [2.1](#S2.SS1 "2.1 Data and Tasks ‣ 2 The Mirai Benchmark ‣ Mirai:
    Evaluating LLM Agents for Event Forecasting")), the implemented agents and environments
    (Sec. [2.2](#S2.SS2 "2.2 Agents and Environments ‣ 2 The Mirai Benchmark ‣ Mirai:
    Evaluating LLM Agents for Event Forecasting")), and the database construction
    details (Sec. [2.3](#S2.SS3 "2.3 Database Construction ‣ 2 The Mirai Benchmark
    ‣ Mirai: Evaluating LLM Agents for Event Forecasting")).'
  prefs: []
  type: TYPE_NORMAL
- en: 2.1 Data and Tasks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![Refer to caption](img/b291bacf6c64590cec573ed8cffb6dfc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1: An example of forecasting the relations between Australia and China
    on Nov.18.2023\. The database contains query-related historical relations and
    news articles, while the agent fails to predict the change of relation and makes
    a wrong forecast.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Refer to caption](img/b3cc2a8a806fc5d431d1f85ca8174f69.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2: Mirai comprehensively covers global event data. (a) The circular
    chart shows the relation hierarchy and distribution in Mirai. (b) The heatmap
    visualizes the intensity of these events globally, distinguishing between areas
    of conflict (red) and mediation (blue). (c) The heatmap illustrates the frequency
    of these events, highlighting regions with the most occurrences.'
  prefs: []
  type: TYPE_NORMAL
- en: We introduce Mirai, a benchmark crafted for evaluating LLM agents for temporal
    forecasting in the realm of international events, with tool-use and complex reasoning.
    We consider forecasting as the process of collecting essential historical data
    and performing temporal reasoning to anticipate the outcomes of future events.
  prefs: []
  type: TYPE_NORMAL
- en: 'Formally, we represent an event as ${e}^{t}=(t,s,r,o)$ denotes the relation
    type defined by the Conflict and Mediation Event Observations (CAMEO) ontology [[32](#bib.bib32)]⁵⁵5CAMEO
    is a well-established ontology for categorizing international political events,
    meticulously developed by experts to enable detailed analysis across multiple
    levels of granularity.. As shown in Figure [2](#S2.F2 "Figure 2 ‣ 2.1 Data and
    Tasks ‣ 2 The Mirai Benchmark ‣ Mirai: Evaluating LLM Agents for Event Forecasting")a,
    we incorporate two hierarchical levels from the CAMEO ontology to facilitate a
    detailed and comprehensive analysis of geopolitical dynamics. The first level
    includes 20 broad categories, represented by a two-digit code (e.g., “01: Public
    Statement” or “04: Consult”), which are subdivided into second-level categories
    identified by a three-digit code that corresponds to its parent category. For
    example, “03: Express intent to cooperate” is a first-level category that includes
    10 different second-level relations such as “036: Express intent to meet or negotiate”.
    Subsequently, the quadruple “(2023-11-03, AUS, 036, CHN)” denotes that on 3 November
    2023, the Australian leader announces a planned visit to China. These relations
    are also organized along two dimensions, from Verbal to Material and from Conflict
    to Cooperation, to form a quadratic categorization in the inner circle of Figure [2](#S2.F2
    "Figure 2 ‣ 2.1 Data and Tasks ‣ 2 The Mirai Benchmark ‣ Mirai: Evaluating LLM
    Agents for Event Forecasting")a.'
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, a collection of events that happened at the same timestamp ${t}$
    can therefore be organized into a temporal graph, with countries as nodes and
    events’ relations as edges.
  prefs: []
  type: TYPE_NORMAL
- en: The task of event forecasting $(t+l,s,?,o)$ between a pair of countries. This
    includes utilizing events involving third parties, such as interactions with their
    mutual neighbors.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the example of Figure [1](#S2.F1 "Figure 1 ‣ 2.1 Data and Tasks ‣ 2 The
    Mirai Benchmark ‣ Mirai: Evaluating LLM Agents for Event Forecasting"), we demonstrate
    how to predict which actions Australia will adopt towards China on 18 November
    2023 based on all available information up to 17 November 2023. This can also
    be formatted as a structured query “(2023-11-17 + [1 day], AUS, ?, CHN)”, where
    the temporal distance of the forecasted event is one day. From the historical
    events, we can see that the two countries last long-standing tensions; though
    news show the leader of Australia visited China and agreed to ease tension, this
    signal does not change the overall tendency, and their relationship keeps being
    Disapprove and Accuse on certain focuses. Thus, the agent over-relying short-term
    news and eventually gives the wrong prediction diplomatic cooperation.'
  prefs: []
  type: TYPE_NORMAL
- en: 2.2 Agents and Environments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![Refer to caption](img/1b82797b96abdf03b99ced61279a41b2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3: Overview of the LLM agent’s interaction with the multi-source environment
    using the ReAct strategy for forecasting a query event. The framework consists
    of three main steps: (1) Think: The agent analyzes the current status and plans
    the next action based on the query and the provided API specifications. (2) Act:
    The agent generates a “Single Function” call or a “Code Block” to retrieve and
    analyze relevant data from the database. (3) Execute: The Python interpreter runs
    the generated code with the API implementation and database and produces observations.
    These steps are iteratively performed until the agent reaches a final forecast
    for the future relation.'
  prefs: []
  type: TYPE_NORMAL
- en: Similar to human political analysts, LLM agents must leverage a variety of information
    sources to make reliable predictions. To this end, we abstract the environment
    by incorporating coding APIs that facilitate interactions with various knowledge
    sources. Within this environment, we can develop an LLM agent that employs these
    APIs through the ReAct strategy [[33](#bib.bib33)], characterized by the iterative
    steps of think, act, and observe. This structured approach allows the agent to
    analyze the current situation, retrieve additional data, and observe outcomes
    to make reliable forecasting.
  prefs: []
  type: TYPE_NORMAL
- en: 'APIs. We provide a comprehensive set of API to the LLM agent, enabling the
    execution of the generated codes to access a rich database of historical events
    and news articles. The API contains the essential data classes and a suite of
    functions designed to accommodate various types of information within the database.
    Data classes range from unary types such as date, country, and relation, to composite
    types like date range, event, and news articles. Functions, executable via standard
    Python syntax, allow the agent to efficiently query the database through code
    interface. The design of these functions is characterized in two aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Information types. These functions cover various types of information, including
    country and relation code-name mapping and hierarchy, and count, listing, and
    distribution of events and news articles. For example, the function map_relation_description_to_cameo
    takes a relation description and returns a list of the five most likely relations
    with their respective CAMEO codes, names, and descriptions, providing precise
    relation information as needed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Search conditions. Additionally, the API functions related to events and news
    articles include various optional parameters that enable tailored searches based
    on different criteria. For instance, the function get_event enables searches by
    specifying conditions like date_range, head_entities, tail_entities, relations,
    and text_description to fetch events that meet these conditions from the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The API specifications and full implementations are shown in Appendix [M](#A13
    "Appendix M Additional Information about API ‣ item 1 ‣ L.1.4 Agent ReAct Process
    ‣ L.1 GPT-4o-based Agent with ReAct and “Code Block” Action ‣ Appendix L Additional
    Forecasting Examples of LLM Agent ‣ Acknowledgements ‣ 5 Conclusion and Limitation
    ‣ 4.3 LLMs for Tool-Use ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2
    Evaluate Forecasting with Different Base LLMs ‣ 3 Experiments ‣ Mirai: Evaluating
    LLM Agents for Event Forecasting").'
  prefs: []
  type: TYPE_NORMAL
- en: 'Interaction with environment. In Mirai, agents are given the API specifications,
    which include meticulously documented Python docstrings for all data classes and
    function definitions, abstracting the underlying implementation details. The environment
    is equipped with a Python code sandbox with full access to APIs and databases.
    The agent uses the ReAct strategy in an iterative manner, alternating between
    think, act, and observe to gather information and perform forecasting. The pipeline
    is illustrated in Figure [3](#S2.F3 "Figure 3 ‣ 2.2 Agents and Environments ‣
    2 The Mirai Benchmark ‣ Mirai: Evaluating LLM Agents for Event Forecasting").'
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Think. Specifically, the agent first thinks about the current situation. If
    it is confident to deliver a final forecast based on the current information and
    analysis, it provides the answer and stops the iteration. Otherwise, it further
    analyzes the current status and plans subsequent actions. In the first step shown
    in Figure [3](#S2.F3 "Figure 3 ‣ 2.2 Agents and Environments ‣ 2 The Mirai Benchmark
    ‣ Mirai: Evaluating LLM Agents for Event Forecasting"), the agent plans to first
    retrieve recent events directly involving the two countries and later verify the
    details by checking related news articles.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Act. Next, the agent acts by generating executable codes to interact with the
    environment. There are two types of action: “Single Function” or “Code Block”.
    A “Single Function” facilitates straightforward data retrieval, whereas a “Code
    Block” supports a more flexible and larger action space, accommodating complex
    control flows such as loops and conditional statements. Also, the agent is allowed
    to use functions defined in the API and can additionally utilize safe, well-established
    Python libraries such as numpy, networkx, and scikit-learn. As shown in Figure [3](#S2.F3
    "Figure 3 ‣ 2.2 Agents and Environments ‣ 2 The Mirai Benchmark ‣ Mirai: Evaluating
    LLM Agents for Event Forecasting"), the agent can write either a “Code Block”
    with an imported library and an inline loop, or a “Single Function” call with
    targeted countries as the argument value.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Observe. The environment receives the code generated by the agent, executing
    it internally using a Python interpreter with full access to API implementations
    and the database. The output from this execution is then passed to the agent as
    the content of its ‘Observation’ step. In particular, the agent can observe the
    corresponding output if its generated code executes successfully; otherwise, it
    can only observe a specified error message along with the error type. In the figure,
    the written code is executed, and results are sent back to the agent memory to
    proceed next iteration.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'These ‘Thought’, ‘Action’, and ‘Observation’ from the previous iterations are
    stored in the agent’s memory base and used as the context of the agent in the
    next iteration. Additionally, the variables defined in the code generated in any
    previous action steps are stored and available for future actions. Examples are
    shown in Appendix [L](#A12 "Appendix L Additional Forecasting Examples of LLM
    Agent ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use
    ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with
    Different Base LLMs ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting").'
  prefs: []
  type: TYPE_NORMAL
- en: 2.3 Database Construction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Pre-processing. We construct a GDELT-based environment to enable agents’ interaction
    with both knowledge graph and textual information. Initially, we filtered the
    dataset for events occurring between Jan. 1, 2023, and Nov. 30, 2023, aligning
    event dates with their respective news publish dates to avoid information leakage.
    We standardize the CountryCode to ISO-3166 norms and exclude any entries with
    missing or outdated codes, and standardize Event codes to the second level of
    the CAMEO ontology to ensure a consistent and detailed representation. Third-level
    event codes, which are more noisy and contain more extraction errors were excluded.
    We also only consider international events. For the news articles, credibility
    was assessed by counting the daily mentions of each event, with a threshold of
    at least 50 mentions to filter out unreliable sources. News content, including
    titles and body text, was then downloaded and cleaned following the OBELICS [[34](#bib.bib34)]
    protocol, which involved removing low-quality text based on word counts, character
    and word repetition ratios, and the presence of special characters and flagged
    words, thereby significantly reducing noise and enhancing the reliability of the
    textual information stored in our database. We list the details for dataset construction
    in Appendix [F](#A6 "Appendix F Details of Dataset Construction ‣ Acknowledgements
    ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4 Related Work ‣ 3.3 Analyzing
    Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3 Experiments
    ‣ Mirai: Evaluating LLM Agents for Event Forecasting"). We finalized a collection
    of 991,759 GDELT event records, corresponding to 59,161 unique $(t,s,r,o)$ events
    and 296,630 unique news articles. We display our curated events over the world
    map in Figure [2](#S2.F2 "Figure 2 ‣ 2.1 Data and Tasks ‣ 2 The Mirai Benchmark
    ‣ Mirai: Evaluating LLM Agents for Event Forecasting")b and [2](#S2.F2 "Figure
    2 ‣ 2.1 Data and Tasks ‣ 2 The Mirai Benchmark ‣ Mirai: Evaluating LLM Agents
    for Event Forecasting")c, illustrating global coverage and varying intensities
    of conflict and mediation across regions.'
  prefs: []
  type: TYPE_NORMAL
- en: Test query set construction. We construct the test data using records from November
    2023, comprising 152,500 GDELT event records and 7385 unique events. To further
    ensure the data quality and minimize potential extraction errors inherent in GDELT
    records, we set a higher threshold of at least 100 daily mentions and 5 downloaded
    news articles for each event. This stricter filtering results in a collection
    of 2,136 unique $(t,s,r,o)$ in this collection. Note that this stricter filtering
    is only applied for the test query construction and will not remove data from
    the database. Additionally, we sample 100 queries from the test query set to form
    a test query subset, ensuring a balanced representation of dates throughout the
    month, countries across continents, and relations spanning the first-level CAMEO
    code types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Evaluation metrics. We instruct the agent to generate final forecasting answer
    in a JSON dictionary, where keys are predicted two-digit first-level CAMEO codes
    and the values are lists of predicted three-digit second-level CAMEO codes inherited
    from the keys. For example, the JSON dictionary “{"01": ["011", "012"], "02":
    ["023"]}” indicates the first level relation predictions for "01: Make public
    statement" and "02: Appeal", along with second level relation predictions "011:
    Decline comment", "012: Make pessimistic comment", and "023: Appeal for material
    aid". We evaluate these relation predictions by calculating precision, recall,
    and F1 score between the predicted and ground-truth lists. Moreover, we map the
    predicted and ground truth relations to their respective binary and quadratic
    classes (as shown in Figure [2](#S2.F2 "Figure 2 ‣ 2.1 Data and Tasks ‣ 2 The
    Mirai Benchmark ‣ Mirai: Evaluating LLM Agents for Event Forecasting")a). Since
    each relation in the ground-truth list may belong to different classes, we employ
    the empirical Kullback-Leibler (KL) divergence of predictions to the ground truth:
    $D_{\text{KL}}(P||Q)=\sum_{i}P(i)\log\left(\frac{P(i)}{Q(i)}\right)$ represent
    the frequencies of ground-truth and predicted relations respectively. A lower
    KL divergence indicates a better alignment of the model’s predictions with the
    ground-truth list.'
  prefs: []
  type: TYPE_NORMAL
- en: 3 Experiments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our experiment section begins with comparing the forecasting performance of
    different agent methods with different prediction horizons (Sec.[3.1](#S3.SS1
    "3.1 Evaluate Forecasting with Different Agent Methods and Tools ‣ 3 Experiments
    ‣ Mirai: Evaluating LLM Agents for Event Forecasting")). Moreover, we evaluate
    agents with different base language models (Sec.[3.2](#S3.SS2 "3.2 Evaluate Forecasting
    with Different Base LLMs ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event
    Forecasting")), and finally analyze several key aspects (Sec.[3.3](#S3.SS3 "3.3
    Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs
    ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")) to understand
    agents’ behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: 3.1 Evaluate Forecasting with Different Agent Methods and Tools
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We investigate the effect of different tools (APIs) and agent tool-use strategies.
    We use gpt-3.5-turbo-0125 [[35](#bib.bib35)] as the base model and evaluate on
    the 705 queries in the test set. For all experiments, we set the model temperature
    to $0.4$ and run 5 times to calculate the mean and standard deviation. We provide
    the detailed prompts in Appendix [K](#A11 "Appendix K Prompts ‣ Acknowledgements
    ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4 Related Work ‣ 3.3 Analyzing
    Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3 Experiments
    ‣ Mirai: Evaluating LLM Agents for Event Forecasting").'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 1: Experimental results on the test set with different agent tools and
    the tool-use strategies. The best-performing score is highlighted in bold and
    the second-best is underlined.'
  prefs: []
  type: TYPE_NORMAL
- en: '| Agent | Tool-Use |  | Binary |  |  |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| KL ($\Downarrow$) | Quad |  |  |  |  |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| KL ($\Downarrow$) | First-level Relation (%) |  |  | Second-level Relation
    (%) |  |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | Action Type | API |  |  | Pre. ($\Uparrow$) |'
  prefs: []
  type: TYPE_TB
- en: '| Direct IO | — | — | 6.5[±1.7] | 15.9[±1.5] | 27.6[±8.1] | 19.7[±5.9] | 18.8[±6.9]
    | 6.6[±1.5] | 5.1[±0.4] | 3.5[±0.8] |'
  prefs: []
  type: TYPE_TB
- en: '| ZS-COT | — | — | 6.9[±0.8] | 10.1[±0.8] | 27.6[±4.0] | 36.0[±4.5] | 26.7[±4.1]
    | 10.2[±1.4] | 17.4[±1.1] | 10.5[±0.7] |'
  prefs: []
  type: TYPE_TB
- en: '| ReAct | Single Function | *Event-Only* | 33.5[±0.7] | 6.7[±0.7] | 44.3[±3.9]
    | 54.2[±3.9] | 41.4[±1.7] | 25.3[±2.6] | 47.4[±2.4] | 26.9[±1.9] |'
  prefs: []
  type: TYPE_TB
- en: '|  | Single Function | *News-Only* | 6.1[±1.0] | 12.8[±0.6] | 27.8[±3.1] |
    25.9[±2.9] | 21.8[±2.3] | 6.3[±2.2] | 9.0[±2.0] | 5.4[±1.3] |'
  prefs: []
  type: TYPE_TB
- en: '| ReAct | Single Function | All | 3.1[±0.5] | 5.9[±1.0] | 47.6[±5.8] | 58.3[±2.6]
    | 44.2[±4.0] | 28.7[±3.9] | 51.0[±4.0] | 29.6[±3.7] |'
  prefs: []
  type: TYPE_TB
- en: '|  | Code Block | All | 5.1[±0.9] | 8.9[±0.5] | 27.1[±4.0] | 38.6[±2.5] | 25.9[±2.2]
    | 11.6[±2.4] | 26.3[±2.0] | 12.6[±1.7] |'
  prefs: []
  type: TYPE_TB
- en: 'For agent implementations, we consider the following two methods without tool-use:'
  prefs: []
  type: TYPE_NORMAL
- en: Direct IO represents the standard LLM chatbot approach that provides answers
    without tool-use or explicit reasoning. This serves as a baseline to reflect the
    internal world knowledge of the LLMs when forecasting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Zero-Shot Chain-of-Thought (ZS-CoT) [[36](#bib.bib36), [37](#bib.bib37)]: In
    the ZS-CoT variant, we add an instruction prompt to the LLM to encourage explicit
    step-by-step thinking before making the final prediction.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For Tool-Use agents, We follow ReAct [[31](#bib.bib31)] to interact with our
    provided environments through an iterative process of thinking, acting, and observing.
    We implement two variants of ReAct for tool-use: 1) “Single Function” and 2) “Code
    Block”. Details are discussed in Sec. [2.2](#S2.SS2 "2.2 Agents and Environments
    ‣ 2 The Mirai Benchmark ‣ Mirai: Evaluating LLM Agents for Event Forecasting").'
  prefs: []
  type: TYPE_NORMAL
- en: ReAct agents can utilize tools. We thus implement different variants by restricting
    their access to utilize 1) *News-Only* APIs; 2) *Event-Only* APIs; 3) *All* data
    classes and functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The experimental results in Table [1](#S3.T1 "Table 1 ‣ 3.1 Evaluate Forecasting
    with Different Agent Methods and Tools ‣ 3 Experiments ‣ Mirai: Evaluating LLM
    Agents for Event Forecasting") reveal several key insights into agent performance:'
  prefs: []
  type: TYPE_NORMAL
- en: 1) Mirai presents a challenging task for LLM agents. The best agent (ReAct with
    “Single Function” using all APIs) for second-level relation predictions achieves
    a precision of $28.7$. These results underscore the complexity and difficulty
    of the temporal forecasting tasks in Mirai and highlight the substantial room
    for improvement in LLM agents for event forecasting.
  prefs: []
  type: TYPE_NORMAL
- en: 2) Predicting fine-grained relations proves more difficult. All models exhibit
    higher KL divergence for quadratic than binary classes, and lower F1 scores for
    second-level predictions compared to first-level ones. These findings confirm
    that predicting fine-grained relation types is more challenging.
  prefs: []
  type: TYPE_NORMAL
- en: 3) Diverse tool-use is critical for temporal forecasting. ZS-CoT and Direct-IO,
    which rely solely on the internal world knowledge of LLMs for forecasting without
    tool-use, significantly underperform the ReAct agent with full API access to the
    database. This emphasizes the importance of basing forecasting and reasoning on
    retrieved historical data and knowledge. In terms of tool types, ReAct agents
    using *News-Only* APIs perform much worse than agents with *Event-Only* APIs.
    While news articles provide detailed context for events, they can also introduce
    noise and lead to issues such as excessively long context, posing additional challenges
    for LLM agents. Moreover, the agents using both types of information achieve the
    optimal results.
  prefs: []
  type: TYPE_NORMAL
- en: 3.2 Evaluate Forecasting with Different Base LLMs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Table 2: Experimental results on the test subset using different base LLMs
    and action types. The best-performing score is highlighted in bold and the second-best
    is underlined.'
  prefs: []
  type: TYPE_NORMAL
- en: '| Model | Training Data |  |  |  |  |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| Cutoff Date | Action Type | Binary |  |  |  |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| KL ($\Downarrow$) | Quad |  |  |  |  |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| KL ($\Downarrow$) | First-level Relation (%) |  |  | Second-level Relation
    (%) |  |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '|  |  |  |  |  | Pre. ($\Uparrow$) |'
  prefs: []
  type: TYPE_TB
- en: '| Mistral-7B | — | Single Function | 9.6[±2.4] | 14.1[±1.9] | 27.2[±8.2] |
    13.1[±3.6] | 14.4[±3.2] | 14.1[±4.4] | 7.0[±2.2] | 6.6[±2.3] |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | Code Block | 9.0[±3.0] | 13.1[±2.3] | 25.8[±6.9] | 10.4[±4.8] | 11.1[±3.8]
    | 10.0[±3.8] | 5.8[±4.1] | 4.6[±1.1] |'
  prefs: []
  type: TYPE_TB
- en: '| gpt-3.5-turbo | 2021-09 | Single Function | 3.9[±1.0] | 6.7[±1.7] | 52.6[±9.3]
    | 46.8[±8.5] | 38.2[±4.9] | 36.7[±9.2] | 41.7[±7.6] | 27.9[±3.6] |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | Code Block | 3.6[±0.7] | 8.0[±1.7] | 32.8[±4.7] | 41.0[±2.0] | 29.7[±2.9]
    | 14.4[±5.0] | 33.7[±5.3] | 14.4[±2.6] |'
  prefs: []
  type: TYPE_TB
- en: '| gpt-4-turbo | 2023-12 | Single Function | 2.4[±0.6] | 6.1[±0.8] | 55.0[±7.5]
    | 43.9[±7.8] | 39.8[±4.9] | 33.5[±7.5] | 43.5[±5.4] | 30.0[±1.9] |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | Code Block | 2.0[±1.1] | 6.0[±2.0] | 46.4[±8.7] | 51.7[±10.0] | 40.0[±8.7]
    | 32.7[±4.9] | 43.2[±9.5] | 28.7[±5.0] |'
  prefs: []
  type: TYPE_TB
- en: '| gpt-4o | 2023-10 | Single Function | 1.8[±1.0] | 4.4[±1.8] | 48.7[±8.7] |
    63.7[±8.8] | 45.5[±4.6] | 31.2[±6.7] | 59.2[±7.3] | 32.6[±2.7] |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | Code Block | 1.6[±1.1] | 4.3[±1.9] | 42.3[±9.4] | 64.5[±9.5] | 44.1[±8.1]
    | 29.1[±7.3] | 59.6[±7.6] | 32.8[±6.4] |'
  prefs: []
  type: TYPE_TB
- en: 'We then investigate the role of the underlying LLMs in the agent’s performance.
    We evaluate both open-sourced LLM Mistral-7B-Instruct-v0.2 [[38](#bib.bib38)]
    (run on a single NVIDIA RTX A6000 GPU), as well as close-sourced LLMs including
    gpt-3.5-turbo-0125 [[35](#bib.bib35)], gpt-4-turbo-2024-04-09 [[22](#bib.bib22)],
    and the recently released gpt-4o-2024-05-13 [[39](#bib.bib39)]. Comparisons are
    done on a data-balanced test subset comprising 100 queries, with all models evaluated
    under the ReAct framework, allowing access to all APIs. The action types can be
    either “Single Function” or “Code Block” with a maximum tool call limit set to
    20 steps. All models use the same prompt content and structure shown in Appendix [K](#A11
    "Appendix K Prompts ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs
    for Tool-Use ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate
    Forecasting with Different Base LLMs ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents
    for Event Forecasting"). The experimental results are presented in Table [3.2](#S3.SS2
    "3.2 Evaluate Forecasting with Different Base LLMs ‣ 3 Experiments ‣ Mirai: Evaluating
    LLM Agents for Event Forecasting"), and a further analysis of the agent’s final
    status is provided in Appendix [J.1](#A10.SS1 "J.1 Analysis of the Final Status
    of Different LLM Agents ‣ Appendix J Additional Experimental Results and Analysis
    ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4 Related
    Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different
    Base LLMs ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting").
    We observe the following findings:'
  prefs: []
  type: TYPE_NORMAL
- en: '1) Code Block benefits stronger LLMs but hurts weaker models: The “Code Block”
    action type provides greater flexibility than the “Single Function”. However,
    its benefits are not uniformly achieved across all models. Mistral-7B and gpt-3.5-turbo
    show reduced performance with Code Block, while stronger models like gpt-4-turbo
    and gpt-4o gains improvements from it. This indicates that the ability to generate
    coherent and practical long Code Blocks is a distinguishing factor that determines
    LLMs as reliable forecasting agents.'
  prefs: []
  type: TYPE_NORMAL
- en: '2) GPT-4o consistently outperforms other models: gpt-4o, the most recent LLM,
    consistently achieves the highest performance across different metrics. Notably,
    for second-level relation prediction, gpt-4o achieves F1 scores of $32.6$ using
    “Single Function” and “Code Block”, surpassing all other models including gpt-4-turbo-2024-04-09.
    This indicates that Mirai is hard enough, and can effectively distinguish different
    LLMs’ advanced reasoning capabilities.'
  prefs: []
  type: TYPE_NORMAL
- en: Can self-consistency make a small model stronger? It is evident that stronger
    LLMs have better agent performance; however, can we enhance a weaker LLM to achieve
    comparable forecasting performance using inference-time computation? To explore
    this, we take Mistral-7B as the base LLM with ReAct using the “Single Function”
    strategy. For each query, we perform multiple sampling at a temperature of $0.4$,
    even surpassing gpt-4o. This result highlights the potential of the inference-time
    search methods like self-consistency to push the boundaries of smaller language
    models in event forecasting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Code execution error analysis. Our implemented agents interact with tools via
    code but often encounter execution error. We summarize the error types for different
    LLMs in Figure [5](#S3.F5 "Figure 5 ‣ 3.2 Evaluate Forecasting with Different
    Base LLMs ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")b.
    We can see that invalid dates and invalid attributes are the two most frequent
    errors, with even gpt-4-turbo exhibiting a frequency of such errors. Notably,
    gpt-4o makes significantly fewer execution errors. This enhanced code generation
    capability contributes to its superior performance for event forecasting.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Refer to caption](img/8b59f5ea483c01eabcefccf9d45c10f4.png)![Refer to caption](img/c60eb1c77a35e193d6a1ac21c56f9bd1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4: a) Self-consistency of Mistral-7B model increases with more samples.
    b) F1 scores of different base LLM agents on relation prediction, categorized
    based on the quadratic classes.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Refer to caption](img/23bb701a840f26b6b364bc7e294ce48b.png)![Refer to caption](img/ea6c2664aa3a6d490194ee44d9e042ba.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5: a) F1 Accuracy for each API function. b) Code execution error analysis
    for different LLMs.'
  prefs: []
  type: TYPE_NORMAL
- en: 3.3 Analyzing Agent Behaviours
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![Refer to caption](img/ac5c76f5de86c68b15fd9c9723bc7a29.png)![Refer to caption](img/4778fe5070a5d22638428e89c1b283f6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6: Evaluation of LLM Agents in different temporal distances of the forecasting
    event.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Refer to caption](img/0ac19669f560d5a57b0a563d57bee462.png)![Refer to caption](img/32db4323566f88517d66e9d44bf7e3c4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7: Action order analysis in LLM agents. a) Tool-Use Transition Graph
    of called API functions. Edge thickness indicates transition frequency. b) Freq.(correct)
    - Freq.(incorrect), in which red (blue) edges indicate positive (negative) contributions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Impact of temporal distance of the forecasting target. Our defined event forecasting
    task varies by temporal distance $l$ days prior to the query event date. The experimental
    results depicted in Figure [6](#S3.F6 "Figure 6 ‣ 3.3 Analyzing Agent Behaviours
    ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3 Experiments ‣ Mirai: Evaluating
    LLM Agents for Event Forecasting") reveal a clear trend: as the temporal distance
    increases, the F1 score decreases and KL-divergence increases. This indicates
    that the agent’s ability to provide accurate predictions diminishes for events
    further in the future. When the temporal distance is small, such as 1 or 7 days,
    the agent has access to more recent and relevant information, providing a strong
    signal (e.g., human experts’ analysis) for making accurate predictions. Thus,
    to comprehensively benchmark the forecasting capabilities of LLM agents, we should
    focus on long-term predictions such as those spanning 30 or 90 days. These longer
    durations require the agents to capture and anticipate potential trend shifts,
    which may be influenced by a broader range of factors and more complex dependencies.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Forecasting accuracy on different relation types. We further split the datasets
    into distinct quadratic relation classes and compute the F1 score for each class,
    as illustrated in Figure [4](#S3.F4 "Figure 4 ‣ 3.2 Evaluate Forecasting with
    Different Base LLMs ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")b.
    The results show that all models exhibit significantly higher performance for
    “verbal cooperation” and “material conflict”, while lower in the other two categories.
    Several factors contribute to these observations. First, “verbal cooperation”
    events are more prevalent in the dataset, allowing the model to retrieve more
    such historical events. Second, “material conflicts” has a consistent pattern
    of extended duration within the same set of countries. Conversely, events categorized
    under “material cooperation” and “verbal conflicts”, such as “057: Sign formal
    agreement” and “084: Return or release”, tend to be more abrupt and unpredictable,
    demanding subtle trend analysis and contextual knowledge, leading to lower performance
    in these categories. These observations highlight the need for LLMs capable of
    understanding the nuances and complexities of different event types.'
  prefs: []
  type: TYPE_NORMAL
- en: 'How tool-use ordering influences forecasting. We further investigate the impact
    of action order on the GPT-4o agent in “Single Function” mode. Figure [7](#S3.F7
    "Figure 7 ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different
    Base LLMs ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")
    shows the transition graph from the initial query to the correct final answer,
    with thicker edges indicating more frequent transitions. Typically, the agent
    begins with get_relation_distribution or get_event to gather an initial set of
    recent and frequent events for key information, and often concludes with browse_news_article
    and get_news_articles, which retrieve news content to make accurate forecasts.
    To further understand whether each function helps forecasting, we subtract the
    frequency of incorrect predictions from those of correct predictions, as shown
    in Figure [7](#S3.F7 "Figure 7 ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate
    Forecasting with Different Base LLMs ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents
    for Event Forecasting")b. Here, red edges represent sequences typically leading
    to accurate outcomes, and blue edges indicate error-prone paths. Actions like
    browse_news_article and get_entity_distribution typically result in correct answers
    more frequently. Notably, get_news_articles has a direct blue link to the answer,
    suggesting that this function leads more often to incorrect answers because it
    only returns news titles, which are too vague for accurate prediction. However,
    when followed by browse_news_article and then providing the answer, the agent
    is more likely to produce correct outcomes. Similar patterns are observed with
    get_event, where adding get_entity_distribution turns a negative link to a positive
    one to the answer. Figure [5](#S3.F5 "Figure 5 ‣ 3.2 Evaluate Forecasting with
    Different Base LLMs ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")a
    further demonstrates how each function contributes to the final performance, showing
    that for the first-level prediction, get_{child/sibling}_relation are more useful.
    These results emphasize the importance for strategic action planning in LLM agents
    for effective temporal forecasting.'
  prefs: []
  type: TYPE_NORMAL
- en: 4 Related Work
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Table 3: Comparison of Mirai with other temporal reasoning benchmarks. “Method”
    refers to the methodology of original and recent models evaluated on the benchmark.
    ICL stands for LLM w/ In-Context Learning, FT stands for Task-Specific Fine-Tuning.'
  prefs: []
  type: TYPE_NORMAL
- en: '| Benchmark | Temporal Reasoning |  | Task Format | Information |  |  |  |
    Method |'
  prefs: []
  type: TYPE_TB
- en: '|  | Understanding | Forecasting |  | Time Series | KG | Textual | API |  |'
  prefs: []
  type: TYPE_TB
- en: '| TempQuestions [[40](#bib.bib40)] | ✓ |  | KGQA |  | ✓ |  |  | KGQA Systems
    |'
  prefs: []
  type: TYPE_TB
- en: '| CRONQuestions [[41](#bib.bib41)] | ✓ |  | KGQA |  | ✓ |  |  | Bert-based
    FT |'
  prefs: []
  type: TYPE_TB
- en: '| TempoQR [[42](#bib.bib42)] | ✓ |  | KGQA |  | ✓ |  |  | Bert-based FT |'
  prefs: []
  type: TYPE_TB
- en: '| TORQUE [[43](#bib.bib43)] | ✓ |  | QA |  |  | ✓ |  | Bert-based FT |'
  prefs: []
  type: TYPE_TB
- en: '| TempReason [[44](#bib.bib44)] | ✓ |  | QA |  | ✓ | ✓ |  | ICL + Task-specific
    FT |'
  prefs: []
  type: TYPE_TB
- en: '| TRAM [[45](#bib.bib45)] | ✓ |  | MCQ |  |  | ✓ |  | ICL + Bert-based FT |'
  prefs: []
  type: TYPE_TB
- en: '| TCELongBench [[46](#bib.bib46)] | ✓ | ✓ | Ordering QA; MCQ |  |  | ✓ |  |
    ICL |'
  prefs: []
  type: TYPE_TB
- en: '| ForecastQA [[47](#bib.bib47)] |  | ✓ | MCQ |  |  | ✓ |  | Bert-based FT |'
  prefs: []
  type: TYPE_TB
- en: '| Approach [[48](#bib.bib48)] |  | ✓ | QA |  |  | ✓ |  | ICL |'
  prefs: []
  type: TYPE_TB
- en: '| IntervalQA [[8](#bib.bib8)] |  | ✓ | Numerical QA; MCQ | ✓ |  | ✓ |  | ICL
    |'
  prefs: []
  type: TYPE_TB
- en: '| TKGs [[49](#bib.bib49), [30](#bib.bib30)] |  | ✓ | Link Prediction |  | ✓
    |  |  | Graph FT + ICL + Task-specific FT |'
  prefs: []
  type: TYPE_TB
- en: '| Mirai |  | ✓ | Relation List |  | ✓ | ✓ | ✓ | LLM Agent |'
  prefs: []
  type: TYPE_TB
- en: 'In recent years, various benchmarks have been developed to evaluate temporal
    reasoning capabilities in AI systems, focusing primarily on question answering
    and link prediction. Mirai distinguishes itself by assessing LLMs in the forecasting
    task, and further employing a relational task format, incorporating diverse information
    sources of knowledge graphs, text, and code-based APIs, and utilizing an agent-based
    methodology that supports intermediate reasoning steps. We summarize our differences
    to these existing benchmarks in Table [3](#S4.T3 "Table 3 ‣ 4 Related Work ‣ 3.3
    Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs
    ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting"), and provide
    further discussions from the following aspects and more in Appendix [D](#A4 "Appendix
    D Additional related work ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3
    LLMs for Tool-Use ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate
    Forecasting with Different Base LLMs ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents
    for Event Forecasting").'
  prefs: []
  type: TYPE_NORMAL
- en: 4.1 Temporal Reasoning Benchmarks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Many benchmarks sensing the temporal reasoning ability of AI models have been
    constructed, but they have different focuses and settings with Mirai, particularly
    in terms of task, information, and method, as shown in Table [3](#S4.T3 "Table
    3 ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting
    with Different Base LLMs ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event
    Forecasting"). One line of benchmarks focuses on the temporal understanding ability
    of the model [[40](#bib.bib40), [41](#bib.bib41), [42](#bib.bib42), [43](#bib.bib43),
    [44](#bib.bib44), [45](#bib.bib45)], such as understanding the temporal relations
    between available facts in knowledge graphs (KGs) or text, either a short piece
    of text or a document corpus. While the temporal forecasting task largely differs
    from understanding, where the reasoning target is unseen in the database for the
    model, and as such, the model has to not only understand but to reason. For forecasting,
    there are two main task formulations among previous benchmarks: the QA task format
    for benchmarks with history information represented in textual format [[8](#bib.bib8),
    [46](#bib.bib46), [47](#bib.bib47), [48](#bib.bib48), [50](#bib.bib50)], and graph
    link prediction task format for temporal knowledge graph(TKG)-based benchmarks [[49](#bib.bib49),
    [30](#bib.bib30)]. However, the uniformat of information sources either lacks
    of support to clearly structural facts or contextual detail for the model to perform
    advanced reasoning, while in Mirai, we provide both information sources. Additionally,
    we provide carefully constructed API with various data classes and functions that
    access to various part of the data. With the flexibility provided by code generation,
    the model is exposed to a broader and more flexible range of information. More
    importantly, Mirai distinguishes itself by introducing an agentic environment
    specifically designed to evaluate LLM agents in the forecasting task. This represents
    a significant departure from previous work, which has not explored or even considered
    the potential of performing temporal forecasting tasks using LLM agents.'
  prefs: []
  type: TYPE_NORMAL
- en: 4.2 Evaluation of Language Agents
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previous research has investigated the performance of LLM agents in a variety
    of domains, including arithmetic reasoning focused on obtaining correct solutions [[51](#bib.bib51),
    [52](#bib.bib52), [53](#bib.bib53)], proficiency assessment in utilizing tools
    and reporting results [[54](#bib.bib54), [55](#bib.bib55), [56](#bib.bib56)],
    evaluation of web navigation skills to find specific websites [[57](#bib.bib57),
    [58](#bib.bib58), [59](#bib.bib59)], and planning travel itineraries under given
    constraints [[60](#bib.bib60)]. However, these evaluations do not fully address
    the challenges posed by tasks involving complex international events with diverse
    information formats and temporal attributes. Mirai presents a unique task in this
    context, where the agent must navigate and reason over the structured events and
    textual news articles with temporal information. This setup requires the agent
    to effectively handle multilateral relationships and information spanning different
    time periods. Furthermore, Mirai assesses the LLM agent’s ability to reason and
    predict information that not be directly available in the provided database. This
    adds an additional layer of complexity, as the agent must leverage its understanding
    of the available information to make informed predictions about future events
    or fill in missing details. By evaluating LLM agents in this challenging setting,
    Mirai provides valuable insights into their capacity to process and reason over
    complex, temporally-structured information and their ability to generate accurate
    predictions based on incomplete data.
  prefs: []
  type: TYPE_NORMAL
- en: 4.3 LLMs for Tool-Use
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Large Language Models (LLMs) have demonstrated remarkable language understanding [[61](#bib.bib61)]
    and reasoning capabilities [[62](#bib.bib62)]. However, they also possess inherent
    limitations, such as their inability to provide up-to-date responses based on
    external knowledge or to perform complex mathematical reasoning. In response to
    these challenges, recent advancements have seen the integration of LLMs with various
    external tools [[63](#bib.bib63)]. Notable examples include TALM [[64](#bib.bib64)]
    and ToolFormer [[65](#bib.bib65)], which utilize in-context learning to enhance
    the model’s ability to leverage different tools in tasks like question answering
    and mathematical reasoning. Chameleon [[66](#bib.bib66)] employs an LLM as a natural
    language planner to deduce the optimal sequence of tools to be used, subsequently
    executing these tools to generate the final output. AVIS [[67](#bib.bib67)] employs
    dynamic tree search to synthesize the most effective tool-use sequence. ToolkenGPT [[68](#bib.bib68)]
    integrates tool-use operators as special tokens and trains the model through sequence-to-sequence
    training. ToolLLM [[69](#bib.bib69)] introduces an instruction tuning dataset
    encompassing over 16,000 real-world APIs, significantly enhancing the model’s
    capability to utilize these tools effectively.
  prefs: []
  type: TYPE_NORMAL
- en: 5 Conclusion and Limitation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In conclusion, we introduce Mirai, a benchmark constructed for evaluating LLM
    agents in temporal forecasting international event with tools (APIs) to access
    an extensive historical event and news database. The results reveals the complexity
    and difficulty for current LLM Agents in generating contextually and syntax-wise
    correct code and performing complex temporal reasoning over the multi-party and
    multi-timestamped data for an effective prediction, highlighting a substantial
    space for further effects in this direction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our work also has several limitations: 1) Only a few representative LLMs were
    tested, leaving broader evaluations with more open-sourced models; 2) The current
    API is basic, primarily providing functions for counting, listing, and statistical
    distribution. Future enhancements could include time series analysis and the ability
    for agents to add new functions for more comprehensive analysis. 3) The study
    was limited by cost of API usage, so we only conduct small number of experimental
    rounds and result in high variance. More extensive testing is suggested for future
    studies to achieve more stable results. Full discussion of limitation can be found
    in Appendix [C](#A3 "Appendix C Limitations ‣ Acknowledgements ‣ 5 Conclusion
    and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4 Related Work ‣ 3.3 Analyzing Agent
    Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3 Experiments
    ‣ Mirai: Evaluating LLM Agents for Event Forecasting"). In the future, we plan
    to incorporate APIs to support more knowledge sources such as time-series and
    multimodal information, and consider testing more open-source LLMs and agent architectures.'
  prefs: []
  type: TYPE_NORMAL
- en: Acknowledgements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Research was supported in part by NIH U24DK097771, U54HG012517, NSF 1829071,
    2106859, 2119643, 2200274, 2202693, and 2312501, DARPA HR00112490370, and Optum
    Lab.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Brown and Lee [2018] Thomas Brown and Susan Lee. Predictive analytics in economic
    sanctions and international policy. *Journal of International Economics*, 26(4):311–330,
    2018.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Smith and Doe [2020] Johnathan Smith and Jane Doe. Geopolitical risk assessment
    in international relations. *Journal of Global Politics*, 15(3):200–225, 2020.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Johnson and Roberts [2019] Emily Johnson and Mark Roberts. The role of diplomacy
    in shaping foreign policy. *Diplomatic Review*, 12(2):145–170, 2019.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Davis and Nguyen [2017] Richard Davis and Anh Nguyen. Strategic alliances and
    predictive diplomacy: A review of historical data. *Political Science Quarterly*,
    132(1):45–72, 2017.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Mahdisoltani et al. [2015] Farzaneh Mahdisoltani, Joanna Biega, and Fabian M
    Suchanek. YAGO3: A Knowledge Base from Multilingual Wikipedias. January 2015.
    CIDR 2015.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Jin et al. [2020a] Woojeong Jin, Meng Qu, Xisen Jin, and Xiang Ren. Recurrent
    Event Network: Autoregressive Structure Inference over Temporal Knowledge Graphs,
    October 2020a. EMNLP 2020.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Li et al. [2021a] Zixuan Li, Xiaolong Jin, Wei Li, Saiping Guan, Jiafeng Guo,
    Huawei Shen, Yuanzhuo Wang, and Xueqi Cheng. Temporal Knowledge Graph Reasoning
    Based on Evolutional Representation Learning, April 2021a. SIGIR 2021.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zou et al. [2022] Andy Zou, Tristan Xiao, Ryan Jia, Joe Kwon, Mantas Mazeika,
    Richard Li, Dawn Song, Jacob Steinhardt, Owain Evans, and Dan Hendrycks. Forecasting
    Future World Events with Neural Networks. arXiv, October 2022. NeurIPS 2022.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Reddy et al. [2023] Revanth Gangi Reddy, Yi R. Fung, Qi Zeng, Manling Li, Ziqi
    Wang, Paul Sullivan, and Heng Ji. SmartBook: AI-Assisted Situation Report Generation,
    March 2023. arXiv.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Galárraga et al. [2017] Luis Galárraga, Simon Razniewski, Antoine Amarilli,
    and Fabian M. Suchanek. Predicting completeness in knowledge bases. In Maarten
    de Rijke, Milad Shokouhi, Andrew Tomkins, and Min Zhang, editors, *Proceedings
    of the Tenth ACM International Conference on Web Search and Data Mining, WSDM
    2017, Cambridge, United Kingdom, February 6-10, 2017*, pages 375–383\. ACM, 2017.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Huang et al. [2024] Zijie Huang, Jeehyun Hwang, Junkai Zhang, Jinwoo Baik,
    Weitong Zhang, Dominik Wodarz, Yizhou Sun, Quanquan Gu, and Wei Wang. Causal graph
    ODE: continuous treatment effect modeling in multi-agent dynamical systems. In
    Tat-Seng Chua, Chong-Wah Ngo, Ravi Kumar, Hady W. Lauw, and Roy Ka-Wei Lee, editors,
    *Proceedings of the ACM on Web Conference 2024, WWW 2024, Singapore, May 13-17,
    2024*, pages 4607–4617\. ACM, 2024.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Mclean et al. [2009] Dr Mclean, Alan Patterson, and John Williams. Risk assessment,
    policy-making and the limits of knowledge: The precautionary principle and international
    relations. *International Relations*, 23:548–566, 12 2009.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sumers et al. [2024] Theodore R. Sumers, Shunyu Yao, Karthik Narasimhan, and
    Thomas L. Griffiths. Cognitive Architectures for Language Agents, March 2024.
    arXiv:2309.02427 [cs].
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Liu et al. [2023a] Xiao Liu, Hao Yu, Hanchen Zhang, Yifan Xu, Xuanyu Lei, Hanyu
    Lai, Yu Gu, Hangliang Ding, Kaiwen Men, Kejuan Yang, Shudan Zhang, Xiang Deng,
    Aohan Zeng, Zhengxiao Du, Chenhui Zhang, Sheng Shen, Tianjun Zhang, Yu Su, Huan
    Sun, Minlie Huang, Yuxiao Dong, and Jie Tang. AgentBench: Evaluating LLMs as Agents,
    October 2023a. arXiv:2308.03688 [cs].'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Weng [2023] Lilian Weng. LLM Powered Autonomous Agents, June 2023. Section:
    posts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[16] AutoGPT Documentation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Wang et al. [2023] Guanzhi Wang, Yuqi Xie, Yunfan Jiang, Ajay Mandlekar, Chaowei
    Xiao, Yuke Zhu, Linxi Fan, and Anima Anandkumar. Voyager: An Open-Ended Embodied
    Agent with Large Language Models, October 2023. arXiv:2305.16291 [cs].'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Shen et al. [2023] Yongliang Shen, Kaitao Song, Xu Tan, Dongsheng Li, Weiming
    Lu, and Yueting Zhuang. HuggingGPT: Solving AI Tasks with ChatGPT and its Friends
    in Hugging Face, December 2023. arXiv:2303.17580 [cs].'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lu et al. [2023a] Pan Lu, Baolin Peng, Hao Cheng, Michel Galley, Kai-Wei Chang,
    Ying Nian Wu, Song-Chun Zhu, and Jianfeng Gao. Chameleon: Plug-and-Play Compositional
    Reasoning with Large Language Models, October 2023a. arXiv:2304.09842 [cs].'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Zhuang et al. [2023a] Yuchen Zhuang, Yue Yu, Kuan Wang, Haotian Sun, and Chao
    Zhang. ToolQA: A Dataset for LLM Question Answering with External Tools, June
    2023a. arXiv:2306.13304 [cs].'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Li et al. [2023a] Minghao Li, Yingxiu Zhao, Bowen Yu, Feifan Song, Hangyu Li,
    Haiyang Yu, Zhoujun Li, Fei Huang, and Yongbin Li. API-Bank: A Comprehensive Benchmark
    for Tool-Augmented LLMs, October 2023a. arXiv:2304.08244 [cs].'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Achiam et al. [2023] Josh Achiam, Steven Adler, Sandhini Agarwal, Lama Ahmad,
    Ilge Akkaya, Florencia Leoni Aleman, Diogo Almeida, Janko Altenschmidt, Sam Altman,
    Shyamal Anadkat, et al. Gpt-4 technical report. *arXiv preprint arXiv:2303.08774*,
    2023.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Anthropic [2023] Anthropic. Claude: An ai assistant by anthropic, 2023.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'DeepMind [2023] Google DeepMind. Gemini: An ai model by google deepmind, 2023.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Touvron et al. [2023] Hugo Touvron, Thibaut Lavril, Gautier Izacard, Xavier
    Martinet, Marie-Anne Lachaux, Timothée Lacroix, Baptiste Roziere, Naman Goyal,
    Eric Hambro, Faisal Azhar, et al. Llama: Open and efficient foundation language
    models, 2023.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Yuan et al. [2023] Siyu Yuan, Jiangjie Chen, Ziquan Fu, Xuyang Ge, Soham Shah,
    Charles Robert Jankowski, Yanghua Xiao, and Deqing Yang. Distilling Script Knowledge
    from Large Language Models for Constrained Language Planning, May 2023. arXiv:2305.05252
    [cs].
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Liu et al. [2023b] Bo Liu, Yuqian Jiang, Xiaohan Zhang, Qiang Liu, Shiqi Zhang,
    Joydeep Biswas, and Peter Stone. LLM+P: Empowering Large Language Models with
    Optimal Planning Proficiency, September 2023b. arXiv:2304.11477 [cs].'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Valmeekam et al. [2023] Karthik Valmeekam, Matthew Marquez, Alberto Olmo, Sarath
    Sreedharan, and Subbarao Kambhampati. PlanBench: An Extensible Benchmark for Evaluating
    Large Language Models on Planning and Reasoning about Change, November 2023. arXiv:2206.10498
    [cs].'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ma et al. [2023a] Yunshan Ma, Chenchen Ye, Zijian Wu, Xiang Wang, Yixin Cao,
    and Tat-Seng Chua. Context-aware Event Forecasting via Graph Disentanglement.
    In *Proceedings of the 29th ACM SIGKDD Conference on Knowledge Discovery and Data
    Mining*, pages 1643–1652, August 2023a. KDD 2023.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Leetaru and Schrodt [2013] Kalev Leetaru and Philip A Schrodt. GDELT: Global
    Data on Events, Location and Tone,. 2013.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Yao et al. [2023a] Shunyu Yao, Jeffrey Zhao, Dian Yu, Nan Du, Izhak Shafran,
    Karthik R. Narasimhan, and Yuan Cao. React: Synergizing reasoning and acting in
    language models. In *The Eleventh International Conference on Learning Representations,
    ICLR 2023, Kigali, Rwanda, May 1-5, 2023*. OpenReview.net, 2023a.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boschee et al. [2015a] Elizabeth Boschee, Jennifer Lautenschlager, Sean O’Brien,
    Steve Shellman, James Starz, and Michael Ward. Cameo.cdb.09b5.pdf. In *ICEWS Coded
    Event Data*. Harvard Dataverse, 2015a.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Yao et al. [2023b] Shunyu Yao, Jeffrey Zhao, Dian Yu, Nan Du, Izhak Shafran,
    Karthik Narasimhan, and Yuan Cao. ReAct: Synergizing Reasoning and Acting in Language
    Models, March 2023b. arXiv:2210.03629 [cs].'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Laurençon et al. [2023] Hugo Laurençon, Lucile Saulnier, Léo Tronchon, Stas
    Bekman, Amanpreet Singh, Anton Lozhkov, Thomas Wang, Siddharth Karamcheti, Alexander M.
    Rush, Douwe Kiela, Matthieu Cord, and Victor Sanh. OBELICS: an open web-scale
    filtered dataset of interleaved image-text documents. In Alice Oh, Tristan Naumann,
    Amir Globerson, Kate Saenko, Moritz Hardt, and Sergey Levine, editors, *Advances
    in Neural Information Processing Systems 36: Annual Conference on Neural Information
    Processing Systems 2023, NeurIPS 2023, New Orleans, LA, USA, December 10 - 16,
    2023*, 2023.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: gpt [2023] GPT-3.5-Turbo, [https://platform.openai.com/docs/models/gpt-3-5-turbo](https://platform.openai.com/docs/models/gpt-3-5-turbo),
    2023.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wei et al. [2023] Jason Wei, Xuezhi Wang, Dale Schuurmans, Maarten Bosma, Brian
    Ichter, Fei Xia, Ed Chi, Quoc Le, and Denny Zhou. Chain-of-Thought Prompting Elicits
    Reasoning in Large Language Models, January 2023. arXiv:2201.11903 [cs].
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Kojima et al. [2022] Takeshi Kojima, Shixiang Shane Gu, Machel Reid, Yutaka
    Matsuo, and Yusuke Iwasawa. Large language models are zero-shot reasoners. In
    Sanmi Koyejo, S. Mohamed, A. Agarwal, Danielle Belgrave, K. Cho, and A. Oh, editors,
    *Advances in Neural Information Processing Systems 35: Annual Conference on Neural
    Information Processing Systems 2022, NeurIPS 2022, New Orleans, LA, USA, November
    28 - December 9, 2022*, 2022.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jiang et al. [2023] Albert Q. Jiang, Alexandre Sablayrolles, Arthur Mensch,
    Chris Bamford, Devendra Singh Chaplot, Diego de las Casas, Florian Bressand, Gianna
    Lengyel, Guillaume Lample, Lucile Saulnier, Lélio Renard Lavaud, Marie-Anne Lachaux,
    Pierre Stock, Teven Le Scao, Thibaut Lavril, Thomas Wang, Timothée Lacroix, and
    William El Sayed. Mistral 7b, 2023.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: gpt [2024] Gpt-4o contributions. 2024.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Jia et al. [2018] Zhen Jia, Abdalghani Abujabal, Rishiraj Saha Roy, Jannik
    Strötgen, and Gerhard Weikum. TempQuestions: A Benchmark for Temporal Question
    Answering. In *Companion Proceedings of the The Web Conference 2018*, WWW ’18,
    pages 1057–1062, Republic and Canton of Geneva, CHE, April 2018\. International
    World Wide Web Conferences Steering Committee. ISBN 978-1-4503-5640-4. WWW 2018.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Saxena et al. [2021] Apoorv Saxena, Soumen Chakrabarti, and Partha Talukdar.
    Question Answering Over Temporal Knowledge Graphs. In *Proceedings of the 59th
    Annual Meeting of the Association for Computational Linguistics and the 11th International
    Joint Conference on Natural Language Processing (Volume 1: Long Papers)*, pages
    6663–6676, Online, August 2021\. Association for Computational Linguistics. ACL
    2021.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Mavromatis et al. [2021] Costas Mavromatis, Prasanna Lakkur Subramanyam, Vassilis N.
    Ioannidis, Soji Adeshina, Phillip R. Howard, Tetiana Grinberg, Nagib Hakim, and
    George Karypis. TempoQR: Temporal Question Reasoning over Knowledge Graphs. arXiv,
    December 2021. AAAI 2022.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ning et al. [2020a] Qiang Ning, Hao Wu, Rujun Han, Nanyun Peng, Matt Gardner,
    and Dan Roth. TORQUE: A Reading Comprehension Dataset of Temporal Ordering Questions.
    In *Proceedings of the 2020 Conference on Empirical Methods in Natural Language
    Processing (EMNLP)*, pages 1158–1172, Online, November 2020a. Association for
    Computational Linguistics. EMNLP 2020.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Tan et al. [2023a] Qingyu Tan, Hwee Tou Ng, and Lidong Bing. Towards Benchmarking
    and Improving the Temporal Reasoning Capability of Large Language Models. In *Proceedings
    of the 61st Annual Meeting of the Association for Computational Linguistics (Volume
    1: Long Papers)*, pages 14820–14835, Toronto, Canada, July 2023a. Association
    for Computational Linguistics. ACL 2023.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Wang and Zhao [2024] Yuqing Wang and Yun Zhao. TRAM: Benchmarking Temporal
    Reasoning for Large Language Models, May 2024. arXiv:2310.00835 [cs].'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zhang et al. [2024] Zhihan Zhang, Yixin Cao, Chenchen Ye, Yunshan Ma, Lizi Liao,
    and Tat-Seng Chua. Analyzing Temporal Complex Events with Large Language Models?
    A Benchmark towards Temporal, Long Context Understanding, June 2024. arXiv:2406.02472
    [cs].
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Jin et al. [2021] Woojeong Jin, Rahul Khanna, Suji Kim, Dong-Ho Lee, Fred Morstatter,
    Aram Galstyan, and Xiang Ren. ForecastQA: A Question Answering Challenge for Event
    Forecasting with Temporal Text Data. In *Proceedings of the 59th Annual Meeting
    of the Association for Computational Linguistics and the 11th International Joint
    Conference on Natural Language Processing (Volume 1: Long Papers)*, pages 4636–4650,
    Online, August 2021\. Association for Computational Linguistics. ACL 2021.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Halawi et al. [2024] Danny Halawi, Fred Zhang, Chen Yueh-Han, and Jacob Steinhardt.
    Approaching Human-Level Forecasting with Language Models, February 2024. URL [http://arxiv.org/abs/2402.18563](http://arxiv.org/abs/2402.18563).
    arXiv:2402.18563 [cs].
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boschee et al. [2015b] Elizabeth Boschee, Jennifer Lautenschlager, Sean O’Brien,
    Steve Shellman, James Starz, and Michael Ward. Icews coded event data, 2015b.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Schoenegger et al. [2024] Philipp Schoenegger, Indre Tuminauskaite, Peter S.
    Park, and Philip E. Tetlock. Wisdom of the Silicon Crowd: LLM Ensemble Prediction
    Capabilities Rival Human Crowd Accuracy, May 2024. URL [http://arxiv.org/abs/2402.19379](http://arxiv.org/abs/2402.19379).
    arXiv:2402.19379 [cs].'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Roy and Roth [2015] Subhro Roy and Dan Roth. Solving general arithmetic word
    problems. In *Proceedings of EMNLP*, 2015.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cobbe et al. [2021] Karl Cobbe, Vineet Kosaraju, Mohammad Bavarian, Mark Chen,
    Heewoo Jun, Lukasz Kaiser, Matthias Plappert, Jerry Tworek, Jacob Hilton, Reiichiro
    Nakano, et al. Training verifiers to solve math word problems. *arXiv preprint
    arXiv:2110.14168*, 2021.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Patel et al. [2021] Arkil Patel, Satwik Bhattamishra, and Navin Goyal. Are NLP
    models really able to solve simple math word problems? In *Proceedings of NAACL*,
    2021.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Li et al. [2023b] Minghao Li, Yingxiu Zhao, Bowen Yu, Feifan Song, Hangyu Li,
    Haiyang Yu, Zhoujun Li, Fei Huang, and Yongbin Li. Api-bank: A comprehensive benchmark
    for tool-augmented llms. In *Proceedings of EMNLP*, 2023b.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Xu et al. [2023a] Qiantong Xu, Fenglu Hong, Bo Li, Changran Hu, Zhengyu Chen,
    and Jian Zhang. On the tool manipulation capability of open-source large language
    models. *arXiv preprint arXiv:2305.16504*, 2023a.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Zhuang et al. [2023b] Yuchen Zhuang, Yue Yu, Kuan Wang, Haotian Sun, and Chao
    Zhang. ToolQA: A dataset for LLM question answering with external tools. In *Proceedings
    of NeurIPS*, 2023b.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Deng et al. [2023] Xiang Deng, Yu Gu, Boyuan Zheng, Shijie Chen, Samuel Stevens,
    Boshi Wang, Huan Sun, and Yu Su. Mind2web: Towards a generalist agent for the
    web. In *Proceedings of NeurIPS*, 2023.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Zhou et al. [2024] Shuyan Zhou, Frank F Xu, Hao Zhu, Xuhui Zhou, Robert Lo,
    Abishek Sridhar, Xianyi Cheng, Yonatan Bisk, Daniel Fried, Uri Alon, et al. Webarena:
    A realistic web environment for building autonomous agents. In *Proceedings of
    ICLR*, 2024.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Liu et al. [2024] Xiao Liu, Hao Yu, Hanchen Zhang, Yifan Xu, Xuanyu Lei, Hanyu
    Lai, Yu Gu, Hangliang Ding, Kaiwen Men, Kejuan Yang, et al. Agentbench: Evaluating
    llms as agents. In *Proceedings of ICLR*, 2024.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Xie et al. [2024] Jian Xie, Kai Zhang, Jiangjie Chen, Tinghui Zhu, Renze Lou,
    Yuandong Tian, Yanghua Xiao, and Yu Su. TravelPlanner: A Benchmark for Real-World
    Planning with Language Agents, February 2024. arXiv:2402.01622 [cs].'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Radford et al. [2018] Alec Radford, Karthik Narasimhan, Tim Salimans, Ilya Sutskever,
    et al. Improving language understanding by generative pre-training. 2018.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wei et al. [2022] Jason Wei, Xuezhi Wang, Dale Schuurmans, Maarten Bosma, Brian
    Ichter, Fei Xia, Ed H. Chi, Quoc V. Le, and Denny Zhou. Chain-of-thought prompting
    elicits reasoning in large language models. In *NeurIPS*, 2022. URL [http://papers.nips.cc/paper_files/paper/2022/hash/9d5609613524ecf4f15af0f7b31abca4-Abstract-Conference.html](http://papers.nips.cc/paper_files/paper/2022/hash/9d5609613524ecf4f15af0f7b31abca4-Abstract-Conference.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Mialon et al. [2023] Grégoire Mialon, Roberto Dessì, Maria Lomeli, Christoforos
    Nalmpantis, Ram Pasunuru, Roberta Raileanu, Baptiste Rozière, Timo Schick, Jane
    Dwivedi-Yu, Asli Celikyilmaz, Edouard Grave, Yann LeCun, and Thomas Scialom. Augmented
    language models: a survey. In *arXiv preprint arXiv:2302.07842*, 2023.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Parisi et al. [2022] Aaron Parisi, Yao Zhao, and Noah Fiedel. Talm: Tool augmented
    language models. In *arXiv preprint arXiv:2205.12255*, 2022.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Schick et al. [2023] Timo Schick, Jane Dwivedi-Yu, Roberto Dessi, Roberta Raileanu,
    Maria Lomeli, Eric Hambro, Luke Zettlemoyer, Nicola Cancedda, and Thomas Scialom.
    Toolformer: Language models can teach themselves to use tools. In *Proceedings
    of NeurIPS*, 2023.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lu et al. [2023b] Pan Lu, Baolin Peng, Hao Cheng, Michel Galley, Kai-Wei Chang,
    Ying Nian Wu, Song-Chun Zhu, and Jianfeng Gao. Chameleon: Plug-and-play compositional
    reasoning with large language models. In *Proceedings of NeurIPS*, 2023b.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hu et al. [2023] Ziniu Hu, Ahmet Iscen, Chen Sun, Kai-Wei Chang, Yizhou Sun,
    David Ross, Cordelia Schmid, and Alireza Fathi. AVIS: autonomous visual information
    seeking with large language model agent. In Alice Oh, Tristan Naumann, Amir Globerson,
    Kate Saenko, Moritz Hardt, and Sergey Levine, editors, *Advances in Neural Information
    Processing Systems 36: Annual Conference on Neural Information Processing Systems
    2023, NeurIPS 2023, New Orleans, LA, USA, December 10 - 16, 2023*, 2023. URL [http://papers.nips.cc/paper_files/paper/2023/hash/029df12a9363313c3e41047844ecad94-Abstract-Conference.html](http://papers.nips.cc/paper_files/paper/2023/hash/029df12a9363313c3e41047844ecad94-Abstract-Conference.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hao et al. [2023] Shibo Hao, Tianyang Liu, Zhen Wang, and Zhiting Hu. Toolkengpt:
    Augmenting frozen language models with massive tools via tool embeddings. In Alice
    Oh, Tristan Naumann, Amir Globerson, Kate Saenko, Moritz Hardt, and Sergey Levine,
    editors, *Advances in Neural Information Processing Systems 36: Annual Conference
    on Neural Information Processing Systems 2023, NeurIPS 2023, New Orleans, LA,
    USA, December 10 - 16, 2023*, 2023. URL [http://papers.nips.cc/paper_files/paper/2023/hash/8fd1a81c882cd45f64958da6284f4a3f-Abstract-Conference.html](http://papers.nips.cc/paper_files/paper/2023/hash/8fd1a81c882cd45f64958da6284f4a3f-Abstract-Conference.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Qin et al. [2023] Yujia Qin, Shihao Liang, Yining Ye, Kunlun Zhu, Lan Yan,
    Yaxi Lu, Yankai Lin, Xin Cong, Xiangru Tang, Bill Qian, Sihan Zhao, Runchu Tian,
    Ruobing Xie, Jie Zhou, Mark Gerstein, Dahai Li, Zhiyuan Liu, and Maosong Sun.
    Toolllm: Facilitating large language models to master 16000+ real-world apis.
    *CoRR*, abs/2307.16789, 2023. doi: 10.48550/ARXIV.2307.16789. URL [https://doi.org/10.48550/arXiv.2307.16789](https://doi.org/10.48550/arXiv.2307.16789).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tan et al. [2023b] Qingyu Tan, Hwee Tou Ng, and Lidong Bing. Towards benchmarking
    and improving the temporal reasoning capability of large language models. In *ACL*,
    pages 14820–14835\. Association for Computational Linguistics, 2023b.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ning et al. [2020b] Qiang Ning, Hao Wu, Rujun Han, Nanyun Peng, Matt Gardner,
    and Dan Roth. TORQUE: A reading comprehension dataset of temporal ordering questions.
    In *EMNLP*, pages 1158–1172, 2020b.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Zhou et al. [2019] Ben Zhou, Daniel Khashabi, Qiang Ning, and Dan Roth. “going
    on a vacation” takes longer than “going for a walk”: A study of temporal commonsense
    understanding. In *EMNLP*, pages 3363–3369, 2019.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Zhang and Choi [2021] Michael Zhang and Eunsol Choi. Situatedqa: Incorporating
    extra-linguistic contexts into qa. In *EMNLP*, 2021.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Wang and Zhao [2023] Yuqing Wang and Yun Zhao. Tram: Benchmarking temporal
    reasoning for large language models. 2023.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Jin et al. [2020b] Woojeong Jin, Meng Qu, Xisen Jin, and Xiang Ren. Recurrent
    event network: Autoregressive structure inferenceover temporal knowledge graphs.
    In *EMNLP (1)*, pages 6669–6683\. Association for Computational Linguistics, 2020b.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Li et al. [2021b] Zixuan Li, Xiaolong Jin, Wei Li, Saiping Guan, Jiafeng Guo,
    Huawei Shen, Yuanzhuo Wang, and Xueqi Cheng. Temporal knowledge graph reasoning
    based on evolutional representation learning. In *SIGIR*, pages 408–417\. ACM,
    2021b.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Park et al. [2022] Namyong Park, Fuchen Liu, Purvanshi Mehta, Dana Cristofor,
    Christos Faloutsos, and Yuxiao Dong. Evokg: Jointly modeling event time and network
    structure for reasoning over temporal knowledge graphs. In *WSDM*, pages 794–803\.
    ACM, 2022.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Zhu et al. [2020] Cunchao Zhu, Muhao Chen, Changjun Fan, Guangquan Cheng, and
    Yan Zhan. Learning from history: Modeling temporal knowledge graphs with sequential
    copy-generation networks. In *AAAI Conference on Artificial Intelligence*, 2020.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sun et al. [2021] Haohai Sun, Jialu Zhong, Yunpu Ma, Zhen Han, and Kun He.
    Timetraveler: Reinforcement learning for temporal knowledge graph forecasting.
    In *EMNLP*, 2021.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Li et al. [2021c] Zixuan Li, Xiaolong Jin, Saiping Guan, Wei Li, Jiafeng Guo,
    Yuanzhuo Wang, and Xueqi Cheng. Search from history and reason for future: Two-stage
    reasoning on temporal knowledge graphs. In *ACL*, 2021c.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Trivedi et al. [2017] Rakshit Trivedi, Hanjun Dai, Yichen Wang, and Le Song.
    Know-evolve: deep temporal reasoning for dynamic knowledge graphs. In *ICML*,
    page 3462–3471, 2017.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ding et al. [2021] Zifeng Ding, Zhen Han, Yunpu Ma, and Volker Tresp. Temporal
    knowledge graph forecasting with neural ode. abs/2101.05151, 2021.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deng et al. [2020] Songgaojun Deng, Huzefa Rangwala, and Yue Ning. Dynamic knowledge
    graph based multi-event forecasting. In *KDD*, pages 1585–1595\. ACM, 2020.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deng et al. [2021] Songgaojun Deng, Huzefa Rangwala, and Yue Ning. Understanding
    event predictions via contextualized multilevel feature learning. In *CIKM*, pages
    342–351\. ACM, 2021.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ma et al. [2023b] Yunshan Ma, Chenchen Ye, Zijian Wu, Xiang Wang, Yixin Cao,
    and Tat-Seng Chua. Context-aware event forecasting via graph disentanglement.
    In *KDD*, pages 1643–1652\. ACM, 2023b.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ma et al. [2023c] Yunshan Ma, Chenchen Ye, Zijian Wu, Xiang Wang, Yixin Cao,
    Liang Pang, and Tat-Seng Chua. Structured, complex and time-complete temporal
    event forecasting. *CoRR*, abs/2312.01052, 2023c.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Xu et al. [2023b] Wenjie Xu, Ben Liu, Miao Peng, Xu Jia, and Min Peng. Pre-trained
    language model with prompts for temporal knowledge graph completion. In *ACL (Findings)*,
    pages 7790–7803\. Association for Computational Linguistics, 2023b.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lee et al. [2023] Dong-Ho Lee, Kian Ahrabian, Woojeong Jin, Fred Morstatter,
    and Jay Pujara. Temporal knowledge graph forecasting without knowledge using in-context
    learning. In *EMNLP*, pages 544–557\. Association for Computational Linguistics,
    2023.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Liao et al. [2023] Ruotong Liao, Xu Jia, Yunpu Ma, and Volker Tresp. Gentkg:
    Generative forecasting on temporal knowledge graph. *CoRR*, abs/2310.07793, 2023.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shi et al. [2023] Xiaoming Shi, Siqiao Xue, Kangrui Wang, Fan Zhou, James Y.
    Zhang, JUN ZHOU, Chenhao Tan, and Hongyuan Mei. Language models can improve event
    prediction by few-shot abductive reasoning. In *NeurIPS*, 2023.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Brown et al. [2020] Tom Brown, Benjamin Mann, Nick Ryder, Melanie Subbiah, Jared D
    Kaplan, Prafulla Dhariwal, Arvind Neelakantan, Pranav Shyam, Girish Sastry, Amanda
    Askell, et al. Language models are few-shot learners. *Advances in neural information
    processing systems*, 33:1877–1901, 2020.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Chowdhery et al. [2023] Aakanksha Chowdhery, Sharan Narang, Jacob Devlin, Maarten
    Bosma, Gaurav Mishra, Adam Roberts, Paul Barham, Hyung Won Chung, Charles Sutton,
    Sebastian Gehrmann, et al. Palm: Scaling language modeling with pathways. *Journal
    of Machine Learning Research*, 24(240):1–113, 2023.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chen et al. [2021] Mark Chen, Jerry Tworek, Heewoo Jun, Qiming Yuan, Henrique
    Ponde de Oliveira Pinto, Jared Kaplan, Harri Edwards, Yuri Burda, Nicholas Joseph,
    Greg Brockman, et al. Evaluating large language models trained on code. *arXiv
    preprint arXiv:2107.03374*, 2021.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Wang et al. [2021] Yue Wang, Weishi Wang, Shafiq Joty, and Steven CH Hoi. Codet5:
    Identifier-aware unified pre-trained encoder-decoder models for code understanding
    and generation. In *Proceedings of the 2021 Conference on Empirical Methods in
    Natural Language Processing*, pages 8696–8708, 2021.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Nijkamp et al. [2022] Erik Nijkamp, Bo Pang, Hiroaki Hayashi, Lifu Tu, Huan
    Wang, Yingbo Zhou, Silvio Savarese, and Caiming Xiong. Codegen: An open large
    language model for code with multi-turn program synthesis. *arXiv preprint arXiv:2203.13474*,
    2022.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Li et al. [2022] Yujia Li, David Choi, Junyoung Chung, Nate Kushman, Julian
    Schrittwieser, Rémi Leblond, Tom Eccles, James Keeling, Felix Gimeno, Agustin
    Dal Lago, et al. Competition-level code generation with alphacode. *Science*,
    378(6624):1092–1097, 2022.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Li et al. [2023c] Raymond Li, Loubna Ben Allal, Yangtian Zi, Niklas Muennighoff,
    Denis Kocetkov, Chenghao Mou, Marc Marone, Christopher Akiki, Jia Li, Jenny Chim,
    et al. Starcoder: may the source be with you! *arXiv preprint arXiv:2305.06161*,
    2023c.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Luo et al. [2023] Ziyang Luo, Can Xu, Pu Zhao, Qingfeng Sun, Xiubo Geng, Wenxiang
    Hu, Chongyang Tao, Jing Ma, Qingwei Lin, and Daxin Jiang. Wizardcoder: Empowering
    code large language models with evol-instruct. *arXiv preprint arXiv:2306.08568*,
    2023.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gunasekar et al. [2023] Suriya Gunasekar, Yi Zhang, Jyoti Aneja, Caio César Teodoro
    Mendes, Allie Del Giorno, Sivakanth Gopi, Mojan Javaheripi, Piero Kauffmann, Gustavo
    de Rosa, Olli Saarikivi, et al. Textbooks are all you need. *arXiv preprint arXiv:2306.11644*,
    2023.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Roziere et al. [2023] Baptiste Roziere, Jonas Gehring, Fabian Gloeckle, Sten
    Sootla, Itai Gat, Xiaoqing Ellen Tan, Yossi Adi, Jingyu Liu, Tal Remez, Jérémy
    Rapin, et al. Code llama: Open foundation models for code. *arXiv preprint arXiv:2308.12950*,
    2023.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bai et al. [2023] Jinze Bai, Shuai Bai, Yunfei Chu, Zeyu Cui, Kai Dang, Xiaodong
    Deng, Yang Fan, Wenbin Ge, Yu Han, Fei Huang, et al. Qwen technical report. *arXiv
    preprint arXiv:2309.16609*, 2023.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Guo et al. [2024] Daya Guo, Qihao Zhu, Dejian Yang, Zhenda Xie, Kai Dong, Wentao
    Zhang, Guanting Chen, Xiao Bi, Y Wu, YK Li, et al. Deepseek-coder: When the large
    language model meets programming–the rise of code intelligence. *arXiv preprint
    arXiv:2401.14196*, 2024.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Austin et al. [2021] Jacob Austin, Augustus Odena, Maxwell Nye, Maarten Bosma,
    Henryk Michalewski, David Dohan, Ellen Jiang, Carrie Cai, Michael Terry, Quoc
    Le, et al. Program synthesis with large language models. *arXiv preprint arXiv:2108.07732*,
    2021.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Appendix
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[1 Introduction](#S1 "In Mirai: Evaluating LLM Agents for Event Forecasting")'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[2 The Mirai Benchmark](#S2 "In Mirai: Evaluating LLM Agents for Event Forecasting")'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[2.1 Data and Tasks](#S2.SS1 "In 2 The Mirai Benchmark ‣ Mirai: Evaluating
    LLM Agents for Event Forecasting")'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[2.2 Agents and Environments](#S2.SS2 "In 2 The Mirai Benchmark ‣ Mirai: Evaluating
    LLM Agents for Event Forecasting")'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[2.3 Database Construction](#S2.SS3 "In 2 The Mirai Benchmark ‣ Mirai: Evaluating
    LLM Agents for Event Forecasting")'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[3 Experiments](#S3 "In Mirai: Evaluating LLM Agents for Event Forecasting")'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[3.1 Evaluate Forecasting with Different Agent Methods and Tools](#S3.SS1 "In
    3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[3.2 Evaluate Forecasting with Different Base LLMs](#S3.SS2 "In 3 Experiments
    ‣ Mirai: Evaluating LLM Agents for Event Forecasting")'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[3.3 Analyzing Agent Behaviours](#S3.SS3 "In 3.2 Evaluate Forecasting with
    Different Base LLMs ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[4 Related Work](#S4 "In 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting
    with Different Base LLMs ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event
    Forecasting")'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[4.1 Temporal Reasoning Benchmarks](#S4.SS1 "In 4 Related Work ‣ 3.3 Analyzing
    Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3 Experiments
    ‣ Mirai: Evaluating LLM Agents for Event Forecasting")'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[4.2 Evaluation of Language Agents](#S4.SS2 "In 4 Related Work ‣ 3.3 Analyzing
    Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3 Experiments
    ‣ Mirai: Evaluating LLM Agents for Event Forecasting")'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[4.3 LLMs for Tool-Use](#S4.SS3 "In 4 Related Work ‣ 3.3 Analyzing Agent Behaviours
    ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3 Experiments ‣ Mirai: Evaluating
    LLM Agents for Event Forecasting")'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[5 Conclusion and Limitation](#S5 "In 4.3 LLMs for Tool-Use ‣ 4 Related Work
    ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base
    LLMs ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[A Reproducibility Statement](#A1 "In Acknowledgements ‣ 5 Conclusion and Limitation
    ‣ 4.3 LLMs for Tool-Use ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2
    Evaluate Forecasting with Different Base LLMs ‣ 3 Experiments ‣ Mirai: Evaluating
    LLM Agents for Event Forecasting")'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[B Datasheet for MIRAI](#A2 "In Acknowledgements ‣ 5 Conclusion and Limitation
    ‣ 4.3 LLMs for Tool-Use ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2
    Evaluate Forecasting with Different Base LLMs ‣ 3 Experiments ‣ Mirai: Evaluating
    LLM Agents for Event Forecasting")'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[B.1 Motivation](#A2.SS1 "In Appendix B Datasheet for MIRAI ‣ Acknowledgements
    ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4 Related Work ‣ 3.3 Analyzing
    Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3 Experiments
    ‣ Mirai: Evaluating LLM Agents for Event Forecasting")'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[B.2 Distribution](#A2.SS2 "In Appendix B Datasheet for MIRAI ‣ Acknowledgements
    ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4 Related Work ‣ 3.3 Analyzing
    Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3 Experiments
    ‣ Mirai: Evaluating LLM Agents for Event Forecasting")'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[B.3 Maintenance](#A2.SS3 "In Appendix B Datasheet for MIRAI ‣ Acknowledgements
    ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4 Related Work ‣ 3.3 Analyzing
    Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3 Experiments
    ‣ Mirai: Evaluating LLM Agents for Event Forecasting")'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[B.4 Composition](#A2.SS4 "In Appendix B Datasheet for MIRAI ‣ Acknowledgements
    ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4 Related Work ‣ 3.3 Analyzing
    Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3 Experiments
    ‣ Mirai: Evaluating LLM Agents for Event Forecasting")'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[B.5 Collection Process](#A2.SS5 "In Appendix B Datasheet for MIRAI ‣ Acknowledgements
    ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4 Related Work ‣ 3.3 Analyzing
    Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3 Experiments
    ‣ Mirai: Evaluating LLM Agents for Event Forecasting")'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[B.6 Uses](#A2.SS6 "In Appendix B Datasheet for MIRAI ‣ Acknowledgements ‣
    5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4 Related Work ‣ 3.3 Analyzing
    Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3 Experiments
    ‣ Mirai: Evaluating LLM Agents for Event Forecasting")'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[C Limitations](#A3 "In Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3
    LLMs for Tool-Use ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate
    Forecasting with Different Base LLMs ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents
    for Event Forecasting")'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[D Additional related work](#A4 "In Acknowledgements ‣ 5 Conclusion and Limitation
    ‣ 4.3 LLMs for Tool-Use ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2
    Evaluate Forecasting with Different Base LLMs ‣ 3 Experiments ‣ Mirai: Evaluating
    LLM Agents for Event Forecasting")'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[D.1 Temporal Event Forecasting Methods](#A4.SS1 "In Appendix D Additional
    related work ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use
    ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with
    Different Base LLMs ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[D.2 LLMs for Code Generation](#A4.SS2 "In Appendix D Additional related work
    ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4 Related
    Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different
    Base LLMs ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[E Additional Details of the Database](#A5 "In Acknowledgements ‣ 5 Conclusion
    and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4 Related Work ‣ 3.3 Analyzing Agent
    Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3 Experiments
    ‣ Mirai: Evaluating LLM Agents for Event Forecasting")'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[E.1 Countries and ISO Codes](#A5.SS1 "In Appendix E Additional Details of
    the Database ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use
    ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with
    Different Base LLMs ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[E.2 Relations and CAMEO Codes](#A5.SS2 "In Appendix E Additional Details of
    the Database ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use
    ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with
    Different Base LLMs ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[F Details of Dataset Construction](#A6 "In Acknowledgements ‣ 5 Conclusion
    and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4 Related Work ‣ 3.3 Analyzing Agent
    Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3 Experiments
    ‣ Mirai: Evaluating LLM Agents for Event Forecasting")'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[G Term of Use for GDELT Dataset](#A7 "In Acknowledgements ‣ 5 Conclusion and
    Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours
    ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3 Experiments ‣ Mirai: Evaluating
    LLM Agents for Event Forecasting")'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[H Broader Impact](#A8 "In Acknowledgements ‣ 5 Conclusion and Limitation ‣
    4.3 LLMs for Tool-Use ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2
    Evaluate Forecasting with Different Base LLMs ‣ 3 Experiments ‣ Mirai: Evaluating
    LLM Agents for Event Forecasting")'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[I Additional Details about Agent Setup](#A9 "In Acknowledgements ‣ 5 Conclusion
    and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4 Related Work ‣ 3.3 Analyzing Agent
    Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3 Experiments
    ‣ Mirai: Evaluating LLM Agents for Event Forecasting")'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[J Additional Experimental Results and Analysis](#A10 "In Acknowledgements
    ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4 Related Work ‣ 3.3 Analyzing
    Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3 Experiments
    ‣ Mirai: Evaluating LLM Agents for Event Forecasting")'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[J.1 Analysis of the Final Status of Different LLM Agents](#A10.SS1 "In Appendix
    J Additional Experimental Results and Analysis ‣ Acknowledgements ‣ 5 Conclusion
    and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4 Related Work ‣ 3.3 Analyzing Agent
    Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3 Experiments
    ‣ Mirai: Evaluating LLM Agents for Event Forecasting")'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[J.2 Analysis on Function Types](#A10.SS2 "In Appendix J Additional Experimental
    Results and Analysis ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs
    for Tool-Use ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate
    Forecasting with Different Base LLMs ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents
    for Event Forecasting")'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[K Prompts](#A11 "In Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs
    for Tool-Use ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate
    Forecasting with Different Base LLMs ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents
    for Event Forecasting")'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[K.1 System Prompts](#A11.SS1 "In Appendix K Prompts ‣ Acknowledgements ‣ 5
    Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4 Related Work ‣ 3.3 Analyzing
    Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3 Experiments
    ‣ Mirai: Evaluating LLM Agents for Event Forecasting")'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[K.1.1 System Prompt for ReAct Agent with Action Type as “Single Function”](#A11.SS1.SSS1
    "In K.1 System Prompts ‣ Appendix K Prompts ‣ Acknowledgements ‣ 5 Conclusion
    and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4 Related Work ‣ 3.3 Analyzing Agent
    Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3 Experiments
    ‣ Mirai: Evaluating LLM Agents for Event Forecasting")'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[K.1.2 System Prompt for ReAct Agent with Action Type as “Code Block”](#A11.SS1.SSS2
    "In K.1 System Prompts ‣ Appendix K Prompts ‣ Acknowledgements ‣ 5 Conclusion
    and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4 Related Work ‣ 3.3 Analyzing Agent
    Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3 Experiments
    ‣ Mirai: Evaluating LLM Agents for Event Forecasting")'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[K.1.3 System Prompt for Direct Agent](#A11.SS1.SSS3 "In K.1 System Prompts
    ‣ Appendix K Prompts ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs
    for Tool-Use ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate
    Forecasting with Different Base LLMs ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents
    for Event Forecasting")'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[K.1.4 System Prompt for CoT Agent](#A11.SS1.SSS4 "In K.1 System Prompts ‣
    Appendix K Prompts ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs
    for Tool-Use ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate
    Forecasting with Different Base LLMs ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents
    for Event Forecasting")'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[K.2 Query Prompt](#A11.SS2 "In Appendix K Prompts ‣ Acknowledgements ‣ 5 Conclusion
    and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4 Related Work ‣ 3.3 Analyzing Agent
    Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3 Experiments
    ‣ Mirai: Evaluating LLM Agents for Event Forecasting")'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[K.3 Answer Extraction Prompt](#A11.SS3 "In Appendix K Prompts ‣ Acknowledgements
    ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4 Related Work ‣ 3.3 Analyzing
    Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3 Experiments
    ‣ Mirai: Evaluating LLM Agents for Event Forecasting")'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[L Additional Forecasting Examples of LLM Agent](#A12 "In Acknowledgements
    ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4 Related Work ‣ 3.3 Analyzing
    Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3 Experiments
    ‣ Mirai: Evaluating LLM Agents for Event Forecasting")'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[L.1 GPT-4o-based Agent with ReAct and “Code Block” Action](#A12.SS1 "In Appendix
    L Additional Forecasting Examples of LLM Agent ‣ Acknowledgements ‣ 5 Conclusion
    and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4 Related Work ‣ 3.3 Analyzing Agent
    Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3 Experiments
    ‣ Mirai: Evaluating LLM Agents for Event Forecasting")'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[L.1.1 Query Details](#A12.SS1.SSS1 "In L.1 GPT-4o-based Agent with ReAct and
    “Code Block” Action ‣ Appendix L Additional Forecasting Examples of LLM Agent
    ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4 Related
    Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different
    Base LLMs ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[L.1.2 Query Prompt](#A12.SS1.SSS2 "In L.1 GPT-4o-based Agent with ReAct and
    “Code Block” Action ‣ Appendix L Additional Forecasting Examples of LLM Agent
    ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4 Related
    Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different
    Base LLMs ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[L.1.3 System Prompt](#A12.SS1.SSS3 "In L.1 GPT-4o-based Agent with ReAct and
    “Code Block” Action ‣ Appendix L Additional Forecasting Examples of LLM Agent
    ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4 Related
    Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different
    Base LLMs ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[L.1.4 Agent ReAct Process](#A12.SS1.SSS4 "In L.1 GPT-4o-based Agent with ReAct
    and “Code Block” Action ‣ Appendix L Additional Forecasting Examples of LLM Agent
    ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4 Related
    Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different
    Base LLMs ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[M Additional Information about API](#A13 "In item 1 ‣ L.1.4 Agent ReAct Process
    ‣ L.1 GPT-4o-based Agent with ReAct and “Code Block” Action ‣ Appendix L Additional
    Forecasting Examples of LLM Agent ‣ Acknowledgements ‣ 5 Conclusion and Limitation
    ‣ 4.3 LLMs for Tool-Use ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2
    Evaluate Forecasting with Different Base LLMs ‣ 3 Experiments ‣ Mirai: Evaluating
    LLM Agents for Event Forecasting")'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[M.1 Overview of API Data Classes and Functions](#A13.SS1 "In Appendix M Additional
    Information about API ‣ item 1 ‣ L.1.4 Agent ReAct Process ‣ L.1 GPT-4o-based
    Agent with ReAct and “Code Block” Action ‣ Appendix L Additional Forecasting Examples
    of LLM Agent ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use
    ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with
    Different Base LLMs ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[M.2 API Specification](#A13.SS2 "In Appendix M Additional Information about
    API ‣ item 1 ‣ L.1.4 Agent ReAct Process ‣ L.1 GPT-4o-based Agent with ReAct and
    “Code Block” Action ‣ Appendix L Additional Forecasting Examples of LLM Agent
    ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4 Related
    Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different
    Base LLMs ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[M.3 API Implementation](#A13.SS3 "In Appendix M Additional Information about
    API ‣ item 1 ‣ L.1.4 Agent ReAct Process ‣ L.1 GPT-4o-based Agent with ReAct and
    “Code Block” Action ‣ Appendix L Additional Forecasting Examples of LLM Agent
    ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4 Related
    Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different
    Base LLMs ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Appendix A Reproducibility Statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We provide detailed information and explanation of our experimental setup,
    dataset, and evaluation metrics, ensuring reproducibility. Specifically, we describe
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Experimental setup (Sec. [3](#S3 "3 Experiments ‣ Mirai: Evaluating LLM Agents
    for Event Forecasting")): Detailed descriptions of the hardware and software configurations,
    including libraries and tools used.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dataset (Sec. [2](#S2 "2 The Mirai Benchmark ‣ Mirai: Evaluating LLM Agents
    for Event Forecasting") & Appendix [F](#A6 "Appendix F Details of Dataset Construction
    ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4 Related
    Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different
    Base LLMs ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")):
    Comprehensive information on the dataset used, including sources, preprocessing
    steps, and any techniques applied.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Evaluation Metrics (Sec. [2.3](#S2.SS3 "2.3 Database Construction ‣ 2 The Mirai
    Benchmark ‣ Mirai: Evaluating LLM Agents for Event Forecasting")): Clear definitions
    for the metrics chosen to evaluate performance.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Additionally, we commit to releasing the following resources for the replication
    of our results:'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Codebase: The complete codebase, including scripts for data preprocessing,
    model serving, and evaluation. This is made available on a public repository ([https://github.com/yecchen/MIRAI](https://github.com/yecchen/MIRAI)).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dataset: The processed dataset, along with detailed instructions on how to
    construct the dataset ([https://drive.google.com/file/d/1xmSEHZ_wqtBu1AwLpJ8wCDYmT-jRpfrN/view?usp=sharing](https://drive.google.com/file/d/1xmSEHZ_wqtBu1AwLpJ8wCDYmT-jRpfrN/view?usp=sharing)).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: By providing these resources, we aim to ensure that our work is fully reproducible
    and can be independently verified by the research community.
  prefs: []
  type: TYPE_NORMAL
- en: Appendix B Datasheet for MIRAI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: B.1 Motivation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For what purpose was the dataset created?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The MIRAI dataset was created to evaluate different capabilities of Large Language
    Model (LLM) agents in forecasting international events. 2. Who created the dataset
    and on behalf of which entity? The dataset was developed by a group of university
    researchers studying LLM reasoning. All rights are held by the individuals themselves,
    rather than by third-party stakeholders. 3. Who funded the creation of the dataset?
    The academic institutions support the university reasearch lab that the authors
    affiliate in.
  prefs: []
  type: TYPE_NORMAL
- en: B.2 Distribution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Will the dataset be distributed to third parties outside of the entity?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Yes, the dataset, evaluation codes and leaderboards are intended to be publicly
    available to foster future research and development. 2. How will the dataset be
    distributed? The database and codebase are currently available on [Google Drive](https://drive.google.com/file/d/1xmSEHZ_wqtBu1AwLpJ8wCDYmT-jRpfrN/view?usp=sharing)
    and [Github](https://github.com/yecchen/MIRAI). 3. Have any third parties imposed
    IP-based or other restrictions on the data associated with the instances? No,
    there are no IP-based or other restrictions on the data: MIRAI is curated based
    on the GDELT⁶⁶6[GDELT Project: https://www.gdeltproject.org/](https://www.gdeltproject.org/)
    Event Database, which is an open platform for research and analysis of global
    society and all datasets released by the GDELT Project are available for unlimited
    and unrestricted use for any academic, commercial, or governmental use of any
    kind without fee; Data are allowed for any redistribution, rehost, republish,
    and mirror of the GDELT datasets in any form, with necessary citations⁷⁷7[GDELT
    Term of Use: https://www.gdeltproject.org/about.html#termsofuse](https://www.gdeltproject.org/about.html#termsofuse).
    4. Do any export controls or other regulatory restrictions apply to the dataset
    or to individual instances? No, there are no export controls or other regulatory
    restrictions applied to this dataset. 5. When will the dataset be distributed?
    The dataset has been made publicly available with the [project website](https://mirai-llm.github.io/),
    [Google Drive](https://drive.google.com/file/d/1xmSEHZ_wqtBu1AwLpJ8wCDYmT-jRpfrN/view?usp=sharing),
    and [Github](https://github.com/yecchen/MIRAI). 6. Will the dataset be distributed
    under a copyright or other IP license, and/or under applicable terms of use (ToU)?
    The dataset will be distributed under the CC BY-NC 4.0 license, allowing for use
    and distribution for non-commercial purposes with appropriate attribution.'
  prefs: []
  type: TYPE_NORMAL
- en: B.3 Maintenance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Who will be supporting/hosting/maintaining the dataset?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The dataset maintenance will be supporting/hosting/maintaining by the authors.
    2. How can the owner/curator/manager of the dataset be contacted? The owner/curator/manager
    of the dataset can be contacted through the authors’ emails. 3. Will the dataset
    be updated? (e.g., to correct labeling errors, add new instances, delete instances)?
    Yes, the dataset will be updated whenever necessary to ensure accuracy, and announcements
    will be made accordingly. 4. If the dataset relates to people, are there applicable
    limits on the retention of the data associated with the instances (e.g., were
    the individuals in question told that their data would be retained for a fixed
    period of time and then deleted?) NA. This dataset does not contain data related
    to individuals or personal identifiers. 5. Will older version of the dataset continue
    to be supported/hosted/maintained? NA. Currently, there are no older versions
    of the dataset, as this is its first release. As the dataset evolves, the possibility
    of supporting and maintaining older versions will be considered based on community
    needs and resource availability. 6. If others want to extend/augment/build on/contribute
    to the dataset, is there a mechanism for them to do so? Researchers and developers
    interested in extending, augmenting, or contributing to the dataset are encouraged
    to submit their changes through GitHub pull requests. For additional inquiries
    or detailed discussions, contacting the authors via email is recommended.
  prefs: []
  type: TYPE_NORMAL
- en: B.4 Composition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What do the instances that comprise the dataset represent?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Each instance in the dataset represents a structured record of international
    events, including the date, involved countries, and type of event, along with
    associated news articles and metadata. 2. How many instances are there in total?
    The database comprises 991,759 GDELT event records from January 2023 to November
    2023, corresponding to 59,161 unique events and 296,630 news articles. The test
    set contains 705 relation prediction queries, and the test subset contains 100
    queries. 3. Does the dataset contain all possible instances or is it a sample
    of instances from a larger set? The dataset represents a curated sample from the
    entire GDELT database. It has been created through meticulously designed data
    cleaning and preprocessing steps aimed at enhancing the quality and reliability
    of the event data. 4. Is there a label or target associated with each instance?
    Yes, each instance in the dataset is an event labeled with a relation type derived
    from the CAMEO⁸⁸8[Conflict and Mediation Event Observations (CAMEO): https://parusanalytics.com/eventdata/data.dir/cameo.html](https://parusanalytics.com/eventdata/data.dir/cameo.html)
    event taxonomy. 5. Is any information missing from individual instances? No, all
    instances are complete with all available information. 6. Are there recommended
    data splits (e.g., training, development/validation, testing)? The dataset includes
    records from January 2023 to November 2023\. The recommended testing set is constructed
    based on records from November 2023\. For testing, each instance utilizes all
    preceding records as its historical dataset to ensure accuracy and relevance in
    analysis. 7. Are there any errors, sources of noise, or redundancies in the dataset?
    The dataset has undergone extensive cleaning and structuring to minimize errors
    and noise. However, residual noise from the original GDELT database may still
    be present. 8. Is the dataset self-contained, or does it link to or otherwise
    rely on external resources (e.g., websites, tweets, other datasets)? While the
    dataset is primarily self-contained, it includes URLs to news articles, providing
    links to external resources for further context and verification. 9. Does the
    dataset contain data that might be considered confidential? No, the dataset contains
    publicly available data and does not include confidential information. 10. Does
    the dataset contain data that, if viewed directly, might be offensive, insulting,
    threatening, or might otherwise cause anxiety? The dataset may include descriptions
    of sensitive events, such as global conflicts, due to its focus on international
    relations. However, thorough checks such as flagging word ratios are employed
    during the data cleaning process to identify and potentially exclude inappropriate
    paragraphs or entire news articles and events. This ensures the minimization of
    distressing content while maintaining the integrity and relevance of the dataset
    for academic study.'
  prefs: []
  type: TYPE_NORMAL
- en: B.5 Collection Process
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How was the data associated with each instance acquired?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Data for each instance was sourced from the GDELT project, which aggregates
    global event data and news articles from various worldwide media. Detailed information
    can be found in Section [2.3](#S2.SS3 "2.3 Database Construction ‣ 2 The Mirai
    Benchmark ‣ Mirai: Evaluating LLM Agents for Event Forecasting") and Appendix [F](#A6
    "Appendix F Details of Dataset Construction ‣ Acknowledgements ‣ 5 Conclusion
    and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4 Related Work ‣ 3.3 Analyzing Agent
    Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3 Experiments
    ‣ Mirai: Evaluating LLM Agents for Event Forecasting") of the paper. 2. What mechanisms
    or procedures were used to collect the data (e.g., hardware apparatus or sensor,
    manual human curation, software program, software API)? Data collection was facilitated
    through software programs that aggregate event data and news articles from various
    sources. This automated collection is followed by data cleaning processes to enhance
    completeness and reliability. For a detailed description of the collection and
    cleaning methods, please refer to Section [2.3](#S2.SS3 "2.3 Database Construction
    ‣ 2 The Mirai Benchmark ‣ Mirai: Evaluating LLM Agents for Event Forecasting")
    and Appendix [F](#A6 "Appendix F Details of Dataset Construction ‣ Acknowledgements
    ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4 Related Work ‣ 3.3 Analyzing
    Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3 Experiments
    ‣ Mirai: Evaluating LLM Agents for Event Forecasting") of the paper. All dataset
    construction scripts are available in [Github](https://github.com/yecchen/MIRAI)
    and also described in the README. 3. Who was involved in the data collection process?
    (e.g., students, crowdworkers, contractors) and how were they compensated (e.g.,
    how much were crowdworkers paid) The data collection and preprocessing were conducted
    by the authors, who are university researchers. This work was performed as part
    of their academic research activities. 4. Does the dataset relate to people? No.
    The dataset does not contain personal data or directly relate to individual people.
    5. Did you collect the data from the individuals in questions directly, or obtain
    it via third parties or other sources (e.g., websites)? The dataset does not involve
    data collected from individuals directly. Instead, it is curated from the GDELT
    project, which aggregates information from various global news media sources.'
  prefs: []
  type: TYPE_NORMAL
- en: B.6 Uses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Has the dataset been used for any tasks already?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The dataset has not been used for any tasks other than the ones proposed and
    examined in this current paper, specifically for benchmarking the forecasting
    capabilities of LLM agents in predicting international relations. 2. What (other)
    tasks could the dataset be used for? In addition to benchmarking LLM agents, the
    dataset could be valuable for research in geopolitics, the development of other
    event prediction algorithms, sentiment analysis of international events, and trend
    analysis in global political dynamics. 3. Is there anything about the composition
    of the dataset or the way it was collected and preprocessed/cleaned/labeled that
    might impact future uses? The dataset was meticulously collected and preprocessed
    to ensure high quality and reliability. However, the reliance on the GDELT project
    as the primary data source and the specific cleaning process applied might influence
    its applicability to certain tasks. Users should consider these factors when applying
    the dataset to different research areas or methodologies. 4. Are there tasks for
    which the dataset should not be used? The dataset should not be used for any tasks
    that violate the terms of use associated with the GDELT project.
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C Limitations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We acknowledge a few limitations in our current work. Firstly, the forecasting
    events in the test set might have been exposed to the most recently published
    LLMs, such as the gpt-4-turbo-2024-04-09, which has training data up to December
    2023\. While the background knowledge of LLMs about international relations matters
    for accurate forecasting, this benchmark still challenges them in retrieving grounded
    facts from the database and performing reliable forecasting. Secondly, many other
    base LLMs are not tested in the experiments. However, we chose some representative
    models for both open-source and closed-source LLMs, leaving more comprehensive
    tests for future work. Thirdly, while the current API covers functions like count,
    listing, and basic distribution statistics of events and news articles, more functionality
    can be added to the function pool in the future. For example, to further encourage
    the agent to analyze based on temporal trends, functions related to time series
    could be added to the API. We could also allow agents to generate and add useful
    functions to the API during their reasoning process to support a more diverse
    toolset. Fourthly, current experiments are limited by cost and time considerations.
    More rounds of experiments should be added for each different LLM and various
    settings. We observe some large variance in the experimental results, which may
    be caused by the current model temperature of 0.4 and the limited number of 5
    rounds per experiment.
  prefs: []
  type: TYPE_NORMAL
- en: Appendix D Additional related work
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: D.1 Temporal Event Forecasting Methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: LLMs have been tested for their temporal understanding through tasks such as
    temporal event ordering or storyline comprehension [[70](#bib.bib70), [71](#bib.bib71),
    [72](#bib.bib72), [73](#bib.bib73), [74](#bib.bib74)]. In the context of temporal
    forecasting, LLMs have also been evaluated on recent text-based temporal forecasting
    benchmarks [[8](#bib.bib8), [46](#bib.bib46)]. However, these evaluations typically
    involve providing LLMs with retrieved context for in-context learning and then
    directly answering the forecast question. This approach limits the interaction
    between the LLM and the database and lacks important intermediate thinking and
    reasoning steps crucial for accurate forecasting. In contrast, Mirai establishes
    a comprehensive environment that enables an LLM to act as an agent, interacting
    with the database through multiple rounds of thinking, retrieving diverse information,
    and providing a complete reasoning path to the final forecast answer. This setup
    allows for a more thorough evaluation of the LLM’s temporal reasoning capabilities
    and its ability to effectively retrieving and analyzing the available information.
  prefs: []
  type: TYPE_NORMAL
- en: Significant research has also been conducted in the field of structured event
    temporal forecasting. Various methods have been proposed, including aggregating
    temporal and relational information among entities [[75](#bib.bib75), [76](#bib.bib76),
    [77](#bib.bib77)], retrieving relevant historical events [[78](#bib.bib78), [79](#bib.bib79),
    [80](#bib.bib80)], and modeling the continuous time evolution of events [[81](#bib.bib81),
    [82](#bib.bib82)]. Efforts have also been made to incorporate textual event information
    into Temporal Knowledge Graphs (TKGs). Glean [[83](#bib.bib83)] and CMF [[84](#bib.bib84)]
    integrate textual embeddings into graph edges, while SeCoGD [[85](#bib.bib85)]
    employs textual topic modeling to separate subgraphs. The MidEast-TE dataset and
    LoGo model [[86](#bib.bib86)] utilize text clustering to construct complex events
    for forecasting with local and global contexts. However, these methods still perform
    forecast reasoning solely on graphs using graph-based techniques. Recent studies
    have explored the use of LLMs for temporal event forecasting by transforming the
    TKG formulation into text sequences and converting missing object prediction into
    next token prediction [[87](#bib.bib87)]. GPT-NeoX-ICL [[88](#bib.bib88)] employs
    in-context learning of LLMs and constructs prompts as a list of historical events
    in quadruplet format. GENTKG [[89](#bib.bib89)] enhances the selection of historical
    event inputs using a temporal logical rule-based retrieval strategy, while LAMP [[90](#bib.bib90)]
    applies LLMs to perform abductive reasoning to assist the retrieval process. However,
    these works only investigate LLMs with in-context learning or simple task-specific
    fine-tuning. In contrast, Mirai explores forecasting with an LLM agent that supports
    explicit information gathering and reasoning steps, enabling a hybrid approach
    that leverages both text and graph data.
  prefs: []
  type: TYPE_NORMAL
- en: D.2 LLMs for Code Generation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Early advancements in LLMs have greatly impacted the field of code generation.
    Notable early models such as GPT-3 [[91](#bib.bib91)] and PALM [[92](#bib.bib92)]
    have demonstrated the potential of LLMs to assist in code completion and generation.
    Subsequent models have built upon the foundation of pre-trained LLMs, further
    refining capabilities specific to code generation. This has led to the development
    of code-specific LLMs such as Codex [[93](#bib.bib93)], Code T5 [[94](#bib.bib94)],
    CodeGen [[95](#bib.bib95)], AlphaCode [[96](#bib.bib96)], StarCoder [[97](#bib.bib97)],
    WizardCoder [[98](#bib.bib98)], and phi-1 [[99](#bib.bib99)]. Moreover, code from
    open-source platforms such as GitHub has increasingly been incorporated into the
    pre-training data for recent LLMs [[25](#bib.bib25), [22](#bib.bib22)]. This integration
    has led to improved performance of LLMs such as Code Llama [[100](#bib.bib100)],
    Code-Qwen [[101](#bib.bib101)], and DeepSeek-Coder [[102](#bib.bib102)] on popular
    code-related tasks [[93](#bib.bib93), [103](#bib.bib103)].
  prefs: []
  type: TYPE_NORMAL
- en: Appendix E Additional Details of the Database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: E.1 Countries and ISO Codes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We show the ISO 3166 Alpha-3 country codes and names in Table [4](#A5.T4 "Table
    4 ‣ E.1 Countries and ISO Codes ‣ Appendix E Additional Details of the Database
    ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4 Related
    Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different
    Base LLMs ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting")
    and Table [5](#A5.T5 "Table 5 ‣ E.1 Countries and ISO Codes ‣ Appendix E Additional
    Details of the Database ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3
    LLMs for Tool-Use ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate
    Forecasting with Different Base LLMs ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents
    for Event Forecasting").'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 4: List of Countries and their ISO-3166 Alpha-3 Codes (Part 1)'
  prefs: []
  type: TYPE_NORMAL
- en: '| Code | Country | Code | Country | Code | Country |'
  prefs: []
  type: TYPE_TB
- en: '| AND | Andorra | ARE | United Arab Emirates | AFG | Afghanistan |'
  prefs: []
  type: TYPE_TB
- en: '| ATG | Antigua and Barbuda | AIA | Anguilla | ALB | Albania |'
  prefs: []
  type: TYPE_TB
- en: '| ARM | Armenia | AGO | Angola | ATA | Antarctica |'
  prefs: []
  type: TYPE_TB
- en: '| ARG | Argentina | ASM | American Samoa | AUT | Austria |'
  prefs: []
  type: TYPE_TB
- en: '| AUS | Australia | ABW | Aruba | ALA | Åland |'
  prefs: []
  type: TYPE_TB
- en: '| AZE | Azerbaijan | BIH | Bosnia and Herzegovina | BRB | Barbados |'
  prefs: []
  type: TYPE_TB
- en: '| BGD | Bangladesh | BEL | Belgium | BFA | Burkina Faso |'
  prefs: []
  type: TYPE_TB
- en: '| BGR | Bulgaria | BHR | Bahrain | BDI | Burundi |'
  prefs: []
  type: TYPE_TB
- en: '| BEN | Benin | BLM | Saint Barthélemy | BMU | Bermuda |'
  prefs: []
  type: TYPE_TB
- en: '| BRN | Brunei | BOL | Bolivia | BES | Bonaire, Sint Eustatius, and Saba |'
  prefs: []
  type: TYPE_TB
- en: '| BRA | Brazil | BHS | Bahamas | BTN | Bhutan |'
  prefs: []
  type: TYPE_TB
- en: '| BVT | Bouvet Island | BWA | Botswana | BLR | Belarus |'
  prefs: []
  type: TYPE_TB
- en: '| BLZ | Belize | CAN | Canada | CCK | Cocos (Keeling) Islands |'
  prefs: []
  type: TYPE_TB
- en: '| COD | DR Congo | CAF | Central African Republic | COG | Congo Republic |'
  prefs: []
  type: TYPE_TB
- en: '| CHE | Switzerland | CIV | Ivory Coast | COK | Cook Islands |'
  prefs: []
  type: TYPE_TB
- en: '| CHL | Chile | CMR | Cameroon | CHN | China |'
  prefs: []
  type: TYPE_TB
- en: '| COL | Colombia | CRI | Costa Rica | CUB | Cuba |'
  prefs: []
  type: TYPE_TB
- en: '| CPV | Cabo Verde | CUW | Curaçao | CXR | Christmas Island |'
  prefs: []
  type: TYPE_TB
- en: '| CYP | Cyprus | CZE | Czechia | DEU | Germany |'
  prefs: []
  type: TYPE_TB
- en: '| DJI | Djibouti | DNK | Denmark | DMA | Dominica |'
  prefs: []
  type: TYPE_TB
- en: '| DOM | Dominican Republic | DZA | Algeria | ECU | Ecuador |'
  prefs: []
  type: TYPE_TB
- en: '| EST | Estonia | EGY | Egypt | ESH | Western Sahara |'
  prefs: []
  type: TYPE_TB
- en: '| ERI | Eritrea | ESP | Spain | ETH | Ethiopia |'
  prefs: []
  type: TYPE_TB
- en: '| FIN | Finland | FJI | Fiji | FLK | Falkland Islands |'
  prefs: []
  type: TYPE_TB
- en: '| FSM | Micronesia | FRO | Faroe Islands | FRA | France |'
  prefs: []
  type: TYPE_TB
- en: '| GAB | Gabon | GBR | United Kingdom | GRD | Grenada |'
  prefs: []
  type: TYPE_TB
- en: '| GEO | Georgia | GUF | French Guiana | GGY | Guernsey |'
  prefs: []
  type: TYPE_TB
- en: '| GHA | Ghana | GIB | Gibraltar | GRL | Greenland |'
  prefs: []
  type: TYPE_TB
- en: '| GMB | The Gambia | GIN | Guinea | GLP | Guadeloupe |'
  prefs: []
  type: TYPE_TB
- en: '| GNQ | Equatorial Guinea | GRC | Greece | SGS | South Georgia and South Sandwich
    Islands |'
  prefs: []
  type: TYPE_TB
- en: '| GTM | Guatemala | GUM | Guam | GNB | Guinea-Bissau |'
  prefs: []
  type: TYPE_TB
- en: '| GUY | Guyana | HKG | Hong Kong | HMD | Heard and McDonald Islands |'
  prefs: []
  type: TYPE_TB
- en: '| HND | Honduras | HRV | Croatia | HTI | Haiti |'
  prefs: []
  type: TYPE_TB
- en: '| HUN | Hungary | IDN | Indonesia | IRL | Ireland |'
  prefs: []
  type: TYPE_TB
- en: '| ISR | Israel | IMN | Isle of Man | IND | India |'
  prefs: []
  type: TYPE_TB
- en: '| IOT | British Indian Ocean Territory | IRQ | Iraq | IRN | Iran |'
  prefs: []
  type: TYPE_TB
- en: '| ISL | Iceland | ITA | Italy | JEY | Jersey |'
  prefs: []
  type: TYPE_TB
- en: '| JAM | Jamaica | JOR | Jordan | JPN | Japan |'
  prefs: []
  type: TYPE_TB
- en: '| KEN | Kenya | KGZ | Kyrgyzstan | KHM | Cambodia |'
  prefs: []
  type: TYPE_TB
- en: '| KIR | Kiribati | COM | Comoros | KNA | St Kitts and Nevis |'
  prefs: []
  type: TYPE_TB
- en: '| PRK | North Korea | KOR | South Korea | KWT | Kuwait |'
  prefs: []
  type: TYPE_TB
- en: '| CYM | Cayman Islands | KAZ | Kazakhstan | LAO | Laos |'
  prefs: []
  type: TYPE_TB
- en: '| LBN | Lebanon | LCA | Saint Lucia | LIE | Liechtenstein |'
  prefs: []
  type: TYPE_TB
- en: '| LKA | Sri Lanka | LBR | Liberia | LSO | Lesotho |'
  prefs: []
  type: TYPE_TB
- en: '| LTU | Lithuania | LUX | Luxembourg | LVA | Latvia |'
  prefs: []
  type: TYPE_TB
- en: '| LBY | Libya | MAR | Morocco | MCO | Monaco |'
  prefs: []
  type: TYPE_TB
- en: '| MDA | Moldova | MNE | Montenegro | MAF | Saint Martin |'
  prefs: []
  type: TYPE_TB
- en: '| MDG | Madagascar | MHL | Marshall Islands | MKD | North Macedonia |'
  prefs: []
  type: TYPE_TB
- en: '| MLI | Mali | MMR | Myanmar | MNG | Mongolia |'
  prefs: []
  type: TYPE_TB
- en: '| MAC | Macao | MNP | Northern Mariana Islands | MTQ | Martinique |'
  prefs: []
  type: TYPE_TB
- en: '| MRT | Mauritania | MSR | Montserrat | MLT | Malta |'
  prefs: []
  type: TYPE_TB
- en: '| MUS | Mauritius | MDV | Maldives | MWI | Malawi |'
  prefs: []
  type: TYPE_TB
- en: '| MEX | Mexico | MYS | Malaysia | MOZ | Mozambique |'
  prefs: []
  type: TYPE_TB
- en: '| NAM | Namibia | NCL | New Caledonia | NER | Niger |'
  prefs: []
  type: TYPE_TB
- en: '| NFK | Norfolk Island | NGA | Nigeria | NIC | Nicaragua |'
  prefs: []
  type: TYPE_TB
- en: '| NLD | The Netherlands | NOR | Norway | NPL | Nepal |'
  prefs: []
  type: TYPE_TB
- en: '| NRU | Nauru | NIU | Niue | NZL | New Zealand |'
  prefs: []
  type: TYPE_TB
- en: '| OMN | Oman | PAN | Panama | PER | Peru |'
  prefs: []
  type: TYPE_TB
- en: '| PYF | French Polynesia | PNG | Papua New Guinea | PHL | Philippines |'
  prefs: []
  type: TYPE_TB
- en: '| PAK | Pakistan | POL | Poland | SPM | Saint Pierre and Miquelon |'
  prefs: []
  type: TYPE_TB
- en: '| PCN | Pitcairn Islands | PRI | Puerto Rico | PSE | Palestine |'
  prefs: []
  type: TYPE_TB
- en: '| PRT | Portugal | PLW | Palau | PRY | Paraguay |'
  prefs: []
  type: TYPE_TB
- en: '| QAT | Qatar | REU | Réunion | ROU | Romania |'
  prefs: []
  type: TYPE_TB
- en: '| SRB | Serbia | RUS | Russia | RWA | Rwanda |'
  prefs: []
  type: TYPE_TB
- en: '| SAU | Saudi Arabia | SLB | Solomon Islands | SYC | Seychelles |'
  prefs: []
  type: TYPE_TB
- en: '| SDN | Sudan | SWE | Sweden | SGP | Singapore |'
  prefs: []
  type: TYPE_TB
- en: '| SHN | Saint Helena | SVN | Slovenia | SJM | Svalbard and Jan Mayen |'
  prefs: []
  type: TYPE_TB
- en: '| SVK | Slovakia | SLE | Sierra Leone | SMR | San Marino |'
  prefs: []
  type: TYPE_TB
- en: 'Table 5: List of Countries and their ISO-3166 Alpha-3 Codes (Part 2)'
  prefs: []
  type: TYPE_NORMAL
- en: '| Code | Country | Code | Country | Code | Country |'
  prefs: []
  type: TYPE_TB
- en: '| SEN | Senegal | SOM | Somalia | SUR | Suriname |'
  prefs: []
  type: TYPE_TB
- en: '| SSD | South Sudan | STP | São Tomé and Príncipe | SLV | El Salvador |'
  prefs: []
  type: TYPE_TB
- en: '| SXM | Sint Maarten | SYR | Syria | SWZ | Eswatini |'
  prefs: []
  type: TYPE_TB
- en: '| TCA | Turks and Caicos Islands | TCD | Chad | ATF | French Southern Territories
    |'
  prefs: []
  type: TYPE_TB
- en: '| TGO | Togo | THA | Thailand | TJK | Tajikistan |'
  prefs: []
  type: TYPE_TB
- en: '| TKL | Tokelau | TLS | Timor-Leste | TKM | Turkmenistan |'
  prefs: []
  type: TYPE_TB
- en: '| TUN | Tunisia | TON | Tonga | TUR | Türkiye |'
  prefs: []
  type: TYPE_TB
- en: '| TTO | Trinidad and Tobago | TUV | Tuvalu | TWN | Taiwan |'
  prefs: []
  type: TYPE_TB
- en: '| TZA | Tanzania | UKR | Ukraine | UGA | Uganda |'
  prefs: []
  type: TYPE_TB
- en: '| UMI | U.S. Outlying Islands | USA | United States | URY | Uruguay |'
  prefs: []
  type: TYPE_TB
- en: '| UZB | Uzbekistan | VAT | Vatican City | VCT | St Vincent and Grenadines |'
  prefs: []
  type: TYPE_TB
- en: '| VEN | Venezuela | VGB | British Virgin Islands | VIR | U.S. Virgin Islands
    |'
  prefs: []
  type: TYPE_TB
- en: '| VNM | Vietnam | VUT | Vanuatu | WLF | Wallis and Futuna |'
  prefs: []
  type: TYPE_TB
- en: '| WSM | Samoa | XKX | Kosovo | YEM | Yemen |'
  prefs: []
  type: TYPE_TB
- en: '| MYT | Mayotte | ZAF | South Africa | ZMB | Zambia |'
  prefs: []
  type: TYPE_TB
- en: '| ZWE | Zimbabwe |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: E.2 Relations and CAMEO Codes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We show the CAMEO relation codes and names, where the first-level relations
    are in two digits, and the second-level relations are in three digits with the
    first two digits be the same as its parent relation:'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '01: Make public statement'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '010: Make statement, not specified'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '011: Decline comment'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '012: Make pessimistic comment'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '013: Make optimistic comment'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '014: Consider policy option'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '015: Acknowledge or claim responsibility'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '016: Reject accusation or deny responsibility'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '017: Engage in symbolic act'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '018: Make empathetic comment'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '019: Express accord'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '02: Appeal'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '020: Make an appeal or request, not specified'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '021: Appeal for material cooperation'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '022: Appeal for diplomatic cooperation'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '023: Appeal for material aid'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '024: Appeal for political reform'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '025: Appeal to yield'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '026: Appeal to others to meet or negotiate'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '027: Appeal to others to settle dispute'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '028: Appeal to others to engage in or accept mediation'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '03: Express intent to cooperate'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '030: Express intent to cooperate, not specified'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '031: Express intent to engage in material cooperation'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '032: Express intent to engage in diplomatic cooperation'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '033: Express intent to provide material aid'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '034: Express intent to institute political reform'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '035: Express intent to yield'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '036: Express intent to meet or negotiate'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '037: Express intent to settle dispute'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '038: Express intent to accept mediation'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '039: Express intent to mediate'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '04: Consult'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '040: Consult, not specified'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '041: Discuss by telephone'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '042: Make a visit'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '043: Host a visit'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '044: Meet at a third location'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '045: Engage in mediation'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '046: Engage in negotiation'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '05: Engage in diplomatic cooperation'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 050:Engage in diplomatic cooperation, not specified
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '051: Praise or endorse'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '052: Defend verbally'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '053: Rally support on behalf of'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '054: Grant diplomatic recognition'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '055: Apologize'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '056: Forgive'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '057: Sign formal agreement'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '06: Engage in material cooperation'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '060: Engage in material cooperation, not specified'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '061: Cooperate economically'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '062: Cooperate militarily'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '063: Engage in judicial cooperation'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '064: Share intelligence or information'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '07: Provide aid'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '070: Provide aid, not specified'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '071: Provide economic aid'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '072: Provide military aid'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '073: Provide humanitarian aid'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '074: Provide military protection or peacekeeping'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '075: Grant asylum'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '08: Yield'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '080: Yield, not specified'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '081: Ease administrative sanctions'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '082: Ease political dissent'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '083: Accede to requests or demands for political reform'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '084: Return or release'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '085: Ease economic sanction or boycott or embargo'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '086: Allow international involvement'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '087: De-escalate military engagement'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '09: Investigate'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '090: Investigate, not specified'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '091: Investigate crime or corruption'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '092: Investigate human rights abuses'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '093: Investigate military action'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '094: Investigate war crimes'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '10: Demand'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '100: Demand, not specified'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '101: Demand material cooperation'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '102: Demand for diplomatic cooperation'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '103: Demand material aid'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '104: Demand political reform'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '105: Demand that target yield'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '106: Demand meeting or negotiation'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '107: Demand settling of dispute'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '108: Demand mediation'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '11: Disapprove'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '110: Disapprove, not specified'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '111: Criticize or denounce'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '112: Accuse'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '113: Rally opposition against'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '114: Complain officially'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '115: Bring lawsuit against'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '116: Find guilty or liable (legally)'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '12: Reject'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '120: All rejections and refusals'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '121: Reject material cooperation'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '122: Reject request or demand for material aid'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '123: Reject request or demand for political reform'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '124: Refuse to yield'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '125: Reject proposal to meet or discuss or negotiate'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '126: Reject mediation'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '127: Reject plan or agreement to settle dispute'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '128: Defy norms or law'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '129: Veto'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '13: Threaten'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '130: Threaten, not specified'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '131: Threaten non-force'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '132: Threaten with administrative sanctions'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '133: Threaten political dissent'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '134: Threaten to halt negotiations'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '135: Threaten to halt mediation'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '136: Threaten to halt international involvement'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '137: Threaten with repression'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '138: Threaten with military force'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '139: Give ultimatum'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '14: Protest'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '140: Engage in political dissent, not specified'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '141: Demonstrate or rally'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '142: Conduct hunger strike'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '143: Conduct strike or boycott'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '144: Obstruct passage or block'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '145: Protest violently or riot'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '15: Exhibit military posture'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '150: Exhibit military or police power, not specified'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '151: Increase police alert status'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '152: Increase military alert status'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '153: Mobilize or increase police power'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '154: Mobilize or increase armed forces'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '155: Mobilize or increase cyber-forces'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '16: Reduce relations'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '160: Reduce relations, not specified'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '161: Reduce or break diplomatic relations'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '162: Reduce or stop material aid'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '163: Impose embargo or boycott or sanctions'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '164: Halt negotiations'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '165: Halt mediation'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '166: Expel or withdraw'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '17: Coerce'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '170: Coerce'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '171: Seize or damage property'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '172: Impose administrative sanctions'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '173: Arrest or detain'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '174: Expel or deport individuals'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '175: Use repression'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '176: Attack cybernetically'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '18: Assault'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '180: Use unconventional violence, not specified'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '181: Abduct or hijack or take hostage'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '182: Physically assault'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '183: Conduct suicide or car or other non-military bombing'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '184: Use as human shield'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '185: Attempt to assassinate'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '186: Assassinate'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '19: Fight'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '190: Use conventional military force, not specified'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '191: Impose blockade or restrict movement'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '192: Occupy territory'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '193: Fight with small arms and light weapons'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '194: Fight with artillery and tanks'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '195: Employ aerial weapons'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '196: Violate ceasefire'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '20: Engage in unconventional mass violence'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '200: Use massive unconventional force, not specified'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '201: Engage in mass expulsion'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '202: Engage in mass killings'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '203: Engage in ethnic cleansing'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: –
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '204: Use weapons of mass destruction'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Appendix F Details of Dataset Construction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We construct the database based on the GDELT⁹⁹9[https://www.gdeltproject.org/](https://www.gdeltproject.org/)
    project, which systematically captures global news media, extracts information
    about countries and events mentioned, and updates this data every 15 minutes.
    The data stored in GDLET contains attributes about the event date, actor, action
    (relation), geography, and source news. The original GDELT dataset, while extensive,
    contains significant noise due to its rapid update frequency and the diverse nature
    of its sources. We thus propose the folowing data-cleaning pre-processing steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Events. We focus on the GDELT data from Jan. 1, 2023, to Nov. 30, 2023\. To
    mitigate potential information leakage, we ensured that the event date coincided
    exactly with its source news publish date. We standardized the CountryCode to
    the ISO-3166 and excluded any missing or outdated entries. As our analysis was
    restricted to international events, we then filte out all domestic events where
    the subject was identical to the object at the country level. The EventCode was
    standardized to the second level of the CAMEO ontology, providing a specific yet
    consistent level of detail. We opted not to include third-level relation information
    for two primary reasons: the absence of sublevel relations for all second-level
    categories, which introduces inconsistencies, and the higher likelihood of extraction
    errors in the finely detailed third-level data in the GDELT dataset.'
  prefs: []
  type: TYPE_NORMAL
- en: News articles. To enhance the reliability of the information, we utilized the
    news sources of the events to assess credibility. Specifically, we calculated
    the daily mentions of each event—defined as the number of distinct news sources
    discussing the event—based on the 15-minute updates from GDELT. We only retained
    events with at least 50 daily mentions to diminish the influence of less reliable
    sources, such as personal blogs or advertisements, and to decrease the incidence
    of erroneously extracted events. We then download the news documents from the
    corresponding news URLs of each event. In the current database, we only keep textual
    information from the news, including new titles and news content. Following the
    OBELICS [[34](#bib.bib34)] protocol for web text cleaning, we applied rigorous
    filters at both the paragraph and document levels, targeting criteria such as
    a low number of words, high repetition ratios of characters and words, and an
    excessive presence of special characters and flagged words. These measures were
    crucial in significantly reducing the noise from web content.
  prefs: []
  type: TYPE_NORMAL
- en: Appendix G Term of Use for GDELT Dataset
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Based on [https://www.gdeltproject.org/about.html#termsofuse](https://www.gdeltproject.org/about.html#termsofuse),
    GDELT dataset “is an open platform for research and analysis of global society
    and thus all datasets released by the GDELT Project are available for unlimited
    and unrestricted use for any academic, commercial, or governmental use of any
    kind without fee.”, as long as “any use or redistribution of the data must include
    a citation to the GDELT Project and a link to this website ([https://www.gdeltproject.org/](https://www.gdeltproject.org/)).”,
    which we’ve cited in abstract.
  prefs: []
  type: TYPE_NORMAL
- en: Appendix H Broader Impact
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Positive impact.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This paper aims to construct high-level and high-quality instruction to improve
    the scientific reasoning capability of LLMs, which helps LLMs to better give the
    answers to questions at the college level. Collecting diverse instructions, annotating
    self-reflective instructions, and filtering out low-quality instructions provide
    researchers insights to prepare training datasets.
  prefs: []
  type: TYPE_NORMAL
- en: Negative impact.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A drawback of this work is that the scale of the training dataset and model
    is relatively small, and we can address this by bootstrapping a more large training
    dataset. We believe that the benefits of data generation manner outweigh the downside.
  prefs: []
  type: TYPE_NORMAL
- en: Appendix I Additional Details about Agent Setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Final answer extraction. Our agent has two stopping criteria: 1) The agent
    makes the final answer. 2) The reasoning process fails to reach an answer (Consecutive
    Invalid Actions, Consecutive Repetitive Actions, or Max Iterations Exceeded).
    Afterwards, we always perform an answer extraction step, which is performed by
    gpt-3.5-turbo. The prompt for answer extraction is shown in Appendix [K.3](#A11.SS3
    "K.3 Answer Extraction Prompt ‣ Appendix K Prompts ‣ Acknowledgements ‣ 5 Conclusion
    and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4 Related Work ‣ 3.3 Analyzing Agent
    Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3 Experiments
    ‣ Mirai: Evaluating LLM Agents for Event Forecasting").'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix J Additional Experimental Results and Analysis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: J.1 Analysis of the Final Status of Different LLM Agents
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Table 6: Average number of ReAct iterations and the number of test cases ending
    in different final status.'
  prefs: []
  type: TYPE_NORMAL
- en: '| Model | Training Data |  |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| Cutoff Date | Action Type | Avg. Iterations | Final Status |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '|  |  |  |  | Final Answer | Consecutive |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| Invalid Actions | Consecutive |  |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| Repetitive Actions | Max Iterations |  |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| Exceeded |  |  |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| Mistral-7B | — | Single Function | 4.23 | 79 | 19 | 2 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | Code Block | 2.84 | 54 | 45 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| gpt-3.5-turbo | 2021-09 | Single Function | 2.54 | 98 | 1 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | Code Block | 3.43 | 84 | 15 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| gpt-4-turbo | 2023-12 | Single Function | 8.76 | 99 | 0 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | Code Block | 4.68 | 93 | 5 | 2 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| gpt-4o | 2023-10 | Single Function | 8.79 | 98 | 0 | 0 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | Code Block | 5.58 | 95 | 4 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: 'Following the experiment on different base LLMs in Sec. [3.2](#S3.SS2 "3.2
    Evaluate Forecasting with Different Base LLMs ‣ 3 Experiments ‣ Mirai: Evaluating
    LLM Agents for Event Forecasting"), we further analyze the final status of the
    agent when it triggers the termination conditions in the ReAct process. The agent-environment
    interactions were terminated based on four different statuses:'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Final Answer: This status is triggered when the model explicitly indicates
    completion by declaring a "final answer," indicating that it has generated its
    final forecast.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consecutive Invalid Actions: Interaction is halted if the model consecutively
    executes non-executable actions more than three times.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consecutive Repetitive Actions: A similar threshold of three consecutive repetitive
    actions prompts termination under this status.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Maximum Iterations Exceeded: Termination occurs if the agent engages in more
    than 20 rounds of iterations without making a forecast answer.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We show the final status 1) The GPT series demonstrates enhanced capability
    in concluding interactions with a final answer: The GPT series frequently concludes
    interactions with a final answer, indicating its superior ability to comprehend
    instructions, utilize tools correctly, and perform reasoning to generate the final
    forecast. In contrast, the smaller open-source model, Mistral-7b, has a round
    one-quarter of cases and one-half of the cases generating consecutive invalid
    answers when using single function and code block, respectively, suggesting limited
    abilities in adhering to data types, functions, Python syntax, and following detailed
    instructions.'
  prefs: []
  type: TYPE_NORMAL
- en: '2) Generating code blocks proves more challenging than generating single functions
    as action: Across all models, there is a higher occurrence of errors when generating
    code blocks compared to single functions. This pattern highlights the greater
    complexity and increased likelihood of errors associated with composing multiple
    lines of code over simple function calls.'
  prefs: []
  type: TYPE_NORMAL
- en: '3) Advanced models engage in more extensive information gathering, resulting
    in better forecasting performance: Advanced models, such as GPT-4 Turbo and GPT-4o,
    engage in significantly more information gathering, with average iterations much
    more or even double than GPT-3.5 Turbo and Mistral-7B. This intensive data collection
    from the database may contribute to their enhanced performance, as previously
    illustrated in Table [3.2](#S3.SS2 "3.2 Evaluate Forecasting with Different Base
    LLMs ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents for Event Forecasting"). These
    models exhibit better planning capability, effectively identifying and searching
    for related historical information.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Refer to caption](img/e2ccbf165ab1f373cd0518927f6dbde1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8: Correlation of F1 Accuracy to Action Sequence Length'
  prefs: []
  type: TYPE_NORMAL
- en: J.2 Analysis on Function Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Appendix K Prompts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: K.1 System Prompts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The system prompt provides the necessary background information, task description,
    and guidelines for the LLM agent. In our case, we introduce the forecasting task,
    basic information of the database, the defined API, and the planning strategies
    in the system prompt.
  prefs: []
  type: TYPE_NORMAL
- en: K.1.1 System Prompt for ReAct Agent with Action Type as “Single Function”
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '<svg id="A11.SS1.SSS1.p1.pic1" class="ltx_picture" height="675.21" overflow="visible"
    version="1.1" width="600"><g transform="translate(0,675.21) matrix(1 0 0 -1 0
    0)" fill="#000000" stroke="#000000" stroke-width="0.4pt"><g fill-opacity="1.0"
    transform="matrix(1.0 0.0 0.0 1.0 21.65 655.47)"><foreignobject width="556.69"
    height="13.84" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible" color="#FFFFFF">System
    prompt for ReAct agent with action type as single function (part 1)</foreignobject></g>
    <g fill-opacity="1.0" transform="matrix(1.0 0.0 0.0 1.0 21.65 13.78)"><foreignobject
    width="556.69" height="623.97" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible"
    color="#000000">You are an expert in forecasting future events based on historical
    data. The database contains news articles from January 1, 2023 to the current
    date {current_date_nlp} and the events extracted from these articles. The events
    are in the form of (date, subject country, relation, object country), where the
    countries are represented by ISO 3166-1 alpha-3 codes and the relations are represented
    by the CAMEO codes defined in the ‘Conflict and Mediation Event Observations’
    ontology. The relations are hierarchical: first-level relations are general parent
    relations represented by two-digit CAMEO codes, while second-level relations are
    more specific child relations represented by three-digit CAMEO codes. Child relations
    have the same first two digits as their parent relations. For example, ‘01’ is
    a first-level relation, and ‘010’ and ‘011’ are some of its second-level relations.
    The relations in the database are represented in the second-level form. Your task
    is to forecast the future relations between two entities in a given query. You
    have access to a defined Python API that allows you to query the database for
    historical events and statistics, and to get precise information about the ISO
    country codes and CAMEO relation codes. The defined API is described as follows:
    [PRE0] You will use an iterative approach, interleaving ’Thought’, ’Action’, and
    ’Observation’ steps to collect information and perform the forecast. You may perform
    up to {max_iterations} iterations. The steps are as follows: - ‘Thought’: Analyze
    the current information and reason about the current situation, and predicts which
    API you want to use (try to use different APIs to collect diverse information)
    or make a decision that you want to make a final answer. - ‘Action’: Use the API
    to gather more information or provide the final forecast. - If using the API:
    the action must be only one single line of exactly one function        call from
    the API with appropriate inputs, without additional code, explanations, or       
    natural language descriptions. - If making the final forecast: the action must
    start immediately with ‘Final Answer:’,        and follow with the results in
    the expected JSON format. - ‘Observation’: Return the output of the called function.
    To make a reasonable forecast, you should collect both news and relational evidence
    to support your prediction. When you are fully confident that you accumulate enough
    information to make the final forecast, you should start the ‘Thought’ with your
    reasoning using the news and structural information to make the prediction, and
    then start the ‘Action’ step with ‘Final Answer:’ followed by the answer in the
    expected JSON format. The answer should be a JSON dictionary where the keys are
    the forecasted two-digit first-level CAMEO codes and the values are lists of forecasted
    three-digit second-level CAMEO codes that are child relations of the key. For
    example, ‘Action: Final Answer: "01": ["010", "011", "012"], "02": ["020", "023"]’.</foreignobject></g></g></svg><svg
    id="A11.SS1.SSS1.p2.pic1" class="ltx_picture" height="163.16" overflow="visible"
    version="1.1" width="600"><g transform="translate(0,163.16) matrix(1 0 0 -1 0
    0)" fill="#000000" stroke="#000000" stroke-width="0.4pt"><g fill-opacity="1.0"
    transform="matrix(1.0 0.0 0.0 1.0 21.65 143.42)"><foreignobject width="556.69"
    height="13.84" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible" color="#FFFFFF">System
    prompt for ReAct agent with action type as single function (part 2)</foreignobject></g>
    <g fill-opacity="1.0" transform="matrix(1.0 0.0 0.0 1.0 21.65 13.78)"><foreignobject
    width="556.69" height="111.93" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible"
    color="#000000">The final answer will be evaluated based on the precision and
    recall of the forecasted first-level and second-level relations, so only include
    confident first-level and second-level CAMEO codes in your final forecast. Try
    to use different APIs to collect diverse information (including multi-hop relations),
    such as the precise meaning of CAMEO codes, insights from news content, relational
    data, and statistical analyses to support your forecasts. Consider not only the
    frequency of the relations but also the temporal aspects of the data when making
    your forecast.</foreignobject></g></g></svg>'
  prefs: []
  type: TYPE_NORMAL
- en: K.1.2 System Prompt for ReAct Agent with Action Type as “Code Block”
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '<svg id="A11.SS1.SSS2.p1.pic1" class="ltx_picture" height="644.69" overflow="visible"
    version="1.1" width="600"><g transform="translate(0,644.69) matrix(1 0 0 -1 0
    0)" fill="#000000" stroke="#000000" stroke-width="0.4pt"><g fill-opacity="1.0"
    transform="matrix(1.0 0.0 0.0 1.0 21.65 624.95)"><foreignobject width="556.69"
    height="13.84" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible" color="#FFFFFF">System
    prompt for ReAct agent with action type as code block (part 1)</foreignobject></g>
    <g fill-opacity="1.0" transform="matrix(1.0 0.0 0.0 1.0 21.65 13.78)"><foreignobject
    width="556.69" height="593.45" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible"
    color="#000000">You are an expert in forecasting future events based on historical
    data. The database contains news articles from January 1, 2023 to the current
    date {current_date_nlp} and the events extracted from these articles. The events
    are in the form of (date, subject country, relation, object country), where the
    countries are represented by ISO 3166-1 alpha-3 codes and the relations are represented
    by the CAMEO codes defined in the ‘Conflict and Mediation Event Observations’
    ontology. The relations are hierarchical: first-level relations are general parent
    relations represented by two-digit CAMEO codes, while second-level relations are
    more specific child relations represented by three-digit CAMEO codes. Child relations
    have the same first two digits as their parent relations. For example, ‘01’ is
    a first-level relation, and ‘010’ and ‘011’ are some of its second-level relations.
    The relations in the database are represented in the second-level form. Your task
    is to forecast the future relations between two entities in a given query. You
    have access to a defined Python API that allows you to query the database for
    historical events and statistics, and to get precise information about the ISO
    country codes and CAMEO relation codes. You are also authorized to utilize additional
    safe, well-established Python libraries such as numpy, pandas, scikit-learn, and
    NetworkX to enhance your data analysis and forecasting accuracy. The defined API
    is described as follows: [PRE1] You will use an iterative approach, interleaving
    ‘Thought’, ‘Action’, and ‘Observation’ steps to collect information and perform
    the forecast. You may perform up to max_iterations iterations. The steps are as
    follows: - ‘Thought’: Analyze the current information and reason about the current
    situation, and predicts which API you want to use (try to use different APIs to
    collect diverse information) or make a decision that you want to make a final
    answer. - ‘Action’: Use the API to gather more information or provide the final
    forecast. - If gathering more data: the action must be an executable Python code
    snippet that        starts with ‘[PRE2]’. It can contain multiple lines of codes
    and        function calls using the defined API or Python libraries. You must
    use print() to output        the results, and only the printed output will be
    returned in the observation step. - If making the final forecast: the action must
    start immediately with ‘Final Answer:’,        and follow with the answer in the
    expected JSON format. This should not be enclosed        within triple backticks.
    - ‘Observation’: Return the printed output of the executed code snippet.</foreignobject></g></g></svg><svg
    id="A11.SS1.SSS2.p2.pic1" class="ltx_picture" height="316.91" overflow="visible"
    version="1.1" width="600"><g transform="translate(0,316.91) matrix(1 0 0 -1 0
    0)" fill="#000000" stroke="#000000" stroke-width="0.4pt"><g fill-opacity="1.0"
    transform="matrix(1.0 0.0 0.0 1.0 21.65 297.17)"><foreignobject width="556.69"
    height="13.84" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible" color="#FFFFFF">System
    prompt for ReAct agent with action type as code block (part 2)</foreignobject></g>
    <g fill-opacity="1.0" transform="matrix(1.0 0.0 0.0 1.0 21.65 13.78)"><foreignobject
    width="556.69" height="265.67" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible"
    color="#000000">To make a reasonable forecast, you should collect both news and
    relational evidence to support your prediction. When you are fully confident that
    you accumulate enough information to make the final forecast, you should start
    the ‘Thought’ with your reasoning using the news and structural information to
    make the prediction, and then start the ‘Action’ step with ‘Final Answer:’ followed
    by the answer in the expected JSON format. The answer should be a JSON dictionary
    where the keys are the forecasted two-digit first-level CAMEO codes and the values
    are lists of forecasted three-digit second-level CAMEO codes that are child relations
    of the key. For example, ‘Action: Final Answer: {"01": ["010", "011", "012"],
    "02": ["020", "023"]}’. The final answer will be evaluated based on the precision
    and recall of the forecasted first-level and second-level relations, so only include
    confident first-level and second-level CAMEO codes in your final forecast. Try
    to use different APIs and Python libraries to collect diverse information (including
    multi-hop relations), such as the precise meaning of CAMEO codes, insights from
    news content, relational data, and statistical analyses to support your forecasts.
    Consider not only the frequency of the relations but also the temporal aspects
    of the data when making your forecast.</foreignobject></g></g></svg>'
  prefs: []
  type: TYPE_NORMAL
- en: K.1.3 System Prompt for Direct Agent
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '<svg id="A11.SS1.SSS3.p1.pic1" class="ltx_picture" height="327.67" overflow="visible"
    version="1.1" width="600"><g transform="translate(0,327.67) matrix(1 0 0 -1 0
    0)" fill="#000000" stroke="#000000" stroke-width="0.4pt"><g fill-opacity="1.0"
    transform="matrix(1.0 0.0 0.0 1.0 21.65 309.47)"><foreignobject width="556.69"
    height="12.3" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible" color="#FFFFFF">System
    prompt for direct agent</foreignobject></g> <g fill-opacity="1.0" transform="matrix(1.0
    0.0 0.0 1.0 21.65 13.78)"><foreignobject width="556.69" height="277.97" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible" color="#000000">You are an expert in forecasting
    future events based on historical data. The events are in the form of (date, subject
    country, relation, object country), where the countries are represented by ISO
    3166-1 alpha-3 codes and the relations are represented by the CAMEO codes defined
    in the ‘Conflict and Mediation Event Observations’ ontology. The relations are
    hierarchical: first-level relations are general parent relations represented by
    two-digit CAMEO codes, while second-level relations are more specific child relations
    represented by three-digit CAMEO codes. Child relations have the same first two
    digits as their parent relations. For example, ‘01’ is a first-level relation,
    and ‘010’ and ‘011’ are some of its second-level relations. The relations in the
    database are represented in the second-level form. Your task is to forecast the
    future relations between two entities in a given query. The answer should be a
    JSON dictionary where the keys are the forecasted two-digit first-level CAMEO
    codes and the values are lists of forecasted three-digit second-level CAMEO codes
    that are child relations of the key. For example, ‘Final Answer: {{“01”: [“010”,
    “011”, “012”], “02”: [“020”, “023”]}}’. The final answer will be evaluated based
    on the precision and recall of the forecasted first-level and second-level relations,
    so only include confident first-level and second-level CAMEO codes in your final
    forecast.</foreignobject></g></g></svg>'
  prefs: []
  type: TYPE_NORMAL
- en: K.1.4 System Prompt for CoT Agent
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '<svg id="A11.SS1.SSS4.p1.pic1" class="ltx_picture" height="377.48" overflow="visible"
    version="1.1" width="600"><g transform="translate(0,377.48) matrix(1 0 0 -1 0
    0)" fill="#000000" stroke="#000000" stroke-width="0.4pt"><g fill-opacity="1.0"
    transform="matrix(1.0 0.0 0.0 1.0 21.65 359.28)"><foreignobject width="556.69"
    height="12.3" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible" color="#FFFFFF">System
    prompt for CoT</foreignobject></g> <g fill-opacity="1.0" transform="matrix(1.0
    0.0 0.0 1.0 21.65 13.78)"><foreignobject width="556.69" height="327.78" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible" color="#000000">You are an expert in forecasting
    future events based on historical data. The events are in the form of (date, subject
    country, relation, object country), where the countries are represented by ISO
    3166-1 alpha-3 codes and the relations are represented by the CAMEO codes defined
    in the ‘Conflict and Mediation Event Observations’ ontology. The relations are
    hierarchical: first-level relations are general parent relations represented by
    two-digit CAMEO codes, while second-level relations are more specific child relations
    represented by three-digit CAMEO codes. Child relations have the same first two
    digits as their parent relations. For example, ‘01’ is a first-level relation,
    and ‘010’ and ‘011’ are some of its second-level relations. The relations in the
    database are represented in the second-level form. Your task is to forecast the
    future relations between two entities in a given query. To make a reasonable forecast,
    you should first think and reason based on your background knowledge. When you
    are confident that you have conducted enough analysis to make the final answer,
    you should start answering by ’Therefore, the final answer is:‘ followed by the
    answer in the expected JSON format. The JSON format should be a JSON dictionary
    where the keys are the forecasted two-digit first-level CAMEO codes and the values
    are lists of forecasted three-digit second-level CAMEO codes that are child relations
    of the key. For example, ‘{{“01”: [“010”, “011”, “012”], “02”: [“020”, “023”]}}’.
    The final answer will be evaluated based on the precision and recall of the forecasted
    first-level and second-level relations, so only include confident first-level
    and second-level CAMEO codes in your final forecast.</foreignobject></g></g></svg>'
  prefs: []
  type: TYPE_NORMAL
- en: K.2 Query Prompt
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <svg id="A11.SS2.p1.pic1" class="ltx_picture" height="113.2" overflow="visible"
    version="1.1" width="600"><g transform="translate(0,113.2) matrix(1 0 0 -1 0 0)"
    fill="#000000" stroke="#000000" stroke-width="0.4pt"><g fill-opacity="1.0" transform="matrix(1.0
    0.0 0.0 1.0 21.65 95.15)"><foreignobject width="556.69" height="12.15" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible" color="#FFFFFF">Query prompt</foreignobject></g>
    <g fill-opacity="1.0" transform="matrix(1.0 0.0 0.0 1.0 21.65 13.78)"><foreignobject
    width="556.69" height="63.65" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible"
    color="#000000">Please forecast the relations that {actor1_name} will take towards
    {actor2_name} on {future_date_nlp} based on historical information up to {current_date_nlp}.
    I.e. forecast the relation CAMEO codes in query event Event(date={future_date},
    head_entity=ISOCode({actor1_code}), relation=CAMEOCode(?), tail_entity=ISOCode({actor2_code})).</foreignobject></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: K.3 Answer Extraction Prompt
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '<svg id="A11.SS3.p1.pic1" class="ltx_picture" height="543.37" overflow="visible"
    version="1.1" width="600"><g transform="translate(0,543.37) matrix(1 0 0 -1 0
    0)" fill="#000000" stroke="#000000" stroke-width="0.4pt"><g fill-opacity="1.0"
    transform="matrix(1.0 0.0 0.0 1.0 21.65 525.32)"><foreignobject width="556.69"
    height="12.15" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible" color="#FFFFFF">Answer
    extraction prompt</foreignobject></g> <g fill-opacity="1.0" transform="matrix(1.0
    0.0 0.0 1.0 21.65 13.78)"><foreignobject width="556.69" height="493.83" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible" color="#000000">Please help me extract final
    answer for forecasting the future relations between two entities in a given query:
    forecast the relations that {actor1_name} will take towards {actor2_name} on {future_date_nlp}
    based on historical information up to current_date_nlp. I.e. forecast the relation
    CAMEO codes in query event Event(date={future_date}, head_entity=ISOCode({actor1_code}),
    relation=CAMEOCode(?), tail_entity=ISOCode({actor2_code})). I have used interleaving
    ‘Thought’, ‘Action’, and ‘Observation’ steps to collect information from the database
    and perform the forecast. The database contains news articles from January 1,
    2023 to the current date current_date_nlp and the events extracted from these
    articles. The events are in the form of (date, subject country, relation, object
    country), where the countries are represented by ISO 3166-1 alpha-3 codes and
    the relations are represented by the CAMEO codes defined in the ‘Conflict and
    Mediation Event Observations’ ontology. The relations are hierarchical: first-level
    relations are general parent relations represented by two-digit CAMEO codes, while
    second-level relations are more specific child relations represented by three-digit
    CAMEO codes. Child relations have the same first two digits as their parent relations.
    For example, ‘01’ is a first-level relation, and ‘010’ and ‘011’ are some of its
    second-level relations. The relations in the database are represented in the second-level
    form. The final forecast answer need to forecast both first-level and second-level
    CAMEO codes, and will be evaluated based on the precision and recall of both levels
    of relations. The final answer content should be a JSON dictionary where the keys
    are the forecasted two-digit first-level CAMEO codes and the values are lists
    of forecasted three-digit second-level CAMEO codes that are child relations of
    the key. For example, {{“01”: [“010”, “011”, “012”], “02”: [“020”, “023”]}}. The
    latest information and forecast I have collected is as follows: {info} If final
    forecast answer has been made in the collected information indicated by "Final
    Answer:", you must only reformat the final forecast answer in the expected JSON
    dictionary format inside XML tags. For example: <answer>{{“01”: [“010”, “011”,
    “012”], “02”: [“020”, “023”]}}</answer>. Otherwise, if no final forecast is made,
    you must reason based on the information you have collected and generate a confident
    final forecast answer to the query, and then reformat your answer in the expected
    JSON dictionary format inside XML tags.</foreignobject></g></g></svg>'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix L Additional Forecasting Examples of LLM Agent
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we show examples of how LLM agents perform reasoning for the
    forecasting query. The query-specific values are highlighted in yellow in the
    system prompt and query prompt, which follows the prompt templates shown in Appendix [K](#A11
    "Appendix K Prompts ‣ Acknowledgements ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs
    for Tool-Use ‣ 4 Related Work ‣ 3.3 Analyzing Agent Behaviours ‣ 3.2 Evaluate
    Forecasting with Different Base LLMs ‣ 3 Experiments ‣ Mirai: Evaluating LLM Agents
    for Event Forecasting"). For simplicity, we use {api_description} as a placeholder
    for the API specification in the prompt, which is replaced by the actual contents
    shown in Appendix [M](#A13 "Appendix M Additional Information about API ‣ item
    1 ‣ L.1.4 Agent ReAct Process ‣ L.1 GPT-4o-based Agent with ReAct and “Code Block”
    Action ‣ Appendix L Additional Forecasting Examples of LLM Agent ‣ Acknowledgements
    ‣ 5 Conclusion and Limitation ‣ 4.3 LLMs for Tool-Use ‣ 4 Related Work ‣ 3.3 Analyzing
    Agent Behaviours ‣ 3.2 Evaluate Forecasting with Different Base LLMs ‣ 3 Experiments
    ‣ Mirai: Evaluating LLM Agents for Event Forecasting") in experiments.'
  prefs: []
  type: TYPE_NORMAL
- en: L.1 GPT-4o-based Agent with ReAct and “Code Block” Action
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: L.1.1 Query Details
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Query Quadruplet: (2023-11-03, AUS, ?, CHN)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Temporal Distance: 1; therefore, the current date is 2023-11-02'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Agent Max Steps: 20'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: L.1.2 Query Prompt
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Please forecast the relations that Australia will take towards China on November
    03, 2023 based on historical information up to November 02, 2023. I.e. forecast
    the relation CAMEO codes in query event Event(date=2023-11-03, head_entity=ISOCode(AUS),
    relation=CAMEOCode(?), tail_entity=ISOCode(CHN)).
  prefs: []
  type: TYPE_NORMAL
- en: L.1.3 System Prompt
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You are an expert in forecasting future events based on historical data. The
    database contains news articles from January 1, 2023 to the current date November
    02, 2023 and the events extracted from these articles. The events are in the form
    of (date, subject country, relation, object country), where the countries are
    represented by ISO 3166-1 alpha-3 codes and the relations are represented by the
    CAMEO codes defined in the "Conflict and Mediation Event Observations" ontology.
    The relations are hierarchical: first-level relations are general parent relations
    represented by two-digit CAMEO codes, while second-level relations are more specific
    child relations represented by three-digit CAMEO codes. Child relations have the
    same first two digits as their parent relations. For example, "01" is a first-level
    relation, and "010" and "011" are some of its second-level relations. The relations
    in the database are represented in the second-level form. Your task is to forecast
    the future relations between two entities in a given query. You have access to
    a defined Python API that allows you to query the database for historical events
    and statistics, and to get precise information about the ISO country codes and
    CAMEO relation codes. You are also authorized to utilize additional safe, well-established
    Python libraries such as numpy, pandas, scikit-learn, and NetworkX to enhance
    your data analysis and forecasting accuracy. The defined API is described as follows:
    [PRE3] You will use an iterative approach, interleaving "Thought", "Action", and
    "Observation" steps to collect information and perform the forecast. You may perform
    up to 20 iterations. The steps are as follows: - "Thought": Analyze the current
    information and reason about the current situation, and predicts which API you
    want to use (try to use different APIs to collect diverse information) or make
    a decision that you want to make a final answer. - "Action": Use the API to gather
    more information or provide the final forecast.       - If gathering more data:
    the action must be an executable Python code snippet that starts with [PRE4].
    It can contain multiple lines of codes and function calls using the defined API
    or Python libraries. You must use print() to output the results, and only the
    printed output will be returned in the observation step.       - If making the
    final forecast: the action must start immediately with "Final Answer:", and follow
    with the answer in the expected JSON format. This should not be enclosed within
    triple backticks. - "Observation": Return the printed output of the executed code
    snippet. To make a reasonable forecast, you should collect both news and relational
    evidence to support your prediction. When you are fully confident that you accumulate
    enough information to make the final forecast, you should start the "Thought"
    with your reasoning using the news and structural information to make the prediction,
    and then start the "Action" step with "Final Answer:" followed by the answer in
    the expected JSON format. The answer should be a JSON dictionary where the keys
    are the forecasted two-digit first-level CAMEO codes and the values are lists
    of forecasted three-digit second-level CAMEO codes that are child relations of
    the key. For example, "Action: Final Answer: {"01": ["010", "011", "012"], "02":
    ["020", "023"]}". The final answer will be evaluated based on the precision and
    recall of the forecasted first-level and second-level relations, so only include
    confident first-level and second-level CAMEO codes in your final forecast. Try
    to use different APIs and Python libraries to collect diverse information (including
    multi-hop relations), such as the precise meaning of CAMEO codes, insights from
    news content, relational data, and statistical analyses to support your forecasts.
    Consider not only the frequency of the relations but also the temporal aspects
    of the data when making your forecast.'
  prefs: []
  type: TYPE_NORMAL
- en: L.1.4 Agent ReAct Process
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Thought: To forecast the relations that Australia will take towards China on
    November 03, 2023, we need to gather historical data on the interactions between
    these two countries. This includes examining the frequency and types of relations
    observed in the past, as well as any recent trends or significant events that
    might influence future relations.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will proceed with the following steps:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (a)
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Retrieve Historical Events: Gather events involving Australia (AUS) and China
    (CHN) to understand the context and types of relations that have occurred in the
    past.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: (b)
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Analyze Relation Distribution: Analyze the distribution of different CAMEO
    codes in these events to identify the most common types of interactions.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: (c)
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Examine Recent Trends: Focus on recent events to detect any emerging trends
    or shifts in relations.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: (d)
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Contextual Analysis: Review news articles to gain insights into the context
    and underlying reasons for these relations.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Let"s start by retrieving historical events between Australia and China.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Action:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[⬇](data:text/plain;base64,ZnJvbSBkYXRldGltZSBpbXBvcnQgZGF0ZXRpbWUKCiMgRGVmaW5lIHRoZSBkYXRlIHJhbmdlIGZvciB0aGUgaGlzdG9yaWNhbCBkYXRhIGNvbGxlY3Rpb24Kc3RhcnRfZGF0ZSA9IERhdGUoIjIwMjMtMDEtMDEiKQplbmRfZGF0ZSA9IERhdGUoIjIwMjMtMTEtMDIiKQpkYXRlX3JhbmdlID0gRGF0ZVJhbmdlKHN0YXJ0X2RhdGU9c3RhcnRfZGF0ZSwgZW5kX2RhdGU9ZW5kX2RhdGUpCgojIERlZmluZSB0aGUgSVNPIGNvZGVzIGZvciBBdXN0cmFsaWEgYW5kIENoaW5hCmF1c19jb2RlID0gSVNPQ29kZSgiQVVTIikKY2huX2NvZGUgPSBJU09Db2RlKCJDSE4iKQoKIyBSZXRyaWV2ZSBoaXN0b3JpY2FsIGV2ZW50cyBpbnZvbHZpbmcgQXVzdHJhbGlhIGFuZCBDaGluYQpldmVudHMgPSBnZXRfZXZlbnRzKGRhdGVfcmFuZ2U9ZGF0ZV9yYW5nZSwgaGVhZF9lbnRpdGllcz1bYXVzX2NvZGVdLCB0YWlsX2VudGl0aWVzPVtjaG5fY29kZV0pCgojIFByaW50IHRoZSByZXRyaWV2ZWQgZXZlbnRzCmZvciBldmVudCBpbiBldmVudHM6CiAgICBwcmludChldmVudClcZW5ke2xzdGxpc3Rpbmd9CiAgICBcdGV4dGJme09ic2VydmF0aW9ufToKICAgIFxiZWdpbntsc3RsaXN0aW5nfVtsYW5ndWFnZT1weXRob25dCkV2ZW50KGRhdGU9RGF0ZSgiMjAyMy0xMS0wMiIpLCBoZWFkX2VudGl0eT1JU09Db2RlKCJBVVMiKSwgcmVsYXRpb249Q0FNRU9Db2RlKCIwNDIiKSwgdGFpbF9lbnRpdHk9SVNPQ29kZSgiQ0hOIikpCkV2ZW50KGRhdGU9RGF0ZSgiMjAyMy0xMS0wMiIpLCBoZWFkX2VudGl0eT1JU09Db2RlKCJBVVMiKSwgcmVsYXRpb249Q0FNRU9Db2RlKCIwNDAiKSwgdGFpbF9lbnRpdHk9SVNPQ29kZSgiQ0hOIikpCkV2ZW50KGRhdGU9RGF0ZSgiMjAyMy0xMS0wMiIpLCBoZWFkX2VudGl0eT1JU09Db2RlKCJBVVMiKSwgcmVsYXRpb249Q0FNRU9Db2RlKCIwMzYiKSwgdGFpbF9lbnRpdHk9SVNPQ29kZSgiQ0hOIikpCkV2ZW50KGRhdGU9RGF0ZSgiMjAyMy0xMS0wMSIpLCBoZWFkX2VudGl0eT1JU09Db2RlKCJBVVMiKSwgcmVsYXRpb249Q0FNRU9Db2RlKCIwNDIiKSwgdGFpbF9lbnRpdHk9SVNPQ29kZSgiQ0hOIikpCkV2ZW50KGRhdGU9RGF0ZSgiMjAyMy0xMS0wMSIpLCBoZWFkX2VudGl0eT1JU09Db2RlKCJBVVMiKSwgcmVsYXRpb249Q0FNRU9Db2RlKCIxNzMiKSwgdGFpbF9lbnRpdHk9SVNPQ29kZSgiQ0hOIikpCkV2ZW50KGRhdGU9RGF0ZSgiMjAyMy0xMS0wMSIpLCBoZWFkX2VudGl0eT1JU09Db2RlKCJBVVMiKSwgcmVsYXRpb249Q0FNRU9Db2RlKCIwMzYiKSwgdGFpbF9lbnRpdHk9SVNPQ29kZSgiQ0hOIikpCkV2ZW50KGRhdGU9RGF0ZSgiMjAyMy0xMC0zMSIpLCBoZWFkX2VudGl0eT1JU09Db2RlKCJBVVMiKSwgcmVsYXRpb249Q0FNRU9Db2RlKCIwMzYiKSwgdGFpbF9lbnRpdHk9SVNPQ29kZSgiQ0hOIikpCkV2ZW50KGRhdGU9RGF0ZSgiMjAyMy0xMC0zMSIpLCBoZWFkX2VudGl0eT1JU09Db2RlKCJBVVMiKSwgcmVsYXRpb249Q0FNRU9Db2RlKCIwNDIiKSwgdGFpbF9lbnRpdHk9SVNPQ29kZSgiQ0hOIikpCkV2ZW50KGRhdGU9RGF0ZSgiMjAyMy0xMC0zMSIpLCBoZWFkX2VudGl0eT1JU09Db2RlKCJBVVMiKSwgcmVsYXRpb249Q0FNRU9Db2RlKCIwNDYiKSwgdGFpbF9lbnRpdHk9SVNPQ29kZSgiQ0hOIikpCkV2ZW50KGRhdGU9RGF0ZSgiMjAyMy0xMC0zMCIpLCBoZWFkX2VudGl0eT1JU09Db2RlKCJBVVMiKSwgcmVsYXRpb249Q0FNRU9Db2RlKCIwMzYiKSwgdGFpbF9lbnRpdHk9SVNPQ29kZSgiQ0hOIikpCkV2ZW50KGRhdGU9RGF0ZSgiMjAyMy0xMC0zMCIpLCBoZWFkX2VudGl0eT1JU09Db2RlKCJBVVMiKSwgcmVsYXRpb249Q0FNRU9Db2RlKCIwNDIiKSwgdGFpbF9lbnRpdHk9SVNPQ29kZSgiQ0hOIikpCkV2ZW50KGRhdGU9RGF0ZSgiMjAyMy0xMC0zMCIpLCBoZWFkX2VudGl0eT1JU09Db2RlKCJBVVMiKSwgcmVsYXRpb249Q0FNRU9Db2RlKCIwNDYiKSwgdGFpbF9lbnRpdHk9SVNPQ29kZSgiQ0hOIikpCkV2ZW50KGRhdGU9RGF0ZSgiMjAyMy0xMC0yOSIpLCBoZWFkX2VudGl0eT1JU09Db2RlKCJBVVMiKSwgcmVsYXRpb249Q0FNRU9Db2RlKCIwMzYiKSwgdGFpbF9lbnRpdHk9SVNPQ29kZSgiQ0hOIikpCkV2ZW50KGRhdGU9RGF0ZSgiMjAyMy0xMC0yNyIpLCBoZWFkX2VudGl0eT1JU09Db2RlKCJBVVMiKSwgcmVsYXRpb249Q0FNRU9Db2RlKCIwMzYiKSwgdGFpbF9lbnRpdHk9SVNPQ29kZSgiQ0hOIikpCkV2ZW50KGRhdGU9RGF0ZSgiMjAyMy0xMC0yNyIpLCBoZWFkX2VudGl0eT1JU09Db2RlKCJBVVMiKSwgcmVsYXRpb249Q0FNRU9Db2RlKCIwNDIiKSwgdGFpbF9lbnRpdHk9SVNPQ29kZSgiQ0hOIikpCkV2ZW50KGRhdGU9RGF0ZSgiMjAyMy0xMC0yNiIpLCBoZWFkX2VudGl0eT1JU09Db2RlKCJBVVMiKSwgcmVsYXRpb249Q0FNRU9Db2RlKCIxNzMiKSwgdGFpbF9lbnRpdHk9SVNPQ29kZSgiQ0hOIikpCkV2ZW50KGRhdGU9RGF0ZSgiMjAyMy0xMC0yNiIpLCBoZWFkX2VudGl0eT1JU09Db2RlKCJBVVMiKSwgcmVsYXRpb249Q0FNRU9Db2RlKCIwNjEiKSwgdGFpbF9lbnRpdHk9SVNPQ29kZSgiQ0hOIikpCkV2ZW50KGRhdGU9RGF0ZSgiMjAyMy0xMC0yNiIpLCBoZWFkX2VudGl0eT1JU09Db2RlKCJBVVMiKSwgcmVsYXRpb249Q0FNRU9Db2RlKCIwNDIiKSwgdGFpbF9lbnRpdHk9SVNPQ29kZSgiQ0hOIikpCkV2ZW50KGRhdGU9RGF0ZSgiMjAyMy0xMC0yNSIpLCBoZWFkX2VudGl0eT1JU09Db2RlKCJBVVMiKSwgcmVsYXRpb249Q0FNRU9Db2RlKCIwNDIiKSwgdGFpbF9lbnRpdHk9SVNPQ29kZSgiQ0hOIikpCkV2ZW50KGRhdGU9RGF0ZSgiMjAyMy0xMC0yMyIpLCBoZWFkX2VudGl0eT1JU09Db2RlKCJBVVMiKSwgcmVsYXRpb249Q0FNRU9Db2RlKCIwNDIiKSwgdGFpbF9lbnRpdHk9SVNPQ29kZSgiQ0hOIikpCkV2ZW50KGRhdGU9RGF0ZSgiMjAyMy0xMC0yMyIpLCBoZWFkX2VudGl0eT1JU09Db2RlKCJBVVMiKSwgcmVsYXRpb249Q0FNRU9Db2RlKCIwMzYiKSwgdGFpbF9lbnRpdHk9SVNPQ29kZSgiQ0hOIikpCkV2ZW50KGRhdGU9RGF0ZSgiMjAyMy0xMC0yMyIpLCBoZWFkX2VudGl0eT1JU09Db2RlKCJBVVMiKSwgcmVsYXRpb249Q0FNRU9Db2RlKCIwMzEiKSwgdGFpbF9lbnRpdHk9SVNPQ29kZSgiQ0hOIikpCkV2ZW50KGRhdGU9RGF0ZSgiMjAyMy0xMC0yMyIpLCBoZWFkX2VudGl0eT1JU09Db2RlKCJBVVMiKSwgcmVsYXRpb249Q0FNRU9Db2RlKCIwNjEiKSwgdGFpbF9lbnRpdHk9SVNPQ29kZSgiQ0hOIikpCkV2ZW50KGRhdGU9RGF0ZSgiMjAyMy0xMC0yMiIpLCBoZWFkX2VudGl0eT1JU09Db2RlKCJBVVMiKSwgcmVsYXRpb249Q0FNRU9Db2RlKCIwNDAiKSwgdGFpbF9lbnRpdHk9SVNPQ29kZSgiQ0hOIikpCkV2ZW50KGRhdGU9RGF0ZSgiMjAyMy0xMC0yMiIpLCBoZWFkX2VudGl0eT1JU09Db2RlKCJBVVMiKSwgcmVsYXRpb249Q0FNRU9Db2RlKCIwNjEiKSwgdGFpbF9lbnRpdHk9SVNPQ29kZSgiQ0hOIikpCkV2ZW50KGRhdGU9RGF0ZSgiMjAyMy0xMC0yMiIpLCBoZWFkX2VudGl0eT1JU09Db2RlKCJBVVMiKSwgcmVsYXRpb249Q0FNRU9Db2RlKCIwMzYiKSwgdGFpbF9lbnRpdHk9SVNPQ29kZSgiQ0hOIikpCkV2ZW50KGRhdGU9RGF0ZSgiMjAyMy0xMC0yMiIpLCBoZWFkX2VudGl0eT1JU09Db2RlKCJBVVMiKSwgcmVsYXRpb249Q0FNRU9Db2RlKCIwNDMiKSwgdGFpbF9lbnRpdHk9SVNPQ29kZSgiQ0hOIikpCkV2ZW50KGRhdGU9RGF0ZSgiMjAyMy0xMC0yMiIpLCBoZWFkX2VudGl0eT1JU09Db2RlKCJBVVMiKSwgcmVsYXRpb249Q0FNRU9Db2RlKCIwNDIiKSwgdGFpbF9lbnRpdHk9SVNPQ29kZSgiQ0hOIikpCkV2ZW50KGRhdGU9RGF0ZSgiMjAyMy0xMC0yMSIpLCBoZWFkX2VudGl0eT1JU09Db2RlKCJBVVMiKSwgcmVsYXRpb249Q0FNRU9Db2RlKCIwNDIiKSwgdGFpbF9lbnRpdHk9SVNPQ29kZSgiQ0hOIikpCkV2ZW50KGRhdGU9RGF0ZSgiMjAyMy0xMC0yMSIpLCBoZWFkX2VudGl0eT1JU09Db2RlKCJBVVMiKSwgcmVsYXRpb249Q0FNRU9Db2RlKCIwNDAiKSwgdGFpbF9lbnRpdHk9SVNPQ29kZSgiQ0hOIikpXGVuZHtsc3RsaXN0aW5nfQogICAgXGl0ZW0gXHRleHRiZntUaG91Z2h0fToKICAgIFRoZSByZXRyaWV2ZWQgZXZlbnRzIGluZGljYXRlIGEgdmFyaWV0eSBvZiByZWxhdGlvbnMgYmV0d2VlbiBBdXN0cmFsaWEgYW5kIENoaW5hLiBUbyBmb3JlY2FzdCB0aGUgZnV0dXJlIHJlbGF0aW9ucywgd2UgbmVlZCB0byBhbmFseXplIHRoZSBkaXN0cmlidXRpb24gb2YgdGhlc2UgcmVsYXRpb25zIHRvIGlkZW50aWZ5IHRoZSBtb3N0IGNvbW1vbiB0eXBlcyBhbmQgYW55IHJlY2VudCB0cmVuZHMuCgogICAgTmV4dCwgd2Ugd2lsbCBhbmFseXplIHRoZSBkaXN0cmlidXRpb24gb2YgdGhlIGRpZmZlcmVudCBDQU1FTyBjb2RlcyBpbiB0aGVzZSBldmVudHMgdG8gaWRlbnRpZnkgdGhlIG1vc3QgZnJlcXVlbnQgaW50ZXJhY3Rpb25zLiBUaGlzIHdpbGwgaGVscCB1cyB1bmRlcnN0YW5kIHRoZSBkb21pbmFudCB0eXBlcyBvZiByZWxhdGlvbnMgYW5kIGFueSBlbWVyZ2luZyBwYXR0ZXJucy4KCiAgICBcdGV4dGJme0FjdGlvbn06CiAgICBcYmVnaW57bHN0bGlzdGluZ31bbGFuZ3VhZ2U9cHl0aG9uXQpmcm9tIGNvbGxlY3Rpb25zIGltcG9ydCBDb3VudGVyCgojIEV4dHJhY3QgdGhlIENBTUVPIGNvZGVzIGZyb20gdGhlIHJldHJpZXZlZCBldmVudHMKY2FtZW9fY29kZXMgPSBbZXZlbnQucmVsYXRpb24uY29kZSBmb3IgZXZlbnQgaW4gZXZlbnRzXQoKIyBDb3VudCB0aGUgZnJlcXVlbmN5IG9mIGVhY2ggQ0FNRU8gY29kZQpjYW1lb19jb2RlX2NvdW50cyA9IENvdW50ZXIoY2FtZW9fY29kZXMpCgojIFByaW50IHRoZSBkaXN0cmlidXRpb24gb2YgQ0FNRU8gY29kZXMKZm9yIGNvZGUsIGNvdW50IGluIGNhbWVvX2NvZGVfY291bnRzLml0ZW1zKCk6CiAgICBwcmludChmIkNBTUVPIENvZGU6IHtjb2RlfSwgQ291bnQ6IHtjb3VudH0iKVxlbmR7bHN0bGlzdGluZ30KICAgIFx0ZXh0YmZ7T2JzZXJ2YXRpb259OgogICAgXGJlZ2lue2xzdGxpc3Rpbmd9W2xhbmd1YWdlPXB5dGhvbl0KQ0FNRU8gQ29kZTogMDQyLCBDb3VudDogMTAKQ0FNRU8gQ29kZTogMDQwLCBDb3VudDogMwpDQU1FTyBDb2RlOiAwMzYsIENvdW50OiA4CkNBTUVPIENvZGU6IDE3MywgQ291bnQ6IDIKQ0FNRU8gQ29kZTogMDQ2LCBDb3VudDogMgpDQU1FTyBDb2RlOiAwNjEsIENvdW50OiAzCkNBTUVPIENvZGU6IDAzMSwgQ291bnQ6IDEKQ0FNRU8gQ29kZTogMDQzLCBDb3VudDogMVxlbmR7bHN0bGlzdGluZ30KICAgIFxpdGVtIFx0ZXh0YmZ7VGhvdWdodH06CiAgICBUaGUgZGlzdHJpYnV0aW9uIG9mIENBTUVPIGNvZGVzIGZyb20gdGhlIGhpc3RvcmljYWwgZXZlbnRzIGJldHdlZW4gQXVzdHJhbGlhIGFuZCBDaGluYSByZXZlYWxzIHRoYXQgY2VydGFpbiB0eXBlcyBvZiBpbnRlcmFjdGlvbnMgYXJlIG1vcmUgZnJlcXVlbnQgdGhhbiBvdGhlcnMuIFNwZWNpZmljYWxseSwgdGhlIG1vc3QgY29tbW9uIHJlbGF0aW9ucyBhcmU6CgogICAgLSBcdGV4dGJmezA0Mn06IDEwIG9jY3VycmVuY2VzXFwKICAgIC0gXHRleHRiZnswMzZ9OiA4IG9jY3VycmVuY2VzXFwKICAgIC0gXHRleHRiZnswNDB9OiAzIG9jY3VycmVuY2VzXFwKICAgIC0gXHRleHRiZnswNjF9OiAzIG9jY3VycmVuY2VzXFwKICAgIC0gXHRleHRiZnswNDZ9OiAyIG9jY3VycmVuY2VzXFwKICAgIC0gXHRleHRiZnsxNzN9OiAyIG9jY3VycmVuY2VzXFwKICAgIC0gXHRleHRiZnswMzF9OiAxIG9jY3VycmVuY2VcXAogICAgLSBcdGV4dGJmezA0M306IDEgb2NjdXJyZW5jZVxcCiAgICBUbyBtYWtlIGEgbW9yZSBpbmZvcm1lZCBmb3JlY2FzdCwgd2Ugc2hvdWxkIHVuZGVyc3RhbmQgd2hhdCB0aGVzZSBDQU1FTyBjb2RlcyByZXByZXNlbnQuIFdlIHdpbGwgbWFwIHRoZXNlIGNvZGVzIHRvIHRoZWlyIGRlc2NyaXB0aW9ucyB0byBnYWluIGluc2lnaHRzIGludG8gdGhlIG5hdHVyZSBvZiB0aGVzZSBpbnRlcmFjdGlvbnMuCgogICAgXHRleHRiZntBY3Rpb259OgogICAgXGJlZ2lue2xzdGxpc3Rpbmd9W2xhbmd1YWdlPXB5dGhvbl0KIyBEZWZpbmUgdGhlIENBTUVPIGNvZGVzIHRvIG1hcApjYW1lb19jb2Rlc190b19tYXAgPSBbIjA0MiIsICIwMzYiLCAiMDQwIiwgIjA2MSIsICIwNDYiLCAiMTczIiwgIjAzMSIsICIwNDMiXQoKIyBNYXAgdGhlIENBTUVPIGNvZGVzIHRvIHRoZWlyIGRlc2NyaXB0aW9ucwpyZWxhdGlvbnMgPSBbbWFwX2NhbWVvX3RvX3JlbGF0aW9uKENBTUVPQ29kZShjb2RlKSkgZm9yIGNvZGUgaW4gY2FtZW9fY29kZXNfdG9fbWFwXQoKIyBQcmludCB0aGUgZGVzY3JpcHRpb25zIG9mIHRoZSBDQU1FTyBjb2Rlcwpmb3IgcmVsYXRpb24gaW4gcmVsYXRpb25zOgogICAgcHJpbnQoZiJDQU1FTyBDb2RlOiB7cmVsYXRpb24uY2FtZW9fY29kZS5jb2RlfSwgTmFtZToge3JlbGF0aW9uLm5hbWV9LCBEZXNjcmlwdGlvbjoge3JlbGF0aW9uLmRlc2NyaXB0aW9ufSIpXGVuZHtsc3RsaXN0aW5nfQogICAgXHRleHRiZntPYnNlcnZhdGlvbn06CiAgICBcYmVnaW57bHN0bGlzdGluZ31bbGFuZ3VhZ2U9cHl0aG9uXQpDQU1FTyBDb2RlOiAwNDIsIE5hbWU6IE1ha2UgYSB2aXNpdCwgRGVzY3JpcHRpb246IFRyYXZlbCB0byBhbm90aGVyIGxvY2F0aW9uIGZvciBhIG1lZXRpbmcgb3Igb3RoZXIgZXZlbnQuCkNBTUVPIENvZGU6IDAzNiwgTmFtZTogRXhwcmVzcyBpbnRlbnQgdG8gbWVldCBvciBuZWdvdGlhdGUsIERlc2NyaXB0aW9uOiBPZmZlciwgcHJvbWlzZSwgYWdyZWUgdG8sIG9yIG90aGVyd2lzZSBpbmRpY2F0ZSB3aWxsaW5nbmVzcyBvciBjb21taXRtZW50IHRvIG1lZXQsIHZpc2l0LCBvciBlbmdhZ2UgaW4gdGFsa3Mgb3IgbmVnb3RpYXRpb25zLgpDQU1FTyBDb2RlOiAwNDAsIE5hbWU6IENvbnN1bHQsIG5vdCBzcGVjaWZpZWQsIERlc2NyaXB0aW9uOiBBbGwgY29uc3VsdGF0aW9ucyBhbmQgbWVldGluZ3MsIG5vdCBvdGhlcndpc2Ugc3BlY2lmaWVkLgpDQU1FTyBDb2RlOiAwNjEsIE5hbWU6IENvb3BlcmF0ZSBlY29ub21pY2FsbHksIERlc2NyaXB0aW9uOiBJbml0aWF0ZSwgcmVzdW1lLCBpbXByb3ZlLCBvciBleHBhbmQgZWNvbm9taWMgZXhjaGFuZ2Ugb3IgY29vcGVyYXRpb24uCkNBTUVPIENvZGU6IDA0NiwgTmFtZTogRW5nYWdlIGluIG5lZ290aWF0aW9uLCBEZXNjcmlwdGlvbjogTmVnb3RpYXRlIG9yIGJhcmdhaW4gd2l0aCBvdGhlcnMuCkNBTUVPIENvZGU6IDE3MywgTmFtZTogQXJyZXN0IG9yIGRldGFpbiwgRGVzY3JpcHRpb246IExlZ2FsIG9yIGV4dHJhanVkaWNpYWwgYXJyZXN0cywgZGV0ZW50aW9ucywgb3IgaW1wcmlzb25tZW50cy4KQ0FNRU8gQ29kZTogMDMxLCBOYW1lOiBFeHByZXNzIGludGVudCB0byBlbmdhZ2UgaW4gbWF0ZXJpYWwgY29vcGVyYXRpb24sIERlc2NyaXB0aW9uOiBPZmZlciwgcHJvbWlzZSwgYWdyZWUgdG8sIG9yIG90aGVyd2lzZSBpbmRpY2F0ZSB3aWxsaW5nbmVzcyBvciBjb21taXRtZW50IHRvIGVuZ2FnZSBpbiBvciBleHBhbmQgbWF0ZXJpYWwgY29vcGVyYXRpdmUgZXhjaGFuZ2UsIHN1Y2ggYXMgZXhwcmVzcyBpbnRlbnQgdG8gY29vcGVyYXRlIGVjb25vbWljYWxseSwgbWlsaXRhcmlseSwgb24ganVkaWNpYWwgbWF0dGVycywgYW5kIG9uIGludGVsbGlnZW5jZS4KQ0FNRU8gQ29kZTogMDQzLCBOYW1lOiBIb3N0IGEgdmlzaXQsIERlc2NyaXB0aW9uOiBIb3N0IG9yIHJlY2VpdmUgYSB2aXNpdG9yIGF0IHJlc2lkZW5jZSwgb2ZmaWNlIG9yIGhvbWUgY291bnRyeS5cZW5ke2xzdGxpc3Rpbmd9CiAgICBcaXRlbSBcdGV4dGJme1Rob3VnaHR9OgogICAgVGhlIG1hcHBlZCBDQU1FTyBjb2RlcyBhbmQgdGhlaXIgZGVzY3JpcHRpb25zIHByb3ZpZGUgdmFsdWFibGUgaW5zaWdodHMgaW50byB0aGUgbmF0dXJlIG9mIGludGVyYWN0aW9ucyBiZXR3ZWVuIEF1c3RyYWxpYSBhbmQgQ2hpbmEuIEhlcmUgYXJlIHRoZSBrZXkgcmVsYXRpb25zIG9ic2VydmVkOgoKICAgIC0gXHRleHRiZnswNDIgKE1ha2UgYSB2aXNpdCl9OiAxMCBvY2N1cnJlbmNlcyDigJMgSW5kaWNhdGVzIGZyZXF1ZW50IHRyYXZlbCBmb3IgbWVldGluZ3Mgb3IgZXZlbnRzLlxcCiAgICAtIFx0ZXh0YmZ7MDM2IChFeHByZXNzIGludGVudCB0byBtZWV0IG9yIG5lZ290aWF0ZSl9OiA4IG9jY3VycmVuY2VzIOKAkyBTaG93cyBhIHN0cm9uZyBpbnRlbnQgdG8gZW5nYWdlIGluIHRhbGtzIG9yIG5lZ290aWF0aW9ucy5cXAogICAgLSBcdGV4dGJmezA0MCAoQ29uc3VsdCwgbm90IHNwZWNpZmllZCl9OiAzIG9jY3VycmVuY2VzIOKAkyBHZW5lcmFsIGNvbnN1bHRhdGlvbnMgYW5kIG1lZXRpbmdzLlxcCiAgICAtIFx0ZXh0YmZ7MDYxIChDb29wZXJhdGUgZWNvbm9taWNhbGx5KX06IDMgb2NjdXJyZW5jZXMg4oCTIEVjb25vbWljIGNvb3BlcmF0aW9uIGluaXRpYXRpdmVzLlxcCiAgICAtIFx0ZXh0YmZ7MDQ2IChFbmdhZ2UgaW4gbmVnb3RpYXRpb24pfTogMiBvY2N1cnJlbmNlcyDigJMgQWN0dWFsIG5lZ290aWF0aW9ucyBvciBiYXJnYWluaW5nLlxcCiAgICAtIFx0ZXh0YmZ7MTczIChBcnJlc3Qgb3IgZGV0YWluKX06IDIgb2NjdXJyZW5jZXMg4oCTIExlZ2FsIG9yIGV4dHJhanVkaWNpYWwgYXJyZXN0cyBvciBkZXRlbnRpb25zLlxcCiAgICAtIFx0ZXh0YmZ7MDMxIChFeHByZXNzIGludGVudCB0byBlbmdhZ2UgaW4gbWF0ZXJpYWwgY29vcGVyYXRpb24pfTogMSBvY2N1cnJlbmNlIOKAkyBJbnRlbnQgdG8gY29vcGVyYXRlIG1hdGVyaWFsbHkuXFwKICAgIC0gXHRleHRiZnswNDMgKEhvc3QgYSB2aXNpdCl9OiAxIG9jY3VycmVuY2Ug4oCTIEhvc3RpbmcgdmlzaXRvcnMuXFwKCiAgICBHaXZlbiB0aGlzIGRhdGEsIHdlIGNhbiBzZWUgdGhhdCB0aGUgbW9zdCBmcmVxdWVudCBpbnRlcmFjdGlvbnMgaW52b2x2ZSB2aXNpdHMsIGV4cHJlc3Npb25zIG9mIGludGVudCB0byBtZWV0IG9yIG5lZ290aWF0ZSwgYW5kIGVjb25vbWljIGNvb3BlcmF0aW9uLiBUaGVzZSBpbnRlcmFjdGlvbnMgc3VnZ2VzdCBhIHBhdHRlcm4gb2YgZGlwbG9tYXRpYyBlbmdhZ2VtZW50IGFuZCBlY29ub21pYyBjb2xsYWJvcmF0aW9uLCB3aXRoIG9jY2FzaW9uYWwgbGVnYWwgYWN0aW9ucy4KCiAgICBUbyBmdXJ0aGVyIHNvbGlkaWZ5IG91ciBmb3JlY2FzdCwgd2Ugc2hvdWxkIGV4YW1pbmUgcmVjZW50IG5ld3MgYXJ0aWNsZXMgdG8gdW5kZXJzdGFuZCB0aGUgY29udGV4dCBhbmQgYW55IHVuZGVybHlpbmcgcmVhc29ucyBmb3IgdGhlc2UgaW50ZXJhY3Rpb25zLiBUaGlzIHdpbGwgaGVscCB1cyBpZGVudGlmeSBhbnkgZW1lcmdpbmcgdHJlbmRzIG9yIHNpZ25pZmljYW50IGV2ZW50cyB0aGF0IG1pZ2h0IGluZmx1ZW5jZSBmdXR1cmUgcmVsYXRpb25zLgoKICAgIE5leHQsIHdlIHdpbGwgcmV0cmlldmUgcmVjZW50IG5ld3MgYXJ0aWNsZXMgaW52b2x2aW5nIEF1c3RyYWxpYSBhbmQgQ2hpbmEgdG8gZ2FpbiBjb250ZXh0dWFsIGluc2lnaHRzLgoKICAgIFx0ZXh0YmZ7QWN0aW9ufToKICAgIFxiZWdpbntsc3RsaXN0aW5nfVtsYW5ndWFnZT1weXRob25dCiMgRGVmaW5lIHRoZSBkYXRlIHJhbmdlIGZvciByZWNlbnQgbmV3cyBhcnRpY2xlcwpyZWNlbnRfc3RhcnRfZGF0ZSA9IERhdGUoIjIwMjMtMTAtMDEiKQpyZWNlbnRfZW5kX2RhdGUgPSBEYXRlKCIyMDIzLTExLTAyIikKcmVjZW50X2RhdGVfcmFuZ2UgPSBEYXRlUmFuZ2Uoc3RhcnRfZGF0ZT1yZWNlbnRfc3RhcnRfZGF0ZSwgZW5kX2RhdGU9cmVjZW50X2VuZF9kYXRlKQoKIyBSZXRyaWV2ZSByZWNlbnQgbmV3cyBhcnRpY2xlcyBpbnZvbHZpbmcgQXVzdHJhbGlhIGFuZCBDaGluYQpuZXdzX2FydGljbGVzID0gZ2V0X25ld3NfYXJ0aWNsZXMoZGF0ZV9yYW5nZT1yZWNlbnRfZGF0ZV9yYW5nZSwgaGVhZF9lbnRpdGllcz1bYXVzX2NvZGVdLCB0YWlsX2VudGl0aWVzPVtjaG5fY29kZV0pCgojIFByaW50IHRoZSByZXRyaWV2ZWQgbmV3cyBhcnRpY2xlcwpmb3IgYXJ0aWNsZSBpbiBuZXdzX2FydGljbGVzOgogICAgcHJpbnQoYXJ0aWNsZSlcZW5ke2xzdGxpc3Rpbmd9CiAgICBcdGV4dGJme09ic2VydmF0aW9ufToKICAgIFxiZWdpbntsc3RsaXN0aW5nfVtsYW5ndWFnZT1weXRob25dCihEYXRlKGRhdGU9IjIwMjMtMTEtMDIiKSwgIk5vIHF1aWNrIGZpeCB0byByZW1haW5pbmcgdGFyaWZmcyBhaGVhZCBvZiBDaGluYSB2aXNpdCIpCihEYXRlKGRhdGU9IjIwMjMtMTEtMDIiKSwgIkNoaW5hInMgYWdncmVzc2lvbiBpbiBJbmRvLVBhY2lmaWMgbGVhZHMgdG8gImNvbmNlcm4gYW5kIGFuZ3N0IjogUGV0ZXIgRHV0dG9uLCBBdXN0cmFsaWEicyBsZWFkZXIgb2Ygb3Bwb3NpdGlvbiIpCihEYXRlKGRhdGU9IjIwMjMtMTEtMDIiKSwgIkF1c3RyYWxpYSBhbmQgQ2hpbmEgZXllIG5ldyB3YXlzIHRvIGhlYWwgb2xkIHdvdW5kcyIpCihEYXRlKGRhdGU9IjIwMjMtMTEtMDIiKSwgIkFsYmFuZXNlIG11c3QgYWltIGJleW9uZCBiaWxhdGVyYWwgb3V0Y29tZXMgb24gQmVpamluZyB2aXNpdCIpCihEYXRlKGRhdGU9IjIwMjMtMTEtMDIiKSwgIldlc3Rlcm4gQXVzdHJhbGlhbiBQcmVtaWVyIEFubm91bmNlcyBWaXNpdCB0byBDaGluYSIpCihEYXRlKGRhdGU9IjIwMjMtMTEtMDIiKSwgIkF1c3RyYWxpYW4gUE0icyBDaGluYSB2aXNpdCB3aWxsIGhlbHAgbm9ybWFsaXplIHJlbGF0aW9ucywgc2F5cyBleC10cmFkZSBtaW5pc3RlciIpCihEYXRlKGRhdGU9IjIwMjMtMTEtMDIiKSwgIk5pY2hvbGFzIE1vb3JlIG9uIGhvdyB0byBnZXQgaW4gZWFybHkgb24gdGhlIG5leHQgYmlnIGdyb3d0aCBzdG9yeSIpCihEYXRlKGRhdGU9IjIwMjMtMTEtMDIiKSwgIlBNInMgQ2hpbmEgdHJpcCBjZW1lbnRzIG5ldyBlcmEgZm9yIHRpZXMiKQooRGF0ZShkYXRlPSIyMDIzLTExLTAyIiksICJQTSB0byB0YWtlIGEgaGFyZCBsaW5lIG9uIHRyYWRlIHdpdGggQ2hpbmEiKQooRGF0ZShkYXRlPSIyMDIzLTExLTAxIiksICJBdXN0cmFsaWFuIFByaW1lIE1pbmlzdGVyIEFudGhvbnkgQWxiYW5lc2UgdG8gcmFpc2UgaW1wcmlzb25lZCBkZW1vY3JhY3kgYmxvZ2dlciBkdXJpbmcgQ2hpbmEgdmlzaXQiKVxlbmR7bHN0bGlzdGluZ30KICAgIFxpdGVtIFx0ZXh0YmZ7VGhvdWdodH06CiAgICBUaGUgcmVjZW50IG5ld3MgYXJ0aWNsZXMgcHJvdmlkZSB2YWx1YWJsZSBjb250ZXh0IGZvciB0aGUgcmVsYXRpb25zIGJldHdlZW4gQXVzdHJhbGlhIGFuZCBDaGluYS4gS2V5IHRoZW1lcyBpbmNsdWRlOlxcCgogICAgMS4gXHRleHRiZntEaXBsb21hdGljIFZpc2l0cyBhbmQgRW5nYWdlbWVudHN9OiBNdWx0aXBsZSBhcnRpY2xlcyBoaWdobGlnaHQgdGhlIHVwY29taW5nIHZpc2l0IG9mIEF1c3RyYWxpYW4gUHJpbWUgTWluaXN0ZXIgQW50aG9ueSBBbGJhbmVzZSB0byBDaGluYS4gVGhpcyBhbGlnbnMgd2l0aCB0aGUgZnJlcXVlbnQgb2NjdXJyZW5jZSBvZiBDQU1FTyBjb2RlIFx0ZXh0YmZ7MDQyIChNYWtlIGEgdmlzaXQpfS5cXAogICAgMi4gXHRleHRiZntFY29ub21pYyBDb29wZXJhdGlvbiBhbmQgVHJhZGV9OiBEaXNjdXNzaW9ucyBhcm91bmQgdHJhZGUgYW5kIGVjb25vbWljIGNvb3BlcmF0aW9uIGFyZSBwcm9taW5lbnQsIGluZGljYXRpbmcgb25nb2luZyBlZmZvcnRzIHRvIGltcHJvdmUgZWNvbm9taWMgdGllcy4gVGhpcyBzdXBwb3J0cyB0aGUgcmVsZXZhbmNlIG9mIENBTUVPIGNvZGVzIFx0ZXh0YmZ7MDYxIChDb29wZXJhdGUgZWNvbm9taWNhbGx5KX0gYW5kIFx0ZXh0YmZ7MDM2IChFeHByZXNzIGludGVudCB0byBtZWV0IG9yIG5lZ290aWF0ZSl9LlxcCiAgICAzLiBcdGV4dGJme0NvbmNlcm5zIGFuZCBUZW5zaW9uc306IEFydGljbGVzIG1lbnRpb24gY29uY2VybnMgYWJvdXQgQ2hpbmEicyBhZ2dyZXNzaW9uIGluIHRoZSBJbmRvLVBhY2lmaWMgYW5kIGh1bWFuIHJpZ2h0cyBpc3N1ZXMsIHN1Z2dlc3RpbmcgdW5kZXJseWluZyB0ZW5zaW9ucy4gVGhpcyBpcyByZWZsZWN0ZWQgaW4gdGhlIG9jY2FzaW9uYWwgb2NjdXJyZW5jZSBvZiBDQU1FTyBjb2RlIFx0ZXh0YmZ7MTczIChBcnJlc3Qgb3IgZGV0YWluKX0uCgogICAgR2l2ZW4gdGhlIGhpc3RvcmljYWwgZGF0YSBhbmQgcmVjZW50IG5ld3MgY29udGV4dCwgdGhlIG1vc3QgbGlrZWx5IHJlbGF0aW9ucyB0aGF0IEF1c3RyYWxpYSB3aWxsIHRha2UgdG93YXJkcyBDaGluYSBvbiBOb3ZlbWJlciAwMywgMjAyMywgaW5jbHVkZSBkaXBsb21hdGljIHZpc2l0cywgZWNvbm9taWMgY29vcGVyYXRpb24sIGFuZCBuZWdvdGlhdGlvbnMsIHdpdGggYSBwb3NzaWJpbGl0eSBvZiBhZGRyZXNzaW5nIHVuZGVybHlpbmcgdGVuc2lvbnMuCgogICAgRmluYWwgQW5zd2VyOgogICAgXGJlZ2lue2xzdGxpc3Rpbmd9W2xhbmd1YWdlPXB5dGhvbl0KewogICIwMyI6IFsiMDMxIiwgIjAzNiJdLAogICIwNCI6IFsiMDQwIiwgIjA0MiIsICIwNDMiLCAiMDQ2Il0sCiAgIjA2IjogWyIwNjEiXSwKICAiMTciOiBbIjE3MyJdCn1cZW5ke2xzdGxpc3Rpbmd9CgogICAgXHRleHRiZntBY3Rpb259OgogICAgRmluYWwgQW5zd2VyOgogICAgXGJlZ2lue2xzdGxpc3Rpbmd9W2xhbmd1YWdlPXB5dGhvbl0KewogICIwMyI6IFsiMDMxIiwgIjAzNiJdLAogICIwNCI6IFsiMDQwIiwgIjA0MiIsICIwNDMiLCAiMDQ2Il0sCiAgIjA2IjogWyIwNjEiXSwKICAiMTciOiBbIjE3MyJdCn1cZW5ke2xzdGxpc3Rpbmd9ClxlbmR7ZW51bWVyYXRlfQoKClxzdWJzdWJzZWN0aW9ue0FnZW50IEZpbmFsIFN0YXR1c30KXGJlZ2lue2l0ZW1pemV9CiAgICBcaXRlbSBcdGV4dGJme0VuZCBTdGF0ZX06IEZpbmFsIEFuc3dlcgogICAgXGl0ZW0gXHRleHRiZntOdW1iZXIgb2YgU3RlcHMgVGFrZW59OiA1CiAgICBcaXRlbSBcdGV4dGJme0ZpbmFsIEFuc3dlcn06CiAgICBcYmVnaW57bHN0bGlzdGluZ31bbGFuZ3VhZ2U9cHl0aG9uXQp7CiAgIjAzIjogWyIwMzEiLCAiMDM2Il0sCiAgIjA0IjogWyIwNDAiLCAiMDQyIiwgIjA0MyIsICIwNDYiXSwKICAiMDYiOiBbIjA2MSJdLAogICIxNyI6IFsiMTczIl0KfVxlbmR7bHN0bGlzdGluZ30KV2Ugc2hvdyB0aGUgY29ycmVzcG9uZGluZyByZWxhdGlvbiBuYW1lcyBvZiB0aGUgcHJlZGljdGVkIGNvZGVzIGhlcmUgZm9yIGEgYmV0dGVyIHJldmlldzoKICAgICAgICBcYmVnaW57bHN0bGlzdGluZ31bbGFuZ3VhZ2U9cHl0aG9uXQp7CiAgIkV4cHJlc3MgaW50ZW50IHRvIGNvb3BlcmF0ZSI6IFsiRXhwcmVzcyBpbnRlbnQgdG8gZW5nYWdlIGluIG1hdGVyaWFsIGNvb3BlcmF0aW9uIiwgIkV4cHJlc3MgaW50ZW50IHRvIG1lZXQgb3IgbmVnb3RpYXRlIl0sCiAgIkNvbnN1bHQiOiBbIkNvbnN1bHQsIG5vdCBzcGVjaWZpZWQiLCAiTWFrZSBhIHZpc2l0IiwgIkhvc3QgYSB2aXNpdCIsICJFbmdhZ2UgaW4gbmVnb3RpYXRpb24iXSwKICAiRW5nYWdlIGluIG1hdGVyaWFsIGNvb3BlcmF0aW9uIjogWyJDb29wZXJhdGUgZWNvbm9taWNhbGx5Il0sCiAgIkNvZXJjZSI6IFsiQXJyZXN0IG9yIGRldGFpbiJdCn1cZW5ke2xzdGxpc3Rpbmd9CiAgICBcaXRlbSBcdGV4dGJme0dyb3VuZCBUcnV0aCBBbnN3ZXJ9OgogICAgXGJlZ2lue2xzdGxpc3Rpbmd9W2xhbmd1YWdlPXB5dGhvbl0KewogICIwMyI6IFsiMDM2Il0sCiAgIjA0IjogWyIwNDIiXSwKICAiMTciOiBbIjE3MiJdCn1cZW5ke2xzdGxpc3Rpbmd9CldlIHNob3cgdGhlIGNvcnJlc3BvbmRpbmcgcmVsYXRpb24gbmFtZXMgb2YgdGhlIGdyb3VuZC10cnV0aCBjb2RlcyBoZXJlIGZvciBhIGJldHRlciByZXZpZXc6CiAgICAgICAgXGJlZ2lue2xzdGxpc3Rpbmd9W2xhbmd1YWdlPXB5dGhvbl0KewogICJFeHByZXNzIGludGVudCB0byBjb29wZXJhdGUiOiBbIkV4cHJlc3MgaW50ZW50IHRvIG1lZXQgb3IgbmVnb3RpYXRlIl0sCiAgIkNvbnN1bHQiOiBbIk1ha2UgYSB2aXNpdCJdLAogICJDb2VyY2UiOiBbIkltcG9zZSBhZG1pbmlzdHJhdGl2ZSBzYW5jdGlvbnMiXQp9XGVuZHtsc3RsaXN0aW5nfQpcZW5ke2l0ZW1pemV9CgoKCgpcc3Vic2VjdGlvbntHUFQtNG8tYmFzZWQgQWdlbnQgd2l0aCBSZUFjdCBhbmQgYGBcaGxjW3VjbGFibHVlITIwXXtTaW5nbGUgRnVuY3Rpb259JycgQWN0aW9ufQoKXHN1YnN1YnNlY3Rpb257UXVlcnkgRGV0YWlsc30KXGJlZ2lue2l0ZW1pemV9CiAgICBcaXRlbSBcdGV4dGJme1F1ZXJ5IFF1YWRydXBsZXR9OiAoMjAyMy0xMS0wMywgQVVTLCA/LCBDSE4pCiAgICBcaXRlbSBcdGV4dGJme1RlbXBvcmFsIERpc3RhbmNlfTogMTsgdGhlcmVmb3JlLCB0aGUgY3VycmVudCBkYXRlIGlzIDIwMjMtMTEtMDIKICAgIFxpdGVtIFx0ZXh0YmZ7QWdlbnQgTWF4IFN0ZXBzfTogMjAKXGVuZHtpdGVtaXplfQoKXHN1YnN1YnNlY3Rpb257UXVlcnkgUHJvbXB0fQpQbGVhc2UgZm9yZWNhc3QgdGhlIHJlbGF0aW9ucyB0aGF0IFxobGNbeWVsbG93ITMwXXtBdXN0cmFsaWF9IHdpbGwgdGFrZSB0b3dhcmRzIFxobGNbeWVsbG93ITMwXXtDaGluYX0gb24gXGhsY1t5ZWxsb3chMzBde05vdmVtYmVyIDAzLCAyMDIzfSBiYXNlZCBvbiBoaXN0b3JpY2FsIGluZm9ybWF0aW9uIHVwIHRvIFxobGNbeWVsbG93ITMwXXtOb3ZlbWJlciAwMiwgMjAyM30uIEkuZS4gZm9yZWNhc3QgdGhlIHJlbGF0aW9uIENBTUVPIGNvZGVzIGluIHF1ZXJ5IGV2ZW50IFxobGNbeWVsbG93ITMwXXtFdmVudChkYXRlPTIwMjMtMTEtMDMsIGhlYWRcX2VudGl0eT1JU09Db2RlKEFVUyksIHJlbGF0aW9uPUNBTUVPQ29kZSg/KSwgdGFpbFxfZW50aXR5PUlTT0NvZGUoQ0hOKSl9LgoKXHN1YnN1YnNlY3Rpb257U3lzdGVtIFByb21wdH0KWW91IGFyZSBhbiBleHBlcnQgaW4gZm9yZWNhc3RpbmcgZnV0dXJlIGV2ZW50cyBiYXNlZCBvbiBoaXN0b3JpY2FsIGRhdGEuIFRoZSBkYXRhYmFzZSBjb250YWlucyBuZXdzIGFydGljbGVzIGZyb20gSmFudWFyeSAxLCAyMDIzIHRvIHRoZSBjdXJyZW50IGRhdGUgXGhsY1t5ZWxsb3chMzBde05vdmVtYmVyIDAyLCAyMDIzfSBhbmQgdGhlIGV2ZW50cyBleHRyYWN0ZWQgZnJvbSB0aGVzZSBhcnRpY2xlcy4gVGhlIGV2ZW50cyBhcmUgaW4gdGhlIGZvcm0gb2YgKGRhdGUsIHN1YmplY3QgY291bnRyeSwgcmVsYXRpb24sIG9iamVjdCBjb3VudHJ5KSwgd2hlcmUgdGhlIGNvdW50cmllcyBhcmUgcmVwcmVzZW50ZWQgYnkgSVNPIDMxNjYtMSBhbHBoYS0zIGNvZGVzIGFuZCB0aGUgcmVsYXRpb25zIGFyZSByZXByZXNlbnRlZCBieSB0aGUgQ0FNRU8gY29kZXMgZGVmaW5lZCBpbiB0aGUgIkNvbmZsaWN0IGFuZCBNZWRpYXRpb24gRXZlbnQgT2JzZXJ2YXRpb25zIiBvbnRvbG9neS4gVGhlIHJlbGF0aW9ucyBhcmUgaGllcmFyY2hpY2FsOiBmaXJzdC1sZXZlbCByZWxhdGlvbnMgYXJlIGdlbmVyYWwgcGFyZW50IHJlbGF0aW9ucyByZXByZXNlbnRlZCBieSB0d28tZGlnaXQgQ0FNRU8gY29kZXMsIHdoaWxlIHNlY29uZC1sZXZlbCByZWxhdGlvbnMgYXJlIG1vcmUgc3BlY2lmaWMgY2hpbGQgcmVsYXRpb25zIHJlcHJlc2VudGVkIGJ5IHRocmVlLWRpZ2l0IENBTUVPIGNvZGVzLiBDaGlsZCByZWxhdGlvbnMgaGF2ZSB0aGUgc2FtZSBmaXJzdCB0d28gZGlnaXRzIGFzIHRoZWlyIHBhcmVudCByZWxhdGlvbnMuIEZvciBleGFtcGxlLCAiMDEiIGlzIGEgZmlyc3QtbGV2ZWwgcmVsYXRpb24sIGFuZCAiMDEwIiBhbmQgIjAxMSIgYXJlIHNvbWUgb2YgaXRzIHNlY29uZC1sZXZlbCByZWxhdGlvbnMuIFRoZSByZWxhdGlvbnMgaW4gdGhlIGRhdGFiYXNlIGFyZSByZXByZXNlbnRlZCBpbiB0aGUgc2Vjb25kLWxldmVsIGZvcm0uClxcXFwKWW91ciB0YXNrIGlzIHRvIGZvcmVjYXN0IHRoZSBmdXR1cmUgcmVsYXRpb25zIGJldHdlZW4gdHdvIGVudGl0aWVzIGluIGEgZ2l2ZW4gcXVlcnkuIFlvdSBoYXZlIGFjY2VzcyB0byBhIGRlZmluZWQgUHl0aG9uIEFQSSB0aGF0IGFsbG93cyB5b3UgdG8gcXVlcnkgdGhlIGRhdGFiYXNlIGZvciBoaXN0b3JpY2FsIGV2ZW50cyBhbmQgc3RhdGlzdGljcywgYW5kIHRvIGdldCBwcmVjaXNlIGluZm9ybWF0aW9uIGFib3V0IHRoZSBJU08gY291bnRyeSBjb2RlcyBhbmQgQ0FNRU8gcmVsYXRpb24gY29kZXMuClxcXFwKVGhlIGRlZmluZWQgQVBJIGlzIGRlc2NyaWJlZCBhcyBmb2xsb3dzOlxcCntcdGV4dGFzY2lpZ3JhdmV9e1x0ZXh0YXNjaWlncmF2ZX17XHRleHRhc2NpaWdyYXZlfSBweXRob25cXApcdGV4dHR0e1x7YXBpXF9kZXNjcmlwdGlvblx9fVxcCntcdGV4dGFzY2lpZ3JhdmV9e1x0ZXh0YXNjaWlncmF2ZX17XHRleHRhc2NpaWdyYXZlfQpcXFxcCllvdSB3aWxsIHVzZSBhbiBpdGVyYXRpdmUgYXBwcm9hY2gsIGludGVybGVhdmluZyAiVGhvdWdodCIsICJBY3Rpb24iLCBhbmQgIk9ic2VydmF0aW9uIiBzdGVwcyB0byBjb2xsZWN0IGluZm9ybWF0aW9uIGFuZCBwZXJmb3JtIHRoZSBmb3JlY2FzdC4gWW91IG1heSBwZXJmb3JtIHVwIHRvIFxobGNbeWVsbG93ITMwXXsyMH0gaXRlcmF0aW9ucy4gVGhlIHN0ZXBzIGFyZSBhcyBmb2xsb3dzOgpcXFxcCi0gIlRob3VnaHQiOiBBbmFseXplIHRoZSBjdXJyZW50IGluZm9ybWF0aW9uIGFuZCByZWFzb24gYWJvdXQgdGhlIGN1cnJlbnQgc2l0dWF0aW9uLCBhbmQgcHJlZGljdHMgd2hpY2ggQVBJIHlvdSB3YW50IHRvIHVzZSAodHJ5IHRvIHVzZSBkaWZmZXJlbnQgQVBJcyB0byBjb2xsZWN0IGRpdmVyc2UgaW5mb3JtYXRpb24pIG9yIG1ha2UgYSBkZWNpc2lvbiB0aGF0IHlvdSB3YW50IHRvIG1ha2UgYSBmaW5hbCBhbnN3ZXIuXFwKLSAiQWN0aW9uIjogVXNlIHRoZSBBUEkgdG8gZ2F0aGVyIG1vcmUgaW5mb3JtYXRpb24gb3IgcHJvdmlkZSB0aGUgZmluYWwgZm9yZWNhc3QuXFwKICAgIFxoc3BhY2UqezZtbX0tIElmIHVzaW5nIHRoZSBBUEk6IFxobGNbdWNsYWJsdWUhMjBde3RoZSBhY3Rpb24gbXVzdCBiZSBvbmx5IG9uZSBzaW5nbGUgbGluZSBvZiBleGFjdGx5IG9uZSBmdW5jdGlvbiBjYWxsIGZyb20gdGhlIEFQSSB3aXRoIGFwcHJvcHJpYXRlIGlucHV0cywgd2l0aG91dCBhZGRpdGlvbmFsIGNvZGUsIGV4cGxhbmF0aW9ucywgb3IgbmF0dXJhbCBsYW5ndWFnZSBkZXNjcmlwdGlvbnN9LlxcCiAgICBcaHNwYWNlKns2bW19LSBJZiBtYWtpbmcgdGhlIGZpbmFsIGZvcmVjYXN0OiB0aGUgYWN0aW9uIG11c3Qgc3RhcnQgaW1tZWRpYXRlbHkgd2l0aCAiRmluYWwgQW5zd2VyOiIsIGFuZCBmb2xsb3cgd2l0aCB0aGUgcmVzdWx0cyBpbiB0aGUgZXhwZWN0ZWQgSlNPTiBmb3JtYXQuXFwKLSAiT2JzZXJ2YXRpb24iOiBSZXR1cm4gdGhlIG91dHB1dCBvZiB0aGUgY2FsbGVkIGZ1bmN0aW9uLgpcXFxcClRvIG1ha2UgYSByZWFzb25hYmxlIGZvcmVjYXN0LCB5b3Ugc2hvdWxkIGNvbGxlY3QgYm90aCBuZXdzIGFuZCByZWxhdGlvbmFsIGV2aWRlbmNlIHRvIHN1cHBvcnQgeW91ciBwcmVkaWN0aW9uLiBXaGVuIHlvdSBhcmUgZnVsbHkgY29uZmlkZW50IHRoYXQgeW91IGFjY3VtdWxhdGUgZW5vdWdoIGluZm9ybWF0aW9uIHRvIG1ha2UgdGhlIGZpbmFsIGZvcmVjYXN0LCB5b3Ugc2hvdWxkIHN0YXJ0IHRoZSAiVGhvdWdodCIgd2l0aCB5b3VyIHJlYXNvbmluZyB1c2luZyB0aGUgbmV3cyBhbmQgc3RydWN0dXJhbCBpbmZvcm1hdGlvbiB0byBtYWtlIHRoZSBwcmVkaWN0aW9uLCBhbmQgdGhlbiBzdGFydCB0aGUgIkFjdGlvbiIgc3RlcCB3aXRoICJGaW5hbCBBbnN3ZXI6IiBmb2xsb3dlZCBieSB0aGUgYW5zd2VyIGluIHRoZSBleHBlY3RlZCBKU09OIGZvcm1hdC4gVGhlIGFuc3dlciBzaG91bGQgYmUgYSBKU09OIGRpY3Rpb25hcnkgd2hlcmUgdGhlIGtleXMgYXJlIHRoZSBmb3JlY2FzdGVkIHR3by1kaWdpdCBmaXJzdC1sZXZlbCBDQU1FTyBjb2RlcyBhbmQgdGhlIHZhbHVlcyBhcmUgbGlzdHMgb2YgZm9yZWNhc3RlZCB0aHJlZS1kaWdpdCBzZWNvbmQtbGV2ZWwgQ0FNRU8gY29kZXMgdGhhdCBhcmUgY2hpbGQgcmVsYXRpb25zIG9mIHRoZSBrZXkuIEZvciBleGFtcGxlLCAiQWN0aW9uOiBGaW5hbCBBbnN3ZXI6IFx7IjAxIjogWyIwMTAiLCAiMDExIiwgIjAxMiJdLCAiMDIiOiBbIjAyMCIsICIwMjMiXVx9Ii4KXFxcXApUaGUgZmluYWwgYW5zd2VyIHdpbGwgYmUgZXZhbHVhdGVkIGJhc2VkIG9uIHRoZSBwcmVjaXNpb24gYW5kIHJlY2FsbCBvZiB0aGUgZm9yZWNhc3RlZCBmaXJzdC1sZXZlbCBhbmQgc2Vjb25kLWxldmVsIHJlbGF0aW9ucywgc28gb25seSBpbmNsdWRlIGNvbmZpZGVudCBmaXJzdC1sZXZlbCBhbmQgc2Vjb25kLWxldmVsIENBTUVPIGNvZGVzIGluIHlvdXIgZmluYWwgZm9yZWNhc3QuClxcXFwKVHJ5IHRvIHVzZSBkaWZmZXJlbnQgQVBJcyB0byBjb2xsZWN0IGRpdmVyc2UgaW5mb3JtYXRpb24gKGluY2x1ZGluZyBtdWx0aS1ob3AgcmVsYXRpb25zKSwgc3VjaCBhcyB0aGUgcHJlY2lzZSBtZWFuaW5nIG9mIENBTUVPIGNvZGVzLCBpbnNpZ2h0cyBmcm9tIG5ld3MgY29udGVudCwgcmVsYXRpb25hbCBkYXRhLCBhbmQgc3RhdGlzdGljYWwgYW5hbHlzZXMgdG8gc3VwcG9ydCB5b3VyIGZvcmVjYXN0cy4gQ29uc2lkZXIgbm90IG9ubHkgdGhlIGZyZXF1ZW5jeSBvZiB0aGUgcmVsYXRpb25zIGJ1dCBhbHNvIHRoZSB0ZW1wb3JhbCBhc3BlY3RzIG9mIHRoZSBkYXRhIHdoZW4gbWFraW5nIHlvdXIgZm9yZWNhc3QuCgpcc3Vic3Vic2VjdGlvbntBZ2VudCBSZUFjdCBQcm9jZXNzfQpcYmVnaW57ZW51bWVyYXRlfQogICAgXGl0ZW0gXHRleHRiZntUaG91Z2h0fToKICAgIFRvIGZvcmVjYXN0IHRoZSByZWxhdGlvbnMgdGhhdCBBdXN0cmFsaWEgKEFVUykgd2lsbCB0YWtlIHRvd2FyZHMgQ2hpbmEgKENITikgb24gTm92ZW1iZXIgMDMsIDIwMjMsIEkgd2lsbCBzdGFydCBieSBnYXRoZXJpbmcgaGlzdG9yaWNhbCBkYXRhIG9uIHRoZSBpbnRlcmFjdGlvbnMgYmV0d2VlbiB0aGVzZSB0d28gY291bnRyaWVzLiBUaGlzIHdpbGwgaW5jbHVkZSB0aGUgdHlwZXMgb2YgcmVsYXRpb25zLCB0aGVpciBmcmVxdWVuY2llcywgYW5kIHRoZSBjb250ZXh0IGluIHdoaWNoIHRoZXkgb2NjdXJyZWQuIEkgd2lsbCB1c2UgdGhlIGZvbGxvd2luZyBzdGVwczoKCiAgICBcYmVnaW57ZW51bWVyYXRlfQogICAgICAgIFxpdGVtIFJldHJpZXZlIHRoZSBkaXN0cmlidXRpb24gb2Ygc2Vjb25kLWxldmVsIHJlbGF0aW9ucyBiZXR3ZWVuIEF1c3RyYWxpYSBhbmQgQ2hpbmEuCiAgICAgICAgXGl0ZW0gQW5hbHl6ZSB0aGUgZGlzdHJpYnV0aW9uIHRvIGlkZW50aWZ5IHRoZSBtb3N0IGNvbW1vbiB0eXBlcyBvZiBpbnRlcmFjdGlvbnMuCiAgICAgICAgXGl0ZW0gRXhhbWluZSByZWNlbnQgbmV3cyBhcnRpY2xlcyB0byB1bmRlcnN0YW5kIHRoZSBjb250ZXh0IGFuZCBhbnkgb25nb2luZyB0cmVuZHMgb3IgZXZlbnRzIHRoYXQgbWlnaHQgaW5mbHVlbmNlIGZ1dHVyZSByZWxhdGlvbnMuCiAgICBcZW5ke2VudW1lcmF0ZX0KCiAgICBcdGV4dGJme0FjdGlvbn06CiAgICBcYmVnaW57bHN0bGlzdGluZ31bbGFuZ3VhZ2U9cHl0aG9uXQpnZXRfcmVsYXRpb25fZGlzdHJpYnV0aW9uKGhlYWRfZW50aXRpZXM9W0lTT0NvZGUoIkFVUyIpXSwgdGFpbF9lbnRpdGllcz1bSVNPQ29kZSgiQ0hOIildKVxlbmR7bHN0bGlzdGluZ30KICAgIFx0ZXh0YmZ7T2JzZXJ2YXRpb259OgogICAgXGJlZ2lue2xzdGxpc3Rpbmd9W2xhbmd1YWdlPXB5dGhvbl0Ke0NBTUVPQ29kZShjb2RlPSIwNDIiKTogMzIsCiBDQU1FT0NvZGUoY29kZT0iMDM2Iik6IDMwLAogQ0FNRU9Db2RlKGNvZGU9IjA0MCIpOiAxNywKQ0FNRU9Db2RlKGNvZGU9IjA2MSIpOiAxNiwKQ0FNRU9Db2RlKGNvZGU9IjA0NiIpOiAxMiwKQ0FNRU9Db2RlKGNvZGU9IjA0MyIpOiAxMSwKQ0FNRU9Db2RlKGNvZGU9IjAxMCIpOiA2LApDQU1FT0NvZGUoY29kZT0iMDIwIik6IDUsCkNBTUVPQ29kZShjb2RlPSIxNzMiKTogNSwKQ0FNRU9Db2RlKGNvZGU9IjAxMiIpOiA1LApDQU1FT0NvZGUoY29kZT0iMDUxIik6IDQsCkNBTUVPQ29kZShjb2RlPSIxNjMiKTogMywKQ0FNRU9Db2RlKGNvZGU9IjEyOCIpOiAyLApDQU1FT0NvZGUoY29kZT0iMDUwIik6IDIsCkNBTUVPQ29kZShjb2RlPSIwODQiKTogMiwKQ0FNRU9Db2RlKGNvZGU9IjA5MCIpOiAyLApDQU1FT0NvZGUoY29kZT0iMTc0Iik6IDEsCkNBTUVPQ29kZShjb2RlPSIxMTIiKTogMSwKQ0FNRU9Db2RlKGNvZGU9IjEzMCIpOiAxLApDQU1FT0NvZGUoY29kZT0iMTYwIik6IDEsCkNBTUVPQ29kZShjb2RlPSIxNzIiKTogMSwKQ0FNRU9Db2RlKGNvZGU9IjE5MiIpOiAxLApDQU1FT0NvZGUoY29kZT0iMTkwIik6IDEsCkNBTUVPQ29kZShjb2RlPSIwNjAiKTogMSwKQ0FNRU9Db2RlKGNvZGU9IjAzMCIpOiAxLApDQU1FT0NvZGUoY29kZT0iMDM1Iik6IDEsCkNBTUVPQ29kZShjb2RlPSIxMzgiKTogMSwKQ0FNRU9Db2RlKGNvZGU9IjA3MSIpOiAxLApDQU1FT0NvZGUoY29kZT0iMDMxIik6IDF9XGVuZHtsc3RsaXN0aW5nfQogICAgXGl0ZW0gXHRleHRiZntUaG91Z2h0fToKICAgIFRoZSBkaXN0cmlidXRpb24gb2Ygc2Vjb25kLWxldmVsIHJlbGF0aW9ucyBiZXR3ZWVuIEF1c3RyYWxpYSBhbmQgQ2hpbmEgc2hvd3MgYSB2YXJpZXR5IG9mIGludGVyYWN0aW9ucywgd2l0aCBzb21lIHJlbGF0aW9ucyBiZWluZyBtb3JlIGZyZXF1ZW50IHRoYW4gb3RoZXJzLiBUaGUgbW9zdCBjb21tb24gaW50ZXJhY3Rpb25zIGluY2x1ZGU6CgogICAgLSAiMDQyIiAoQ29uc3VsdCk6IDMyIG9jY3VycmVuY2VzXFwKICAgIC0gIjAzNiIgKEV4cHJlc3MgaW50ZW50IHRvIGNvb3BlcmF0ZSk6IDMwIG9jY3VycmVuY2VzXFwKICAgIC0gIjA0MCIgKEFzc3VyZSk6IDE3IG9jY3VycmVuY2VzXFwKICAgIC0gIjA2MSIgKENvb3BlcmF0ZSBlY29ub21pY2FsbHkpOiAxNiBvY2N1cnJlbmNlc1xcCiAgICAtICIwNDYiIChQcmFpc2Ugb3IgZW5kb3JzZSk6IDEyIG9jY3VycmVuY2VzXFwKICAgIC0gIjA0MyIgKEFwb2xvZ2l6ZSk6IDExIG9jY3VycmVuY2VzXFwKCiAgICBUaGVzZSBmcmVxdWVudCBpbnRlcmFjdGlvbnMgc3VnZ2VzdCBhIHRyZW5kIHRvd2FyZHMgZGlwbG9tYXRpYyBhbmQgY29vcGVyYXRpdmUgZW5nYWdlbWVudHMuIEhvd2V2ZXIsIHRvIG1ha2UgYSBtb3JlIGluZm9ybWVkIGZvcmVjYXN0LCBpdCBpcyBlc3NlbnRpYWwgdG8gdW5kZXJzdGFuZCB0aGUgY29udGV4dCBhbmQgYW55IHJlY2VudCBkZXZlbG9wbWVudHMgdGhhdCBtaWdodCBpbmZsdWVuY2UgZnV0dXJlIHJlbGF0aW9ucy4KCiAgICBOZXh0LCBJIHdpbGwgcmV0cmlldmUgcmVjZW50IG5ld3MgYXJ0aWNsZXMgaW52b2x2aW5nIEF1c3RyYWxpYSBhbmQgQ2hpbmEgdG8gZ2F0aGVyIGluc2lnaHRzIG9uIHRoZSBjdXJyZW50IGNvbnRleHQgYW5kIGFueSBvbmdvaW5nIHRyZW5kcyBvciBldmVudHMuCgogICAgXHRleHRiZntBY3Rpb259OgogICAgXGJlZ2lue2xzdGxpc3Rpbmd9W2xhbmd1YWdlPXB5dGhvbl0KZ2V0X25ld3NfYXJ0aWNsZXMoZGF0ZV9yYW5nZT1EYXRlUmFuZ2Uoc3RhcnRfZGF0ZT1EYXRlKCIyMDIzLTEwLTAxIiksIGVuZF9kYXRlPURhdGUoIjIwMjMtMTEtMDIiKSksIGhlYWRfZW50aXRpZXM9W0lTT0NvZGUoIkFVUyIpXSwgdGFpbF9lbnRpdGllcz1bSVNPQ29kZSgiQ0hOIildKVxlbmR7bHN0bGlzdGluZ30KICAgIFx0ZXh0YmZ7T2JzZXJ2YXRpb259OgogICAgXGJlZ2lue2xzdGxpc3Rpbmd9W2xhbmd1YWdlPXB5dGhvbl0KWyhEYXRlKGRhdGU9IjIwMjMtMTEtMDIiKSwgIk5vIHF1aWNrIGZpeCB0byByZW1haW5pbmcgdGFyaWZmcyBhaGVhZCBvZiBDaGluYSB2aXNpdCIpLAogKERhdGUoZGF0ZT0iMjAyMy0xMS0wMiIpLCAiQ2hpbmEicyBhZ2dyZXNzaW9uIGluIEluZG8tUGFjaWZpYyBsZWFkcyB0byAiY29uY2VybiBhbmQgYW5nc3QiOiBQZXRlciBEdXR0b24sIEF1c3RyYWxpYSJzIGxlYWRlciBvZiBvcHBvc2l0aW9uIiksCiAoRGF0ZShkYXRlPSIyMDIzLTExLTAyIiksICJBdXN0cmFsaWEgYW5kIENoaW5hIGV5ZSBuZXcgd2F5cyB0byBoZWFsIG9sZCB3b3VuZHMiKSwKIChEYXRlKGRhdGU9IjIwMjMtMTEtMDIiKSwgIkFsYmFuZXNlIG11c3QgYWltIGJleW9uZCBiaWxhdGVyYWwgb3V0Y29tZXMgb24gQmVpamluZyB2aXNpdCIpLAogKERhdGUoZGF0ZT0iMjAyMy0xMS0wMiIpLCAiV2VzdGVybiBBdXN0cmFsaWFuIFByZW1pZXIgQW5ub3VuY2VzIFZpc2l0IHRvIENoaW5hIiksCiAoRGF0ZShkYXRlPSIyMDIzLTExLTAyIiksICJBdXN0cmFsaWFuIFBNInMgQ2hpbmEgdmlzaXQgd2lsbCBoZWxwIG5vcm1hbGl6ZSByZWxhdGlvbnMsIHNheXMgZXgtdHJhZGUgbWluaXN0ZXIiKSwKIChEYXRlKGRhdGU9IjIwMjMtMTEtMDIiKSwgIk5pY2hvbGFzIE1vb3JlIG9uIGhvdyB0byBnZXQgaW4gZWFybHkgb24gdGhlIG5leHQgYmlnIGdyb3d0aCBzdG9yeSIpLAogKERhdGUoZGF0ZT0iMjAyMy0xMS0wMiIpLCAiUE0icyBDaGluYSB0cmlwIGNlbWVudHMgbmV3IGVyYSBmb3IgdGllcyIpLAogKERhdGUoZGF0ZT0iMjAyMy0xMS0wMiIpLCAiUE0gdG8gdGFrZSBhIGhhcmQgbGluZSBvbiB0cmFkZSB3aXRoIENoaW5hIiksCiAoRGF0ZShkYXRlPSIyMDIzLTExLTAxIiksICJBdXN0cmFsaWFuIFByaW1lIE1pbmlzdGVyIEFudGhvbnkgQWxiYW5lc2UgdG8gcmFpc2UgaW1wcmlzb25lZCBkZW1vY3JhY3kgYmxvZ2dlciBkdXJpbmcgQ2hpbmEgdmlzaXQiKV1cZW5ke2xzdGxpc3Rpbmd9CiAgICBcaXRlbSBcdGV4dGJme1Rob3VnaHR9OgogICAgVGhlIHJlY2VudCBuZXdzIGFydGljbGVzIGluZGljYXRlIGEgbWl4IG9mIGRpcGxvbWF0aWMsIGVjb25vbWljLCBhbmQgc2VjdXJpdHktcmVsYXRlZCBpbnRlcmFjdGlvbnMgYmV0d2VlbiBBdXN0cmFsaWEgYW5kIENoaW5hLiBLZXkgdGhlbWVzIGluY2x1ZGU6CgogICAgLSBEaXBsb21hdGljIGVuZ2FnZW1lbnRzIGFuZCBlZmZvcnRzIHRvIG5vcm1hbGl6ZSByZWxhdGlvbnMsIGFzIHNlZW4gaW4gYXJ0aWNsZXMgYWJvdXQgdGhlIEF1c3RyYWxpYW4gUHJpbWUgTWluaXN0ZXIicyB2aXNpdCB0byBDaGluYSBhbmQgZWZmb3J0cyB0byBoZWFsIG9sZCB3b3VuZHMuXFwKICAgIC0gRWNvbm9taWMgY29vcGVyYXRpb24gYW5kIHRyYWRlIGRpc2N1c3Npb25zLCBpbmNsdWRpbmcgYWRkcmVzc2luZyB0YXJpZmZzIGFuZCB0cmFkZSBpc3N1ZXMuXFwKICAgIC0gU2VjdXJpdHkgY29uY2VybnMgYW5kIGNyaXRpY2lzbXMsIHBhcnRpY3VsYXJseSByZWxhdGVkIHRvIENoaW5hInMgYWN0aW9ucyBpbiB0aGUgSW5kby1QYWNpZmljIHJlZ2lvbiBhbmQgaHVtYW4gcmlnaHRzIGlzc3Vlcy5cXAoKICAgIEdpdmVuIHRoZXNlIHRoZW1lcywgaXQgaXMgbGlrZWx5IHRoYXQgdGhlIGZ1dHVyZSByZWxhdGlvbnMgYmV0d2VlbiBBdXN0cmFsaWEgYW5kIENoaW5hIHdpbGwgaW52b2x2ZSBhIGNvbWJpbmF0aW9uIG9mIGRpcGxvbWF0aWMgYXNzdXJhbmNlcywgZWNvbm9taWMgY29vcGVyYXRpb24sIGFuZCBzb21lIGNyaXRpY2FsIHN0YXRlbWVudHMgb3IgYWN0aW9ucyByZWxhdGVkIHRvIHNlY3VyaXR5IGFuZCBodW1hbiByaWdodHMuCgogICAgTmV4dCwgSSB3aWxsIHJldHJpZXZlIGRldGFpbGVkIGRlc2NyaXB0aW9ucyBvZiB0aGUgbW9zdCBmcmVxdWVudCBzZWNvbmQtbGV2ZWwgcmVsYXRpb25zIHRvIGVuc3VyZSBhY2N1cmF0ZSBtYXBwaW5nIGFuZCB1bmRlcnN0YW5kaW5nIG9mIHRoZXNlIGludGVyYWN0aW9ucy4KCiAgICBcdGV4dGJme0FjdGlvbn06CiAgICBcYmVnaW57bHN0bGlzdGluZ31bbGFuZ3VhZ2U9cHl0aG9uXQptYXBfY2FtZW9fdG9fcmVsYXRpb24oQ0FNRU9Db2RlKCIwNDIiKSlcZW5ke2xzdGxpc3Rpbmd9CiAgICBcdGV4dGJme09ic2VydmF0aW9ufToKICAgIFxiZWdpbntsc3RsaXN0aW5nfVtsYW5ndWFnZT1weXRob25dClJlbGF0aW9uKGNhbWVvX2NvZGU9Q0FNRU9Db2RlKCIwNDIiKSwgbmFtZT0iTWFrZSBhIHZpc2l0IiwgZGVzY3JpcHRpb249IlRyYXZlbCB0byBhbm90aGVyIGxvY2F0aW9uIGZvciBhIG1lZXRpbmcgb3Igb3RoZXIgZXZlbnQuIilcZW5ke2xzdGxpc3Rpbmd9CiAgICBcaXRlbSBcdGV4dGJme1Rob3VnaHR9OgogICAgVGhlIHJlbGF0aW9uICIwNDIiIChNYWtlIGEgdmlzaXQpIGludm9sdmVzIHRyYXZlbGluZyB0byBhbm90aGVyIGxvY2F0aW9uIGZvciBhIG1lZXRpbmcgb3Igb3RoZXIgZXZlbnQsIHdoaWNoIGFsaWducyB3aXRoIHRoZSByZWNlbnQgbmV3cyBhYm91dCB0aGUgQXVzdHJhbGlhbiBQcmltZSBNaW5pc3RlciJzIHZpc2l0IHRvIENoaW5hLiBUaGlzIHN1Z2dlc3RzIHRoYXQgZGlwbG9tYXRpYyB2aXNpdHMgYXJlIGEgc2lnbmlmaWNhbnQgYXNwZWN0IG9mIHRoZSBpbnRlcmFjdGlvbnMgYmV0d2VlbiBBdXN0cmFsaWEgYW5kIENoaW5hLgoKICAgIFRvIGZ1cnRoZXIgcmVmaW5lIHRoZSBmb3JlY2FzdCwgSSB3aWxsIHJldHJpZXZlIGRldGFpbGVkIGRlc2NyaXB0aW9ucyBmb3IgdGhlIG90aGVyIG1vc3QgZnJlcXVlbnQgc2Vjb25kLWxldmVsIHJlbGF0aW9uczogIjAzNiIsICIwNDAiLCAiMDYxIiwgIjA0NiIsIGFuZCAiMDQzIi4KCiAgICBcdGV4dGJme0FjdGlvbn06CiAgICBcYmVnaW57bHN0bGlzdGluZ31bbGFuZ3VhZ2U9cHl0aG9uXQptYXBfY2FtZW9fdG9fcmVsYXRpb24oQ0FNRU9Db2RlKCIwMzYiKSlcZW5ke2xzdGxpc3Rpbmd9CiAgICBcdGV4dGJme09ic2VydmF0aW9ufToKICAgIFxiZWdpbntsc3RsaXN0aW5nfVtsYW5ndWFnZT1weXRob25dClJlbGF0aW9uKGNhbWVvX2NvZGU9Q0FNRU9Db2RlKCIwMzYiKSwgbmFtZT0iRXhwcmVzcyBpbnRlbnQgdG8gbWVldCBvciBuZWdvdGlhdGUiLCBkZXNjcmlwdGlvbj0iT2ZmZXIsIHByb21pc2UsIGFncmVlIHRvLCBvciBvdGhlcndpc2UgaW5kaWNhdGUgd2lsbGluZ25lc3Mgb3IgY29tbWl0bWVudCB0byBtZWV0LCB2aXNpdCwgb3IgZW5nYWdlIGluIHRhbGtzIG9yIG5lZ290aWF0aW9ucy4iKVxlbmR7bHN0bGlzdGluZ30KICAgIFxpdGVtIFx0ZXh0YmZ7VGhvdWdodH06CiAgICBUaGUgcmVsYXRpb24gIjAzNiIgKEV4cHJlc3MgaW50ZW50IHRvIG1lZXQgb3IgbmVnb3RpYXRlKSBpbnZvbHZlcyBpbmRpY2F0aW5nIGEgd2lsbGluZ25lc3Mgb3IgY29tbWl0bWVudCB0byBtZWV0LCB2aXNpdCwgb3IgZW5nYWdlIGluIHRhbGtzIG9yIG5lZ290aWF0aW9ucy4gVGhpcyBhbGlnbnMgd2l0aCB0aGUgb25nb2luZyBkaXBsb21hdGljIGVmZm9ydHMgYW5kIGRpc2N1c3Npb25zIG1lbnRpb25lZCBpbiB0aGUgcmVjZW50IG5ld3MgYXJ0aWNsZXMuCgogICAgTmV4dCwgSSB3aWxsIHJldHJpZXZlIGRldGFpbGVkIGRlc2NyaXB0aW9ucyBmb3IgdGhlIHJlbGF0aW9ucyAiMDQwIiwgIjA2MSIsICIwNDYiLCBhbmQgIjA0MyIgdG8gZnVydGhlciB1bmRlcnN0YW5kIHRoZSBjb250ZXh0IG9mIHRoZXNlIGludGVyYWN0aW9ucy4KCiAgICBcdGV4dGJme0FjdGlvbn06CiAgICBcYmVnaW57bHN0bGlzdGluZ31bbGFuZ3VhZ2U9cHl0aG9uXQpnZXRfcGFyZW50X3JlbGF0aW9uKENBTUVPQ29kZSgiMDQwIikpXGVuZHtsc3RsaXN0aW5nfQogICAgXHRleHRiZntPYnNlcnZhdGlvbn06CiAgICBcYmVnaW57bHN0bGlzdGluZ31bbGFuZ3VhZ2U9cHl0aG9uXQpSZWxhdGlvbihjYW1lb19jb2RlPUNBTUVPQ29kZSgiMDQiKSwgbmFtZT0iQ29uc3VsdCIsIGRlc2NyaXB0aW9uPSJBbGwgY29uc3VsdGF0aW9ucyBhbmQgbWVldGluZ3MuIilcZW5ke2xzdGxpc3Rpbmd9CiAgICBcaXRlbSBcdGV4dGJme1Rob3VnaHR9OgogICAgVGhlIHBhcmVudCByZWxhdGlvbiBgMDRgIChDb25zdWx0KSBlbmNvbXBhc3NlcyBhbGwgY29uc3VsdGF0aW9ucyBhbmQgbWVldGluZ3MsIHdoaWNoIGlzIGNvbnNpc3RlbnQgd2l0aCB0aGUgZnJlcXVlbnQgZGlwbG9tYXRpYyBpbnRlcmFjdGlvbnMgYmV0d2VlbiBBdXN0cmFsaWEgYW5kIENoaW5hLiBUaGUgc3BlY2lmaWMgcmVsYXRpb24gIjA0MCIgKEFzc3VyZSkgbGlrZWx5IGludm9sdmVzIHByb3ZpZGluZyBhc3N1cmFuY2VzIGR1cmluZyB0aGVzZSBjb25zdWx0YXRpb25zLgoKICAgIFRvIGZ1cnRoZXIgcmVmaW5lIHRoZSBmb3JlY2FzdCwgSSB3aWxsIHJldHJpZXZlIGRldGFpbGVkIGRlc2NyaXB0aW9ucyBmb3IgdGhlIHJlbGF0aW9ucyAiMDYxIiwgIjA0NiIsIGFuZCAiMDQzIi4KCiAgICBcdGV4dGJme0FjdGlvbn06IiIKCiAgICBcdGV4dGJme09ic2VydmF0aW9ufTogTm8gZmVlZGJhY2sgZnJvbSB0aGUgZW52aXJvbm1lbnQgZHVlIHRvIHRoZSBudWxsIGFjdGlvbi4KICAgIFxpdGVtIFx0ZXh0YmZ7VGhvdWdodH06CiAgICBJIHdpbGwgY29udGludWUgcmV0cmlldmluZyBkZXRhaWxlZCBkZXNjcmlwdGlvbnMgZm9yIHRoZSByZWxhdGlvbnMgIjA2MSIsICIwNDYiLCBhbmQgIjA0MyIgdG8gZnVydGhlciB1bmRlcnN0YW5kIHRoZSBjb250ZXh0IG9mIHRoZXNlIGludGVyYWN0aW9ucy4KCiAgICBcdGV4dGJme0FjdGlvbn06IiIKCiAgICBcdGV4dGJme09ic2VydmF0aW9ufTogTm8gZmVlZGJhY2sgZnJvbSB0aGUgZW52aXJvbm1lbnQgZHVlIHRvIHRoZSBudWxsIGFjdGlvbi4KICAgIFxpdGVtIFx0ZXh0YmZ7VGhvdWdodH06CiAgICBJdCBzZWVtcyB0aGVyZSB3YXMgYW4gaXNzdWUgd2l0aCBteSBwcmV2aW91cyBhY3Rpb25zLiBJIHdpbGwgbm93IHByb2NlZWQgdG8gcmV0cmlldmUgdGhlIGRldGFpbGVkIGRlc2NyaXB0aW9ucyBmb3IgdGhlIHJlbWFpbmluZyBmcmVxdWVudCBzZWNvbmQtbGV2ZWwgcmVsYXRpb25zOiAiMDYxIiwgIjA0NiIsIGFuZCAiMDQzIi4KICAgIFx0ZXh0YmZ7QWN0aW9ufToKICAgIFxiZWdpbntsc3RsaXN0aW5nfVtsYW5ndWFnZT1weXRob25dCm1hcF9jYW1lb190b19yZWxhdGlvbihDQU1FT0NvZGUoIjA2MSIpKVxlbmR7bHN0bGlzdGluZ30KICAgIFx0ZXh0YmZ7T2JzZXJ2YXRpb259OgogICAgXGJlZ2lue2xzdGxpc3Rpbmd9W2xhbmd1YWdlPXB5dGhvbl0KUmVsYXRpb24oY2FtZW9fY29kZT1DQU1FT0NvZGUoIjA2MSIpLCBuYW1lPSJDb29wZXJhdGUgZWNvbm9taWNhbGx5IiwgZGVzY3JpcHRpb249IkluaXRpYXRlLCByZXN1bWUsIGltcHJvdmUsIG9yIGV4cGFuZCBlY29ub21pYyBleGNoYW5nZSBvciBjb29wZXJhdGlvbi4iKVxlbmR7bHN0bGlzdGluZ30KICAgIFxpdGVtIFx0ZXh0YmZ7VGhvdWdodH06CiAgICBUaGUgcmVsYXRpb24gIjA2MSIgKENvb3BlcmF0ZSBlY29ub21pY2FsbHkpIGludm9sdmVzIGluaXRpYXRpbmcsIHJlc3VtaW5nLCBpbXByb3ZpbmcsIG9yIGV4cGFuZGluZyBlY29ub21pYyBleGNoYW5nZSBvciBjb29wZXJhdGlvbi4gVGhpcyBhbGlnbnMgd2l0aCB0aGUgcmVjZW50IG5ld3MgYXJ0aWNsZXMgZGlzY3Vzc2luZyB0cmFkZSBpc3N1ZXMgYW5kIGVjb25vbWljIGNvb3BlcmF0aW9uIGJldHdlZW4gQXVzdHJhbGlhIGFuZCBDaGluYS4KCiAgICBOZXh0LCBJIHdpbGwgcmV0cmlldmUgZGV0YWlsZWQgZGVzY3JpcHRpb25zIGZvciB0aGUgcmVsYXRpb25zICIwNDYiIGFuZCAiMDQzIi4KCiAgICBcdGV4dGJme0FjdGlvbn06CiAgICBcYmVnaW57bHN0bGlzdGluZ31bbGFuZ3VhZ2U9cHl0aG9uXQptYXBfY2FtZW9fdG9fcmVsYXRpb24oQ0FNRU9Db2RlKCIwNDYiKSlcZW5ke2xzdGxpc3Rpbmd9CiAgICBcdGV4dGJme09ic2VydmF0aW9ufToKICAgIFxiZWdpbntsc3RsaXN0aW5nfVtsYW5ndWFnZT1weXRob25dClJlbGF0aW9uKGNhbWVvX2NvZGU9Q0FNRU9Db2RlKCIwNDYiKSwgbmFtZT0iRW5nYWdlIGluIG5lZ290aWF0aW9uIiwgZGVzY3JpcHRpb249Ik5lZ290aWF0ZSBvciBiYXJnYWluIHdpdGggb3RoZXJzLiIpXGVuZHtsc3RsaXN0aW5nfQoKICAgIFxpdGVtIFx0ZXh0YmZ7VGhvdWdodH06CiAgICBUaGUgcmVsYXRpb24gIjA0NiIgKEVuZ2FnZSBpbiBuZWdvdGlhdGlvbikgaW52b2x2ZXMgbmVnb3RpYXRpbmcgb3IgYmFyZ2FpbmluZyB3aXRoIG90aGVycy4gVGhpcyBpcyBjb25zaXN0ZW50IHdpdGggdGhlIG9uZ29pbmcgZGlzY3Vzc2lvbnMgYW5kIG5lZ290aWF0aW9ucyBtZW50aW9uZWQgaW4gdGhlIG5ld3MgYXJ0aWNsZXMsIHBhcnRpY3VsYXJseSByZWdhcmRpbmcgdHJhZGUgYW5kIGRpcGxvbWF0aWMgaXNzdWVzLgoKICAgIE5leHQsIEkgd2lsbCByZXRyaWV2ZSB0aGUgZGV0YWlsZWQgZGVzY3JpcHRpb24gZm9yIHRoZSByZWxhdGlvbiAiMDQzIi4KCiAgICBcdGV4dGJme0FjdGlvbn06IiIKCiAgICBcdGV4dGJme09ic2VydmF0aW9ufTogTm8gZmVlZGJhY2sgZnJvbSB0aGUgZW52aXJvbm1lbnQgZHVlIHRvIHRoZSBudWxsIGFjdGlvbi4KCiAgICBcaXRlbSBcdGV4dGJme1Rob3VnaHR9OgogICAgSXQgc2VlbXMgdGhlcmUgd2FzIGFuIGlzc3VlIHdpdGggbXkgcHJldmlvdXMgYWN0aW9ucy4gSSB3aWxsIG5vdyBwcm9jZWVkIHRvIHJldHJpZXZlIHRoZSBkZXRhaWxlZCBkZXNjcmlwdGlvbiBmb3IgdGhlIHJlbGF0aW9uICIwNDMiIHRvIGNvbXBsZXRlIHRoZSB1bmRlcnN0YW5kaW5nIG9mIHRoZSBtb3N0IGZyZXF1ZW50IGludGVyYWN0aW9ucyBiZXR3ZWVuIEF1c3RyYWxpYSBhbmQgQ2hpbmEuCgogICAgXHRleHRiZntBY3Rpb259OgogICAgXGJlZ2lue2xzdGxpc3Rpbmd9W2xhbmd1YWdlPXB5dGhvbl0KbWFwX2NhbWVvX3RvX3JlbGF0aW9uKENBTUVPQ29kZSgiMDQzIikpXGVuZHtsc3RsaXN0aW5nfQogICAgXHRleHRiZntPYnNlcnZhdGlvbn06CiAgICBcYmVnaW57bHN0bGlzdGluZ31bbGFuZ3VhZ2U9cHl0aG9uXQpSZWxhdGlvbihjYW1lb19jb2RlPUNBTUVPQ29kZSgiMDQzIiksIG5hbWU9Ikhvc3QgYSB2aXNpdCIsIGRlc2NyaXB0aW9uPSJIb3N0IG9yIHJlY2VpdmUgYSB2aXNpdG9yIGF0IHJlc2lkZW5jZSwgb2ZmaWNlIG9yIGhvbWUgY291bnRyeS4iKVxlbmR7bHN0bGlzdGluZ30KCiAgICBcaXRlbSBcdGV4dGJme1Rob3VnaHR9OgogICAgVGhlIHJlbGF0aW9uICIwNDMiIChIb3N0IGEgdmlzaXQpIGludm9sdmVzIGhvc3Rpbmcgb3IgcmVjZWl2aW5nIGEgdmlzaXRvciBhdCBhIHJlc2lkZW5jZSwgb2ZmaWNlLCBvciBob21lIGNvdW50cnkuIFRoaXMgYWxpZ25zIHdpdGggdGhlIGRpcGxvbWF0aWMgdmlzaXRzIGFuZCBlbmdhZ2VtZW50cyBtZW50aW9uZWQgaW4gdGhlIHJlY2VudCBuZXdzIGFydGljbGVzLgoKICAgIEJhc2VkIG9uIHRoZSBkZXRhaWxlZCBkZXNjcmlwdGlvbnMgYW5kIHRoZSByZWNlbnQgbmV3cyBjb250ZXh0LCB0aGUgbW9zdCBmcmVxdWVudCBpbnRlcmFjdGlvbnMgYmV0d2VlbiBBdXN0cmFsaWEgYW5kIENoaW5hIGludm9sdmUgZGlwbG9tYXRpYyB2aXNpdHMsIGVjb25vbWljIGNvb3BlcmF0aW9uLCBuZWdvdGlhdGlvbnMsIGFuZCBhc3N1cmFuY2VzLiBUaGVzZSBpbnRlcmFjdGlvbnMgc3VnZ2VzdCBhIHRyZW5kIHRvd2FyZHMgZGlwbG9tYXRpYyBhbmQgY29vcGVyYXRpdmUgZW5nYWdlbWVudHMsIHdpdGggc29tZSBjcml0aWNhbCBzdGF0ZW1lbnRzIG9yIGFjdGlvbnMgcmVsYXRlZCB0byBzZWN1cml0eSBhbmQgaHVtYW4gcmlnaHRzLgoKICAgIEdpdmVuIHRoaXMgaW5mb3JtYXRpb24sIEkgYW0gY29uZmlkZW50IGluIGZvcmVjYXN0aW5nIHRoZSBmb2xsb3dpbmcgcmVsYXRpb25zIGJldHdlZW4gQXVzdHJhbGlhIGFuZCBDaGluYSBvbiBOb3ZlbWJlciAwMywgMjAyMzoKCiAgICAtIERpcGxvbWF0aWMgdmlzaXRzIGFuZCBlbmdhZ2VtZW50cyAoIjA0MiIsICIwNDMiLCAiMDM2IikKICAgIC0gRWNvbm9taWMgY29vcGVyYXRpb24gKCIwNjEiKQogICAgLSBOZWdvdGlhdGlvbnMgKCIwNDYiKQogICAgLSBBc3N1cmFuY2VzICgiMDQwIikKCiAgICBcdGV4dGJme0FjdGlvbn06CiAgICBGaW5hbCBBbnN3ZXI6IFx7IjA0IjogWyIwNDAiLCAiMDQyIiwgIjA0MyIsICIwNDYiXSwgIjAzIjogWyIwMzYiXSwgIjA2IjogWyIwNjEiXVx9ClxlbmR7ZW51bWVyYXRlfQoKCgpcc3Vic3Vic2VjdGlvbntBZ2VudCBGaW5hbCBTdGF0dXN9ClxiZWdpbntpdGVtaXplfQogICAgXGl0ZW0gXHRleHRiZntFbmQgU3RhdGV9OiBGaW5hbCBBbnN3ZXIKICAgIFxpdGVtIFx0ZXh0YmZ7TnVtYmVyIG9mIFN0ZXBzIFRha2VufTogMTIKICAgIFxpdGVtIFx0ZXh0YmZ7RmluYWwgQW5zd2VyfToKICAgIFxiZWdpbntsc3RsaXN0aW5nfVtsYW5ndWFnZT1weXRob25dCnsKICAiMDMiOiBbIjAzNiJdLAogICIwNCI6IFsiMDQwIiwgIjA0MiIsICIwNDMiLCAiMDQ2Il0sCiAgIjA2IjogWyIwNjEiXQp9XGVuZHtsc3RsaXN0aW5nfQpXZSBzaG93IHRoZSBjb3JyZXNwb25kaW5nIHJlbGF0aW9uIG5hbWVzIG9mIHRoZSBwcmVkaWN0ZWQgY29kZXMgaGVyZSBmb3IgYSBiZXR0ZXIgcmV2aWV3OgogICAgICAgIFxiZWdpbntsc3RsaXN0aW5nfVtsYW5ndWFnZT1weXRob25dCnsKICAiRXhwcmVzcyBpbnRlbnQgdG8gY29vcGVyYXRlIjogWyJFeHByZXNzIGludGVudCB0byBtZWV0IG9yIG5lZ290aWF0ZSJdLAogICJDb25zdWx0IjogWyJDb25zdWx0LCBub3Qgc3BlY2lmaWVkIiwgIk1ha2UgYSB2aXNpdCIsICJIb3N0IGEgdmlzaXQiLCAiRW5nYWdlIGluIG5lZ290aWF0aW9uIl0sCiAgIkVuZ2FnZSBpbiBtYXRlcmlhbCBjb29wZXJhdGlvbiI6IFsiQ29vcGVyYXRlIGVjb25vbWljYWxseSJdCn1cZW5ke2xzdGxpc3Rpbmd9CiAgICBcaXRlbSBcdGV4dGJme0dyb3VuZCBUcnV0aCBBbnN3ZXJ9OgogICAgXGJlZ2lue2xzdGxpc3Rpbmd9W2xhbmd1YWdlPXB5dGhvbl0KewogICIwMyI6IFsiMDM2Il0sCiAgIjA0IjogWyIwNDIiXSwKICAiMTciOiBbIjE3MiJdCn1cZW5ke2xzdGxpc3Rpbmd9CldlIHNob3cgdGhlIGNvcnJlc3BvbmRpbmcgcmVsYXRpb24gbmFtZXMgb2YgdGhlIGdyb3VuZC10cnV0aCBjb2RlcyBoZXJlIGZvciBhIGJldHRlciByZXZpZXc6CiAgICAgICAgXGJlZ2lue2xzdGxpc3Rpbmd9W2xhbmd1YWdlPXB5dGhvbl0KewogICJFeHByZXNzIGludGVudCB0byBjb29wZXJhdGUiOiBbIkV4cHJlc3MgaW50ZW50IHRvIG1lZXQgb3IgbmVnb3RpYXRlIl0sCiAgIkNvbnN1bHQiOiBbIk1ha2UgYSB2aXNpdCJdLAogICJDb2VyY2UiOiBbIkltcG9zZSBhZG1pbmlzdHJhdGl2ZSBzYW5jdGlvbnMiXQp9XGVuZHtsc3RsaXN0aW5nfQpcZW5ke2l0ZW1pemV9)1from  datetime  import  datetime23#  Define  the  date  range  for  the  historical  data  collection4start_date  =  Date("2023-01-01")5end_date  =  Date("2023-11-02")6date_range  =  DateRange(start_date=start_date,  end_date=end_date)78#  Define  the  ISO  codes  for  Australia  and  China9aus_code  =  ISOCode("AUS")10chn_code  =  ISOCode("CHN")1112#  Retrieve  historical  events  involving  Australia  and  China13events  =  get_events(date_range=date_range,  head_entities=[aus_code],  tail_entities=[chn_code])1415#  Print  the  retrieved  events16for  event  in  events:17  print(event)\end{lstlisting}18  \textbf{Observation}:19  \begin{lstlisting}[language=python]20Event(date=Date("2023-11-02"),  head_entity=ISOCode("AUS"),  relation=CAMEOCode("042"),  tail_entity=ISOCode("CHN"))21Event(date=Date("2023-11-02"),  head_entity=ISOCode("AUS"),  relation=CAMEOCode("040"),  tail_entity=ISOCode("CHN"))22Event(date=Date("2023-11-02"),  head_entity=ISOCode("AUS"),  relation=CAMEOCode("036"),  tail_entity=ISOCode("CHN"))23Event(date=Date("2023-11-01"),  head_entity=ISOCode("AUS"),  relation=CAMEOCode("042"),  tail_entity=ISOCode("CHN"))24Event(date=Date("2023-11-01"),  head_entity=ISOCode("AUS"),  relation=CAMEOCode("173"),  tail_entity=ISOCode("CHN"))25Event(date=Date("2023-11-01"),  head_entity=ISOCode("AUS"),  relation=CAMEOCode("036"),  tail_entity=ISOCode("CHN"))26Event(date=Date("2023-10-31"),  head_entity=ISOCode("AUS"),  relation=CAMEOCode("036"),  tail_entity=ISOCode("CHN"))27Event(date=Date("2023-10-31"),  head_entity=ISOCode("AUS"),  relation=CAMEOCode("042"),  tail_entity=ISOCode("CHN"))28Event(date=Date("2023-10-31"),  head_entity=ISOCode("AUS"),  relation=CAMEOCode("046"),  tail_entity=ISOCode("CHN"))29Event(date=Date("2023-10-30"),  head_entity=ISOCode("AUS"),  relation=CAMEOCode("036"),  tail_entity=ISOCode("CHN"))30Event(date=Date("2023-10-30"),  head_entity=ISOCode("AUS"),  relation=CAMEOCode("042"),  tail_entity=ISOCode("CHN"))31Event(date=Date("2023-10-30"),  head_entity=ISOCode("AUS"),  relation=CAMEOCode("046"),  tail_entity=ISOCode("CHN"))32Event(date=Date("2023-10-29"),  head_entity=ISOCode("AUS"),  relation=CAMEOCode("036"),  tail_entity=ISOCode("CHN"))33Event(date=Date("2023-10-27"),  head_entity=ISOCode("AUS"),  relation=CAMEOCode("036"),  tail_entity=ISOCode("CHN"))34Event(date=Date("2023-10-27"),  head_entity=ISOCode("AUS"),  relation=CAMEOCode("042"),  tail_entity=ISOCode("CHN"))35Event(date=Date("2023-10-26"),  head_entity=ISOCode("AUS"),  relation=CAMEOCode("173"),  tail_entity=ISOCode("CHN"))36Event(date=Date("2023-10-26"),  head_entity=ISOCode("AUS"),  relation=CAMEOCode("061"),  tail_entity=ISOCode("CHN"))37Event(date=Date("2023-10-26"),  head_entity=ISOCode("AUS"),  relation=CAMEOCode("042"),  tail_entity=ISOCode("CHN"))38Event(date=Date("2023-10-25"),  head_entity=ISOCode("AUS"),  relation=CAMEOCode("042"),  tail_entity=ISOCode("CHN"))39Event(date=Date("2023-10-23"),  head_entity=ISOCode("AUS"),  relation=CAMEOCode("042"),  tail_entity=ISOCode("CHN"))40Event(date=Date("2023-10-23"),  head_entity=ISOCode("AUS"),  relation=CAMEOCode("036"),  tail_entity=ISOCode("CHN"))41Event(date=Date("2023-10-23"),  head_entity=ISOCode("AUS"),  relation=CAMEOCode("031"),  tail_entity=ISOCode("CHN"))42Event(date=Date("2023-10-23"),  head_entity=ISOCode("AUS"),  relation=CAMEOCode("061"),  tail_entity=ISOCode("CHN"))43Event(date=Date("2023-10-22"),  head_entity=ISOCode("AUS"),  relation=CAMEOCode("040"),  tail_entity=ISOCode("CHN"))44Event(date=Date("2023-10-22"),  head_entity=ISOCode("AUS"),  relation=CAMEOCode("061"),  tail_entity=ISOCode("CHN"))45Event(date=Date("2023-10-22"),  head_entity=ISOCode("AUS"),  relation=CAMEOCode("036"),  tail_entity=ISOCode("CHN"))46Event(date=Date("2023-10-22"),  head_entity=ISOCode("AUS"),  relation=CAMEOCode("043"),  tail_entity=ISOCode("CHN"))47Event(date=Date("2023-10-22"),  head_entity=ISOCode("AUS"),  relation=CAMEOCode("042"),  tail_entity=ISOCode("CHN"))48Event(date=Date("2023-10-21"),  head_entity=ISOCode("AUS"),  relation=CAMEOCode("042"),  tail_entity=ISOCode("CHN"))49Event(date=Date("2023-10-21"),  head_entity=ISOCode("AUS"),  relation=CAMEOCode("040"),  tail_entity=ISOCode("CHN"))\end{lstlisting}50  \item  \textbf{Thought}:51  The  retrieved  events  indicate  a  variety  of  relations  between  Australia  and  China.  To  forecast  the  future  relations,  we  need  to  analyze  the  distribution  of  these  relations  to  identify  the  most  common  types  and  any  recent  trends.5253  Next,  we  will  analyze  the  distribution  of  the  different  CAMEO  codes  in  these  events  to  identify  the  most  frequent  interactions.  This  will  help  us  understand  the  dominant  types  of  relations  and  any  emerging  patterns.5455  \textbf{Action}:56  \begin{lstlisting}[language=python]57from  collections  import  Counter5859#  Extract  the  CAMEO  codes  from  the  retrieved  events60cameo_codes  =  [event.relation.code  for  event  in  events]6162#  Count  the  frequency  of  each  CAMEO  code63cameo_code_counts  =  Counter(cameo_codes)6465#  Print  the  distribution  of  CAMEO  codes66for  code,  count  in  cameo_code_counts.items():67  print(f"CAMEO  Code:  {code},  Count:  {count}")\end{lstlisting}68  \textbf{Observation}:69  \begin{lstlisting}[language=python]70CAMEO  Code:  042,  Count:  1071CAMEO  Code:  040,  Count:  372CAMEO  Code:  036,  Count:  873CAMEO  Code:  173,  Count:  274CAMEO  Code:  046,  Count:  275CAMEO  Code:  061,  Count:  376CAMEO  Code:  031,  Count:  177CAMEO  Code:  043,  Count:  1\end{lstlisting}78  \item  \textbf{Thought}:79  The  distribution  of  CAMEO  codes  from  the  historical  events  between  Australia  and  China  reveals  that  certain  types  of  interactions  are  more  frequent  than  others.  Specifically,  the  most  common  relations  are:8081  -  \textbf{042}:  10  occurrences\\82  -  \textbf{036}:  8  occurrences\\83  -  \textbf{040}:  3  occurrences\\84  -  \textbf{061}:  3  occurrences\\85  -  \textbf{046}:  2  occurrences\\86  -  \textbf{173}:  2  occurrences\\87  -  \textbf{031}:  1  occurrence\\88  -  \textbf{043}:  1  occurrence\\89  To  make  a  more  informed  forecast,  we  should  understand  what  these  CAMEO  codes  represent.  We  will  map  these  codes  to  their  descriptions  to  gain  insights  into  the  nature  of  these  interactions.9091  \textbf{Action}:92  \begin{lstlisting}[language=python]93#  Define  the  CAMEO  codes  to  map94cameo_codes_to_map  =  ["042",  "036",  "040",  "061",  "046",  "173",  "031",  "043"]9596#  Map  the  CAMEO  codes  to  their  descriptions97relations  =  [map_cameo_to_relation(CAMEOCode(code))  for  code  in  cameo_codes_to_map]9899#  Print  the  descriptions  of  the  CAMEO  codes100for  relation  in  relations:101  print(f"CAMEO  Code:  {relation.cameo_code.code},  Name:  {relation.name},  Description:  {relation.description}")\end{lstlisting}102  \textbf{Observation}:103  \begin{lstlisting}[language=python]104CAMEO  Code:  042,  Name:  Make  a  visit,  Description:  Travel  to  another  location  for  a  meeting  or  other  event.105CAMEO  Code:  036,  Name:  Express  intent  to  meet  or  negotiate,  Description:  Offer,  promise,  agree  to,  or  otherwise  indicate  willingness  or  commitment  to  meet,  visit,  or  engage  in  talks  or  negotiations.106CAMEO  Code:  040,  Name:  Consult,  not  specified,  Description:  All  consultations  and  meetings,  not  otherwise  specified.107CAMEO  Code:  061,  Name:  Cooperate  economically,  Description:  Initiate,  resume,  improve,  or  expand  economic  exchange  or  cooperation.108CAMEO  Code:  046,  Name:  Engage  in  negotiation,  Description:  Negotiate  or  bargain  with  others.109CAMEO  Code:  173,  Name:  Arrest  or  detain,  Description:  Legal  or  extrajudicial  arrests,  detentions,  or  imprisonments.110CAMEO  Code:  031,  Name:  Express  intent  to  engage  in  material  cooperation,  Description:  Offer,  promise,  agree  to,  or  otherwise  indicate  willingness  or  commitment  to  engage  in  or  expand  material  cooperative  exchange,  such  as  express  intent  to  cooperate  economically,  militarily,  on  judicial  matters,  and  on  intelligence.111CAMEO  Code:  043,  Name:  Host  a  visit,  Description:  Host  or  receive  a  visitor  at  residence,  office  or  home  country.\end{lstlisting}112  \item  \textbf{Thought}:113  The  mapped  CAMEO  codes  and  their  descriptions  provide  valuable  insights  into  the  nature  of  interactions  between  Australia  and  China.  Here  are  the  key  relations  observed:114115  -  \textbf{042  (Make  a  visit)}:  10  occurrences  –  Indicates  frequent  travel  for  meetings  or  events.\\116  -  \textbf{036  (Express  intent  to  meet  or  negotiate)}:  8  occurrences  –  Shows  a  strong  intent  to  engage  in  talks  or  negotiations.\\117  -  \textbf{040  (Consult,  not  specified)}:  3  occurrences  –  General  consultations  and  meetings.\\118  -  \textbf{061  (Cooperate  economically)}:  3  occurrences  –  Economic  cooperation  initiatives.\\119  -  \textbf{046  (Engage  in  negotiation)}:  2  occurrences  –  Actual  negotiations  or  bargaining.\\120  -  \textbf{173  (Arrest  or  detain)}:  2  occurrences  –  Legal  or  extrajudicial  arrests  or  detentions.\\121  -  \textbf{031  (Express  intent  to  engage  in  material  cooperation)}:  1  occurrence  –  Intent  to  cooperate  materially.\\122  -  \textbf{043  (Host  a  visit)}:  1  occurrence  –  Hosting  visitors.\\123124  Given  this  data,  we  can  see  that  the  most  frequent  interactions  involve  visits,  expressions  of  intent  to  meet  or  negotiate,  and  economic  cooperation.  These  interactions  suggest  a  pattern  of  diplomatic  engagement  and  economic  collaboration,  with  occasional  legal  actions.125126  To  further  solidify  our  forecast,  we  should  examine  recent  news  articles  to  understand  the  context  and  any  underlying  reasons  for  these  interactions.  This  will  help  us  identify  any  emerging  trends  or  significant  events  that  might  influence  future  relations.127128  Next,  we  will  retrieve  recent  news  articles  involving  Australia  and  China  to  gain  contextual  insights.129130  \textbf{Action}:131  \begin{lstlisting}[language=python]132#  Define  the  date  range  for  recent  news  articles133recent_start_date  =  Date("2023-10-01")134recent_end_date  =  Date("2023-11-02")135recent_date_range  =  DateRange(start_date=recent_start_date,  end_date=recent_end_date)136137#  Retrieve  recent  news  articles  involving  Australia  and  China138news_articles  =  get_news_articles(date_range=recent_date_range,  head_entities=[aus_code],  tail_entities=[chn_code])139140#  Print  the  retrieved  news  articles141for  article  in  news_articles:142  print(article)\end{lstlisting}143  \textbf{Observation}:144  \begin{lstlisting}[language=python]145(Date(date="2023-11-02"),  "No  quick  fix  to  remaining  tariffs  ahead  of  China  visit")146(Date(date="2023-11-02"),  "China"s  aggression  in  Indo-Pacific  leads  to  "concern  and  angst":  Peter  Dutton,  Australia"s  leader  of  opposition")147(Date(date="2023-11-02"),  "Australia  and  China  eye  new  ways  to  heal  old  wounds")148(Date(date="2023-11-02"),  "Albanese  must  aim  beyond  bilateral  outcomes  on  Beijing  visit")149(Date(date="2023-11-02"),  "Western  Australian  Premier  Announces  Visit  to  China")150(Date(date="2023-11-02"),  "Australian  PM"s  China  visit  will  help  normalize  relations,  says  ex-trade  minister")151(Date(date="2023-11-02"),  "Nicholas  Moore  on  how  to  get  in  early  on  the  next  big  growth  story")152(Date(date="2023-11-02"),  "PM"s  China  trip  cements  new  era  for  ties")153(Date(date="2023-11-02"),  "PM  to  take  a  hard  line  on  trade  with  China")154(Date(date="2023-11-01"),  "Australian  Prime  Minister  Anthony  Albanese  to  raise  imprisoned  democracy  blogger  during  China  visit")\end{lstlisting}155  \item  \textbf{Thought}:156  The  recent  news  articles  provide  valuable  context  for  the  relations  between  Australia  and  China.  Key  themes  include:\\157158  1.  \textbf{Diplomatic  Visits  and  Engagements}:  Multiple  articles  highlight  the  upcoming  visit  of  Australian  Prime  Minister  Anthony  Albanese  to  China.  This  aligns  with  the  frequent  occurrence  of  CAMEO  code  \textbf{042  (Make  a  visit)}.\\159  2.  \textbf{Economic  Cooperation  and  Trade}:  Discussions  around  trade  and  economic  cooperation  are  prominent,  indicating  ongoing  efforts  to  improve  economic  ties.  This  supports  the  relevance  of  CAMEO  codes  \textbf{061  (Cooperate  economically)}  and  \textbf{036  (Express  intent  to  meet  or  negotiate)}.\\160  3.  \textbf{Concerns  and  Tensions}:  Articles  mention  concerns  about  China"s  aggression  in  the  Indo-Pacific  and  human  rights  issues,  suggesting  underlying  tensions.  This  is  reflected  in  the  occasional  occurrence  of  CAMEO  code  \textbf{173  (Arrest  or  detain)}.161162  Given  the  historical  data  and  recent  news  context,  the  most  likely  relations  that  Australia  will  take  towards  China  on  November  03,  2023,  include  diplomatic  visits,  economic  cooperation,  and  negotiations,  with  a  possibility  of  addressing  underlying  tensions.163164  Final  Answer:165  \begin{lstlisting}[language=python]166{167  "03":  ["031",  "036"],168  "04":  ["040",  "042",  "043",  "046"],169  "06":  ["061"],170  "17":  ["173"]171}\end{lstlisting}172173  \textbf{Action}:174  Final  Answer:175  \begin{lstlisting}[language=python]176{177  "03":  ["031",  "036"],178  "04":  ["040",  "042",  "043",  "046"],179  "06":  ["061"],180  "17":  ["173"]181}\end{lstlisting}182\end{enumerate}183184185\subsubsection{Agent  Final  Status}186\begin{itemize}187  \item  \textbf{End  State}:  Final  Answer188  \item  \textbf{Number  of  Steps  Taken}:  5189  \item  \textbf{Final  Answer}:190  \begin{lstlisting}[language=python]191{192  "03":  ["031",  "036"],193  "04":  ["040",  "042",  "043",  "046"],194  "06":  ["061"],195  "17":  ["173"]196}\end{lstlisting}197We  show  the  corresponding  relation  names  of  the  predicted  codes  here  for  a  better  review:198  \begin{lstlisting}[language=python]199{200  "Express  intent  to  cooperate":  ["Express  intent  to  engage  in  material  cooperation",  "Express  intent  to  meet  or  negotiate"],201  "Consult":  ["Consult,  not  specified",  "Make  a  visit",  "Host  a  visit",  "Engage  in  negotiation"],202  "Engage  in  material  cooperation":  ["Cooperate  economically"],203  "Coerce":  ["Arrest  or  detain"]204}\end{lstlisting}205  \item  \textbf{Ground  Truth  Answer}:206  \begin{lstlisting}[language=python]207{208  "03":  ["036"],209  "04":  ["042"],210  "17":  ["172"]211}\end{lstlisting}212We  show  the  corresponding  relation  names  of  the  ground-truth  codes  here  for  a  better  review:213  \begin{lstlisting}[language=python]214{215  "Express  intent  to  cooperate":  ["Express  intent  to  meet  or  negotiate"],216  "Consult":  ["Make  a  visit"],217  "Coerce":  ["Impose  administrative  sanctions"]218}\end{lstlisting}219\end{itemize}220221222223224\subsection{GPT-4o-based  Agent  with  ReAct  and  ‘‘\hlc[uclablue!20]{Single  Function}’’  Action}225226\subsubsection{Query  Details}227\begin{itemize}228  \item  \textbf{Query  Quadruplet}:  (2023-11-03,  AUS,  ?,  CHN)229  \item  \textbf{Temporal  Distance}:  1;  therefore,  the  current  date  is  2023-11-02230  \item  \textbf{Agent  Max  Steps}:  20231\end{itemize}232233\subsubsection{Query  Prompt}234Please  forecast  the  relations  that  \hlc[yellow!30]{Australia}  will  take  towards  \hlc[yellow!30]{China}  on  \hlc[yellow!30]{November  03,  2023}  based  on  historical  information  up  to  \hlc[yellow!30]{November  02,  2023}.  I.e.  forecast  the  relation  CAMEO  codes  in  query  event  \hlc[yellow!30]{Event(date=2023-11-03,  head\_entity=ISOCode(AUS),  relation=CAMEOCode(?),  tail\_entity=ISOCode(CHN))}.235236\subsubsection{System  Prompt}237You  are  an  expert  in  forecasting  future  events  based  on  historical  data.  The  database  contains  news  articles  from  January  1,  2023  to  the  current  date  \hlc[yellow!30]{November  02,  2023}  and  the  events  extracted  from  these  articles.  The  events  are  in  the  form  of  (date,  subject  country,  relation,  object  country),  where  the  countries  are  represented  by  ISO  3166-1  alpha-3  codes  and  the  relations  are  represented  by  the  CAMEO  codes  defined  in  the  "Conflict  and  Mediation  Event  Observations"  ontology.  The  relations  are  hierarchical:  first-level  relations  are  general  parent  relations  represented  by  two-digit  CAMEO  codes,  while  second-level  relations  are  more  specific  child  relations  represented  by  three-digit  CAMEO  codes.  Child  relations  have  the  same  first  two  digits  as  their  parent  relations.  For  example,  "01"  is  a  first-level  relation,  and  "010"  and  "011"  are  some  of  its  second-level  relations.  The  relations  in  the  database  are  represented  in  the  second-level  form.238\\\\239Your  task  is  to  forecast  the  future  relations  between  two  entities  in  a  given  query.  You  have  access  to  a  defined  Python  API  that  allows  you  to  query  the  database  for  historical  events  and  statistics,  and  to  get  precise  information  about  the  ISO  country  codes  and  CAMEO  relation  codes.240\\\\241The  defined  API  is  described  as  follows:\\242{\textasciigrave}{\textasciigrave}{\textasciigrave}  python\\243\texttt{\{api\_description\}}\\244{\textasciigrave}{\textasciigrave}{\textasciigrave}245\\\\246You  will  use  an  iterative  approach,  interleaving  "Thought",  "Action",  and  "Observation"  steps  to  collect  information  and  perform  the  forecast.  You  may  perform  up  to  \hlc[yellow!30]{20}  iterations.  The  steps  are  as  follows:247\\\\248-  "Thought":  Analyze  the  current  information  and  reason  about  the  current  situation,  and  predicts  which  API  you  want  to  use  (try  to  use  different  APIs  to  collect  diverse  information)  or  make  a  decision  that  you  want  to  make  a  final  answer.\\249-  "Action":  Use  the  API  to  gather  more  information  or  provide  the  final  forecast.\\250  \hspace*{6mm}-  If  using  the  API:  \hlc[uclablue!20]{the  action  must  be  only  one  single  line  of  exactly  one  function  call  from  the  API  with  appropriate  inputs,  without  additional  code,  explanations,  or  natural  language  descriptions}.\\251  \hspace*{6mm}-  If  making  the  final  forecast:  the  action  must  start  immediately  with  "Final  Answer:",  and  follow  with  the  results  in  the  expected  JSON  format.\\252-  "Observation":  Return  the  output  of  the  called  function.253\\\\254To  make  a  reasonable  forecast,  you  should  collect  both  news  and  relational  evidence  to  support  your  prediction.  When  you  are  fully  confident  that  you  accumulate  enough  information  to  make  the  final  forecast,  you  should  start  the  "Thought"  with  your  reasoning  using  the  news  and  structural  information  to  make  the  prediction,  and  then  start  the  "Action"  step  with  "Final  Answer:"  followed  by  the  answer  in  the  expected  JSON  format.  The  answer  should  be  a  JSON  dictionary  where  the  keys  are  the  forecasted  two-digit  first-level  CAMEO  codes  and  the  values  are  lists  of  forecasted  three-digit  second-level  CAMEO  codes  that  are  child  relations  of  the  key.  For  example,  "Action:  Final  Answer:  \{"01":  ["010",  "011",  "012"],  "02":  ["020",  "023"]\}".255\\\\256The  final  answer  will  be  evaluated  based  on  the  precision  and  recall  of  the  forecasted  first-level  and  second-level  relations,  so  only  include  confident  first-level  and  second-level  CAMEO  codes  in  your  final  forecast.257\\\\258Try  to  use  different  APIs  to  collect  diverse  information  (including  multi-hop  relations),  such  as  the  precise  meaning  of  CAMEO  codes,  insights  from  news  content,  relational  data,  and  statistical  analyses  to  support  your  forecasts.  Consider  not  only  the  frequency  of  the  relations  but  also  the  temporal  aspects  of  the  data  when  making  your  forecast.259260\subsubsection{Agent  ReAct  Process}261\begin{enumerate}262  \item  \textbf{Thought}:263  To  forecast  the  relations  that  Australia  (AUS)  will  take  towards  China  (CHN)  on  November  03,  2023,  I  will  start  by  gathering  historical  data  on  the  interactions  between  these  two  countries.  This  will  include  the  types  of  relations,  their  frequencies,  and  the  context  in  which  they  occurred.  I  will  use  the  following  steps:264265  \begin{enumerate}266  \item  Retrieve  the  distribution  of  second-level  relations  between  Australia  and  China.267  \item  Analyze  the  distribution  to  identify  the  most  common  types  of  interactions.268  \item  Examine  recent  news  articles  to  understand  the  context  and  any  ongoing  trends  or  events  that  might  influence  future  relations.269  \end{enumerate}270271  \textbf{Action}:272  \begin{lstlisting}[language=python]273get_relation_distribution(head_entities=[ISOCode("AUS")],  tail_entities=[ISOCode("CHN")])\end{lstlisting}274  \textbf{Observation}:275  \begin{lstlisting}[language=python]276{CAMEOCode(code="042"):  32,277  CAMEOCode(code="036"):  30,278  CAMEOCode(code="040"):  17,279CAMEOCode(code="061"):  16,280CAMEOCode(code="046"):  12,281CAMEOCode(code="043"):  11,282CAMEOCode(code="010"):  6,283CAMEOCode(code="020"):  5,284CAMEOCode(code="173"):  5,285CAMEOCode(code="012"):  5,286CAMEOCode(code="051"):  4,287CAMEOCode(code="163"):  3,288CAMEOCode(code="128"):  2,289CAMEOCode(code="050"):  2,290CAMEOCode(code="084"):  2,291CAMEOCode(code="090"):  2,292CAMEOCode(code="174"):  1,293CAMEOCode(code="112"):  1,294CAMEOCode(code="130"):  1,295CAMEOCode(code="160"):  1,296CAMEOCode(code="172"):  1,297CAMEOCode(code="192"):  1,298CAMEOCode(code="190"):  1,299CAMEOCode(code="060"):  1,300CAMEOCode(code="030"):  1,301CAMEOCode(code="035"):  1,302CAMEOCode(code="138"):  1,303CAMEOCode(code="071"):  1,304CAMEOCode(code="031"):  1}\end{lstlisting}305  \item  \textbf{Thought}:306  The  distribution  of  second-level  relations  between  Australia  and  China  shows  a  variety  of  interactions,  with  some  relations  being  more  frequent  than  others.  The  most  common  interactions  include:307308  -  "042"  (Consult):  32  occurrences\\309  -  "036"  (Express  intent  to  cooperate):  30  occurrences\\310  -  "040"  (Assure):  17  occurrences\\311  -  "061"  (Cooperate  economically):  16  occurrences\\312  -  "046"  (Praise  or  endorse):  12  occurrences\\313  -  "043"  (Apologize):  11  occurrences\\314315  These  frequent  interactions  suggest  a  trend  towards  diplomatic  and  cooperative  engagements.  However,  to  make  a  more  informed  forecast,  it  is  essential  to  understand  the  context  and  any  recent  developments  that  might  influence  future  relations.316317  Next,  I  will  retrieve  recent  news  articles  involving  Australia  and  China  to  gather  insights  on  the  current  context  and  any  ongoing  trends  or  events.318319  \textbf{Action}:320  \begin{lstlisting}[language=python]321get_news_articles(date_range=DateRange(start_date=Date("2023-10-01"),  end_date=Date("2023-11-02")),  head_entities=[ISOCode("AUS")],  tail_entities=[ISOCode("CHN")])\end{lstlisting}322  \textbf{Observation}:323  \begin{lstlisting}[language=python]324[(Date(date="2023-11-02"),  "No  quick  fix  to  remaining  tariffs  ahead  of  China  visit"),325  (Date(date="2023-11-02"),  "China"s  aggression  in  Indo-Pacific  leads  to  "concern  and  angst":  Peter  Dutton,  Australia"s  leader  of  opposition"),326  (Date(date="2023-11-02"),  "Australia  and  China  eye  new  ways  to  heal  old  wounds"),327  (Date(date="2023-11-02"),  "Albanese  must  aim  beyond  bilateral  outcomes  on  Beijing  visit"),328  (Date(date="2023-11-02"),  "Western  Australian  Premier  Announces  Visit  to  China"),329  (Date(date="2023-11-02"),  "Australian  PM"s  China  visit  will  help  normalize  relations,  says  ex-trade  minister"),330  (Date(date="2023-11-02"),  "Nicholas  Moore  on  how  to  get  in  early  on  the  next  big  growth  story"),331  (Date(date="2023-11-02"),  "PM"s  China  trip  cements  new  era  for  ties"),332  (Date(date="2023-11-02"),  "PM  to  take  a  hard  line  on  trade  with  China"),333  (Date(date="2023-11-01"),  "Australian  Prime  Minister  Anthony  Albanese  to  raise  imprisoned  democracy  blogger  during  China  visit")]\end{lstlisting}334  \item  \textbf{Thought}:335  The  recent  news  articles  indicate  a  mix  of  diplomatic,  economic,  and  security-related  interactions  between  Australia  and  China.  Key  themes  include:336337  -  Diplomatic  engagements  and  efforts  to  normalize  relations,  as  seen  in  articles  about  the  Australian  Prime  Minister"s  visit  to  China  and  efforts  to  heal  old  wounds.\\338  -  Economic  cooperation  and  trade  discussions,  including  addressing  tariffs  and  trade  issues.\\339  -  Security  concerns  and  criticisms,  particularly  related  to  China"s  actions  in  the  Indo-Pacific  region  and  human  rights  issues.\\340341  Given  these  themes,  it  is  likely  that  the  future  relations  between  Australia  and  China  will  involve  a  combination  of  diplomatic  assurances,  economic  cooperation,  and  some  critical  statements  or  actions  related  to  security  and  human  rights.342343  Next,  I  will  retrieve  detailed  descriptions  of  the  most  frequent  second-level  relations  to  ensure  accurate  mapping  and  understanding  of  these  interactions.344345  \textbf{Action}:346  \begin{lstlisting}[language=python]347map_cameo_to_relation(CAMEOCode("042"))\end{lstlisting}348  \textbf{Observation}:349  \begin{lstlisting}[language=python]350Relation(cameo_code=CAMEOCode("042"),  name="Make  a  visit",  description="Travel  to  another  location  for  a  meeting  or  other  event.")\end{lstlisting}351  \item  \textbf{Thought}:352  The  relation  "042"  (Make  a  visit)  involves  traveling  to  another  location  for  a  meeting  or  other  event,  which  aligns  with  the  recent  news  about  the  Australian  Prime  Minister"s  visit  to  China.  This  suggests  that  diplomatic  visits  are  a  significant  aspect  of  the  interactions  between  Australia  and  China.353354  To  further  refine  the  forecast,  I  will  retrieve  detailed  descriptions  for  the  other  most  frequent  second-level  relations:  "036",  "040",  "061",  "046",  and  "043".355356  \textbf{Action}:357  \begin{lstlisting}[language=python]358map_cameo_to_relation(CAMEOCode("036"))\end{lstlisting}359  \textbf{Observation}:360  \begin{lstlisting}[language=python]361Relation(cameo_code=CAMEOCode("036"),  name="Express  intent  to  meet  or  negotiate",  description="Offer,  promise,  agree  to,  or  otherwise  indicate  willingness  or  commitment  to  meet,  visit,  or  engage  in  talks  or  negotiations.")\end{lstlisting}362  \item  \textbf{Thought}:363  The  relation  "036"  (Express  intent  to  meet  or  negotiate)  involves  indicating  a  willingness  or  commitment  to  meet,  visit,  or  engage  in  talks  or  negotiations.  This  aligns  with  the  ongoing  diplomatic  efforts  and  discussions  mentioned  in  the  recent  news  articles.364365  Next,  I  will  retrieve  detailed  descriptions  for  the  relations  "040",  "061",  "046",  and  "043"  to  further  understand  the  context  of  these  interactions.366367  \textbf{Action}:368  \begin{lstlisting}[language=python]369get_parent_relation(CAMEOCode("040"))\end{lstlisting}370  \textbf{Observation}:371  \begin{lstlisting}[language=python]372Relation(cameo_code=CAMEOCode("04"),  name="Consult",  description="All  consultations  and  meetings.")\end{lstlisting}373  \item  \textbf{Thought}:374  The  parent  relation  ‘04‘  (Consult)  encompasses  all  consultations  and  meetings,  which  is  consistent  with  the  frequent  diplomatic  interactions  between  Australia  and  China.  The  specific  relation  "040"  (Assure)  likely  involves  providing  assurances  during  these  consultations.375376  To  further  refine  the  forecast,  I  will  retrieve  detailed  descriptions  for  the  relations  "061",  "046",  and  "043".377378  \textbf{Action}:""379380  \textbf{Observation}:  No  feedback  from  the  environment  due  to  the  null  action.381  \item  \textbf{Thought}:382  I  will  continue  retrieving  detailed  descriptions  for  the  relations  "061",  "046",  and  "043"  to  further  understand  the  context  of  these  interactions.383384  \textbf{Action}:""385386  \textbf{Observation}:  No  feedback  from  the  environment  due  to  the  null  action.387  \item  \textbf{Thought}:388  It  seems  there  was  an  issue  with  my  previous  actions.  I  will  now  proceed  to  retrieve  the  detailed  descriptions  for  the  remaining  frequent  second-level  relations:  "061",  "046",  and  "043".389  \textbf{Action}:390  \begin{lstlisting}[language=python]391map_cameo_to_relation(CAMEOCode("061"))\end{lstlisting}392  \textbf{Observation}:393  \begin{lstlisting}[language=python]394Relation(cameo_code=CAMEOCode("061"),  name="Cooperate  economically",  description="Initiate,  resume,  improve,  or  expand  economic  exchange  or  cooperation.")\end{lstlisting}395  \item  \textbf{Thought}:396  The  relation  "061"  (Cooperate  economically)  involves  initiating,  resuming,  improving,  or  expanding  economic  exchange  or  cooperation.  This  aligns  with  the  recent  news  articles  discussing  trade  issues  and  economic  cooperation  between  Australia  and  China.397398  Next,  I  will  retrieve  detailed  descriptions  for  the  relations  "046"  and  "043".399400  \textbf{Action}:401  \begin{lstlisting}[language=python]402map_cameo_to_relation(CAMEOCode("046"))\end{lstlisting}403  \textbf{Observation}:404  \begin{lstlisting}[language=python]405Relation(cameo_code=CAMEOCode("046"),  name="Engage  in  negotiation",  description="Negotiate  or  bargain  with  others.")\end{lstlisting}406407  \item  \textbf{Thought}:408  The  relation  "046"  (Engage  in  negotiation)  involves  negotiating  or  bargaining  with  others.  This  is  consistent  with  the  ongoing  discussions  and  negotiations  mentioned  in  the  news  articles,  particularly  regarding  trade  and  diplomatic  issues.409410  Next,  I  will  retrieve  the  detailed  description  for  the  relation  "043".411412  \textbf{Action}:""413414  \textbf{Observation}:  No  feedback  from  the  environment  due  to  the  null  action.415416  \item  \textbf{Thought}:417  It  seems  there  was  an  issue  with  my  previous  actions.  I  will  now  proceed  to  retrieve  the  detailed  description  for  the  relation  "043"  to  complete  the  understanding  of  the  most  frequent  interactions  between  Australia  and  China.418419  \textbf{Action}:420  \begin{lstlisting}[language=python]421map_cameo_to_relation(CAMEOCode("043"))\end{lstlisting}422  \textbf{Observation}:423  \begin{lstlisting}[language=python]424Relation(cameo_code=CAMEOCode("043"),  name="Host  a  visit",  description="Host  or  receive  a  visitor  at  residence,  office  or  home  country.")\end{lstlisting}425426  \item  \textbf{Thought}:427  The  relation  "043"  (Host  a  visit)  involves  hosting  or  receiving  a  visitor  at  a  residence,  office,  or  home  country.  This  aligns  with  the  diplomatic  visits  and  engagements  mentioned  in  the  recent  news  articles.428429  Based  on  the  detailed  descriptions  and  the  recent  news  context,  the  most  frequent  interactions  between  Australia  and  China  involve  diplomatic  visits,  economic  cooperation,  negotiations,  and  assurances.  These  interactions  suggest  a  trend  towards  diplomatic  and  cooperative  engagements,  with  some  critical  statements  or  actions  related  to  security  and  human  rights.430431  Given  this  information,  I  am  confident  in  forecasting  the  following  relations  between  Australia  and  China  on  November  03,  2023:432433  -  Diplomatic  visits  and  engagements  ("042",  "043",  "036")434  -  Economic  cooperation  ("061")435  -  Negotiations  ("046")436  -  Assurances  ("040")437438  \textbf{Action}:439  Final  Answer:  \{"04":  ["040",  "042",  "043",  "046"],  "03":  ["036"],  "06":  ["061"]\}440\end{enumerate}441442443444\subsubsection{Agent  Final  Status}445\begin{itemize}446  \item  \textbf{End  State}:  Final  Answer447  \item  \textbf{Number  of  Steps  Taken}:  12448  \item  \textbf{Final  Answer}:449  \begin{lstlisting}[language=python]450{451  "03":  ["036"],452  "04":  ["040",  "042",  "043",  "046"],453  "06":  ["061"]454}\end{lstlisting}455We  show  the  corresponding  relation  names  of  the  predicted  codes  here  for  a  better  review:456  \begin{lstlisting}[language=python]457{458  "Express  intent  to  cooperate":  ["Express  intent  to  meet  or  negotiate"],459  "Consult":  ["Consult,  not  specified",  "Make  a  visit",  "Host  a  visit",  "Engage  in  negotiation"],460  "Engage  in  material  cooperation":  ["Cooperate  economically"]461}\end{lstlisting}462  \item  \textbf{Ground  Truth  Answer}:463  \begin{lstlisting}[language=python]464{465  "03":  ["036"],466  "04":  ["042"],467  "17":  ["172"]468}\end{lstlisting}469We  show  the  corresponding  relation  names  of  the  ground-truth  codes  here  for  a  better  review:470  \begin{lstlisting}[language=python]471{472  "Express  intent  to  cooperate":  ["Express  intent  to  meet  or  negotiate"],473  "Consult":  ["Make  a  visit"],474  "Coerce":  ["Impose  administrative  sanctions"]475}\end{lstlisting}476\end{itemize}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Appendix M Additional Information about API
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: M.1 Overview of API Data Classes and Functions
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Table 7: API data classes and their attributes'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| Class Name | Attributes and Types |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Date | date:  str  #  ‘YYYY-MM-DD’ |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| DateRange | start_date:  Optional[Date], end_date:  Optional[Date] |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ISOCode | code:  str  #  3-letter  ISO  code |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Country | iso_code:  ISOCode, name:  str |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| CAMEOCode | code:  str  #  CAMEO  code |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Relation | cameo_code:  CAMEOCode, name:  str, description:  str |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Event | date:  Date, head_entity:  ISOCode, relation:  CAMEOCode, tail_entity:  ISOCode
    |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| NewsArticle | date:  Date, title:  str, content:  str, events:  List[Event]
    |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: 'Table 8: API functions categorized by functionality'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| Functions related to Countries and Relations |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| map_country_name_to_iso(name:  str)  ->  List[Country] |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| map_iso_to_country_name(iso_code:  ISOCode)  ->  str |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| map_relation_description_to_cameo(description:  str)  ->  List[Relation]
    |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| map_cameo_to_relation(cameo_code:  CAMEOCode)  ->  Relation |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| get_parent_relation(cameo_code:  CAMEOCode)  ->  Relation |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| get_child_relations(cameo_code:  CAMEOCode)  ->  List[Relation] |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| get_sibling_relations(cameo_code:  CAMEOCode)  ->  List[Relation] |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Functions related to Events |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| count_events(date_range:  Optional[DateRange],  head_entities:  Optional[List[ISOCode]],  tail_entities:  Optional[List[ISOCode]],  relations:  Optional[List[CAMEOCode]])  ->  int
    |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| get_events(date_range:  Optional[DateRange],  head_entities:  Optional[List[ISOCode]],  tail_entities:  Optional[List[ISOCode]],  relations:  Optional[List[CAMEOCode]],  text_description:  Optional[str])  ->  List[Event]
    |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| get_entity_distribution(date_range:  Optional[DateRange],  involved_relations:  Optional[List[CAMEOCode]],  interacted_entities:  Optional[List[ISOCode]],  entity_role:  Optional[str])  ->  Dict[ISOCode,  int]
    |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| get_relation_distribution(date_range:  Optional[DateRange],  head_entities:  Optional[List[ISOCode]],  tail_entities:  Optional[List[ISOCode]])  ->  Dict[CAMEOCode,  int]
    |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Functions related to News |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| count_news_articles(date_range:  Optional[DateRange],  head_entities:  Optional[List[ISOCode]],  tail_entities:  Optional[List[ISOCode]],  relations:  Optional[List[CAMEOCode]],  keywords:  Optional[List[str]])  ->  int
    |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| get_news_articles(date_range:  Optional[DateRange],  head_entities:  Optional[List[ISOCode]],  tail_entities:  Optional[List[ISOCode]],  relations:  Optional[List[CAMEOCode]],  keywords:  Optional[List[str]],  text_description:  Optional[str])  ->  List[Tuple[Date,  str]]
    |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| browse_news_article(date:  Date,  title:  str)  ->  str |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: M.2 API Specification
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we provide the API specification, which is part of the system
    prompt for the ReAct agent. It contains the definition of data classes and functions,
    with detailed Python docstring. For dataclass, the specification includes class
    definition and description, attributes and their description, and the example
    of initializing the class object. For functions, the specification includes the
    function definition and description, the parameter and description, the return
    and description, and the example of usage.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[⬇](data:text/plain;base64,QGRhdGFjbGFzcwpjbGFzcyBEYXRlOgogICAgIiIiUmVwcmVzZW50cyBhIGRhdGUuIiIiCiAgICBkYXRlOiBzdHIgIyBEYXRlIGluIHRoZSBmb3JtYXQgJ1lZWVktTU0tREQnCiAgICAjIEV4YW1wbGU6IERhdGUoIjIwMjItMDEtMDEiKQoKQGRhdGFjbGFzcwpjbGFzcyBEYXRlUmFuZ2U6CiAgICAiIiJSZXByZXNlbnRzIGEgcmFuZ2Ugb2YgZGF0ZXMgKGluY2x1c2l2ZSkuIiIiCiAgICBzdGFydF9kYXRlOiBPcHRpb25hbFtEYXRlXSAjIElmIE5vbmUsIHRoZSBlYXJsaWVzdCBkYXRlIGlzIHVzZWQKICAgIGVuZF9kYXRlOiBPcHRpb25hbFtEYXRlXSAjIElmIE5vbmUsIHRoZSBjdXJyZW50IGRhdGUgaXMgdXNlZAogICAgIyBFeGFtcGxlOiBEYXRlUmFuZ2Uoc3RhcnRfZGF0ZT1EYXRlKCIyMDIyLTAxLTAxIiksIGVuZF9kYXRlPURhdGUoIjIwMjItMDEtMzEiKSkKCkBkYXRhY2xhc3MKY2xhc3MgSVNPQ29kZToKICAgICIiIlJlcHJlc2VudHMgYW4gSVNPIGFscGhhLTMgY291bnRyeSBjb2RlLiIiIgogICAgY29kZTogc3RyICMgMy1sZXR0ZXIgSVNPIGNvZGUKICAgICMgRXhhbXBsZTogSVNPQ29kZSgiVVNBIikKCkBkYXRhY2xhc3MKY2xhc3MgQ291bnRyeToKICAgICIiIlJlcHJlc2VudHMgYSBjb3VudHJ5IGVudGl0eS4iIiIKICAgIGlzb19jb2RlOiBJU09Db2RlCiAgICBuYW1lOiBzdHIKICAgICMgRXhhbXBsZTogQ291bnRyeShpc29fY29kZT1JU09Db2RlKCJVU0EiKSwgbmFtZT0iVW5pdGVkIFN0YXRlcyIpCgpAZGF0YWNsYXNzCmNsYXNzIENBTUVPQ29kZToKICAgICIiIlJlcHJlc2VudHMgYSBDQU1FTyB2ZXJiIGNvZGUuIiIiCiAgICBjb2RlOiBzdHIgIyAyLWRpZ2l0IENBTUVPIGNvZGUgZm9yIGZpcnN0IGxldmVsIHJlbGF0aW9ucywgMy1kaWdpdCBDQU1FTyBjb2RlIGZvciBzZWNvbmQgbGV2ZWwgcmVsYXRpb25zCiAgICAjIEV4YW1wbGU6IENBTUVPQ29kZSgiMDEiKSwgQ0FNRU9Db2RlKCIwMTAiKQoKQGRhdGFjbGFzcwpjbGFzcyBSZWxhdGlvbjoKICAgICIiIlJlcHJlc2VudHMgYSByZWxhdGlvbi4iIiIKICAgIGNhbWVvX2NvZGU6IENBTUVPQ29kZQogICAgbmFtZTogc3RyCiAgICBkZXNjcmlwdGlvbjogc3RyICMgQSBicmllZiBkZXNjcmlwdGlvbiBvZiB3aGF0IGV2ZW50IHRoZSByZWxhdGlvbiByZXByZXNlbnRzCiAgICAjIEV4YW1wbGU6IFJlbGF0aW9uKGNhbWVvX2NvZGU9Q0FNRU9Db2RlKCIwMTAiKSwgbmFtZT0iTWFrZSBzdGF0ZW1lbnQsIG5vdCBzcGVjaWZpZWQiLCBkZXNjcmlwdGlvbj0iQWxsIHB1YmxpYyBzdGF0ZW1lbnRzIGV4cHJlc3NlZCB2ZXJiYWxseSBvciBpbiBhY3Rpb24sIG5vdCBvdGhlcndpc2Ugc3BlY2lmaWVkLiIKCkBkYXRhY2xhc3MKY2xhc3MgRXZlbnQ6CiAgICAiIiJSZXByZXNlbnRzIGFuIGV2ZW50IGNoYXJhY3Rlcml6ZWQgYnkgZGF0ZSwgaGVhZCBlbnRpdHksIHJlbGF0aW9uLCBhbmQgdGFpbCBlbnRpdHkuIiIiCiAgICBkYXRlOiBEYXRlCiAgICBoZWFkX2VudGl0eTogSVNPQ29kZQogICAgcmVsYXRpb246IENBTUVPQ29kZQogICAgdGFpbF9lbnRpdHk6IElTT0NvZGUKICAgICMgRXhhbXBsZTogRXZlbnQoZGF0ZT1EYXRlKCIyMDIyLTAxLTAxIiksIGhlYWRfZW50aXR5PUlTT0NvZGUoIlVTQSIpLCByZWxhdGlvbj1DQU1FT0NvZGUoIjAxMCIpLCB0YWlsX2VudGl0eT1JU09Db2RlKCJDQU4iKSkKCkBkYXRhY2xhc3MKY2xhc3MgTmV3c0FydGljbGU6CiAgICAiIiJSZXByZXNlbnRzIGEgbmV3cyBhcnRpY2xlLCBpbmNsdWRpbmcgbWV0YWRhdGEgYW5kIGNvbnRlbnQuIiIiCiAgICBkYXRlOiBEYXRlCiAgICB0aXRsZTogc3RyCiAgICBjb250ZW50OiBzdHIgIyBGdWxsIHRleHQgY29udGVudCBvZiB0aGUgbmV3cyBhcnRpY2xlCiAgICBldmVudHM6IExpc3RbRXZlbnRdICMgTGlzdCBvZiBldmVudHMgbWVudGlvbmVkIGluIHRoZSBhcnRpY2xlCiAgICAjIEV4YW1wbGU6IE5ld3NBcnRpY2xlKGRhdGU9RGF0ZSgiMjAyMi0wMS0wMSIpLCB0aXRsZT0iVHJhZGUgYWdyZWVtZW50IGJldHdlZW4gVVNBIGFuZCBDaGluYSIsIGNvbnRlbnQ9Ik9uIEphbnVhcnkgMSwgMjAyMiwgYSB0cmFkZSBhZ3JlZW1lbnQgd2FzIHNpZ25lZCBiZXR3ZWVuIHRoZSBVU0EgYW5kIENoaW5hLi4uIiwgZXZlbnRzPVtFdmVudChkYXRlPURhdGUoIjIwMjItMDEtMDEiKSwgaGVhZF9lbnRpdHk9SVNPQ29kZSgiVVNBIiksIHJlbGF0aW9uPUNBTUVPQ29kZSgiMDEwIiksIHRhaWxfZW50aXR5PUlTT0NvZGUoIkNITiIpXSkKCiAgICBkZWYgX19zdHJfXyhzZWxmKToKICAgICAgICByZXR1cm4gZiJ7c2VsZi5kYXRlfTpcbntzZWxmLnRpdGxlfVxue3NlbGYuY29udGVudH0iCgpkZWYgbWFwX2NvdW50cnlfbmFtZV90b19pc28obmFtZTogc3RyKSAtPiBMaXN0W0NvdW50cnldOgogICAgIiIiCiAgICBNYXBzIGEgY291bnRyeSBuYW1lIHRvIHRoZSBtb3N0IGxpa2VseSBjb3JyZXNwb25kaW5nIENvdW50cnkgb2JqZWN0cyB3aXRoIElTTyBjb2Rlcy4KCiAgICBQYXJhbWV0ZXJzOgogICAgICAgIG5hbWUgKHN0cik6IFRoZSBjb3VudHJ5IG5hbWUgdG8gbWFwLgoKICAgIFJldHVybnM6CiAgICAgICAgTGlzdFtDb3VudHJ5XTogQSBsaXN0IG9mIDUgbW9zdCBsaWtlbHkgQ291bnRyeSBvYmplY3RzIHNvcnRlZCBieSByZWxldmFuY2UuCgogICAgRXhhbXBsZToKICAgICAgICA+Pj4gbWFwX2NvdW50cnlfbmFtZV90b19pc28oIktvcmVhIikKICAgICAgICBbQ291bnRyeShpc29fY29kZT1JU09Db2RlKCJLT1IiKSwgbmFtZT0iUmVwdWJsaWMgb2YgS29yZWEiKSwgQ291bnRyeShpc29fY29kZT1JU09Db2RlKCJQUksiKSwgbmFtZT0iRGVtb2NyYXRpYyBQZW9wbGUncyBSZXB1YmxpYyBvZiBLb3JlYSIpXQogICAgIiIiCiAgICBwYXNzCgpkZWYgbWFwX2lzb190b19jb3VudHJ5X25hbWUoaXNvX2NvZGU6IElTT0NvZGUpIC0+IHN0cjoKICAgICIiIgogICAgTWFwcyBhbiBJU08gY29kZSB0byBhIGNvdW50cnkgbmFtZS4KCiAgICBQYXJhbWV0ZXJzOgogICAgICAgIGlzb19jb2RlIChJU09Db2RlKTogVGhlIElTTyBjb2RlIHRvIG1hcC4KCiAgICBSZXR1cm5zOgogICAgICAgIHN0cjogVGhlIGNvcnJlc3BvbmRpbmcgY291bnRyeSBuYW1lLgoKICAgIEV4YW1wbGU6CiAgICAgICAgPj4+IG1hcF9pc29fdG9fY291bnRyeV9uYW1lKElTT0NvZGUoIkNITiIpKQogICAgICAgICJDaGluYSIKICAgICIiIgogICAgcGFzcwoKZGVmIG1hcF9yZWxhdGlvbl9kZXNjcmlwdGlvbl90b19jYW1lbyhkZXNjcmlwdGlvbjogc3RyKSAtPiBMaXN0W1JlbGF0aW9uXToKICAgICIiIgogICAgTWFwcyBhIHJlbGF0aW9uIGRlc2NyaXB0aW9uIHRvIHRoZSBtb3N0IGxpa2VseSBSZWxhdGlvbiBvYmplY3RzLgoKICAgIFBhcmFtZXRlcnM6CiAgICAgICAgZGVzY3JpcHRpb24gKHN0cik6IFRoZSByZWxhdGlvbiBkZXNjcmlwdGlvbiB0byBtYXAuCgogICAgUmV0dXJuczoKICAgICAgICBMaXN0W1JlbGF0aW9uXTogQSBsaXN0IG9mIDUgbW9zdCBsaWtlbHkgUmVsYXRpb25zIHNvcnRlZCBieSByZWxldmFuY2UuCgogICAgRXhhbXBsZToKICAgICAgICA+Pj4gbWFwX3JlbGF0aW9uX2Rlc2NyaXB0aW9uX3RvX2NhbWVvKCJGaWdodCB3aXRoIGd1bnMiKQogICAgICAgIFtSZWx0aW9uKGNhbWVvX2NvZGU9Q0FNRU9Db2RlKCIxOSIpLCBuYW1lPSJGaWdodCIsIGRlc2NyaXB0aW9uPSJBbGwgdXNlcyBvZiBjb252ZW50aW9uYWwgZm9yY2UgYW5kIGFjdHMgb2Ygd2FyIHR5cGljYWxseSBieSBvcmdhbml6ZWQgYXJtZWQgZ3JvdXBzLiIpLCBSZWxhdGlvbihjYW1lb19jb2RlPUNBTUVPQ29kZSgiMTkzIiksIG5hbWU9IkZpZ2h0IHdpdGggc21hbGwgYXJtcyBhbmQgbGlnaHQgd2VhcG9ucyIsIGRlc2NyaXB0aW9uPSJBdHRhY2sgdXNpbmcgc21hbGwgYXJtcyBhbmQgbGlnaHQgd2VhcG9ucyBzdWNoIGFzIHJpZmxlcywgbWFjaGluZS1ndW5zLCBhbmQgbW9ydGFyIHNoZWxscy4iKSwgUmVsYXRpb24oY2FtZW9fY29kZT1DQU1FT0NvZGUoIjE5MCIpLCBuYW1lPSJVc2UgY29udmVudGlvbmFsIG1pbGl0YXJ5IGZvcmNlLCBub3Qgc3BlY2lmaWVkIiwgZGVzY3JpcHRpb249IkFsbCB1c2VzIG9mIGNvbnZlbnRpb25hbCBmb3JjZSBhbmQgYWN0cyBvZiB3YXIgdHlwaWNhbGx5IGJ5IG9yZ2FuaXplZCBhcm1lZCBncm91cHMsIG5vdCBvdGhlcndpc2Ugc3BlY2lmaWVkLiIpXQogICAgIiIiCiAgICBwYXNzCgpkZWYgbWFwX2NhbWVvX3RvX3JlbGF0aW9uKGNhbWVvX2NvZGU6IENBTUVPQ29kZSkgLT4gUmVsYXRpb246CiAgICAiIiIKICAgIE1hcHMgYSBDQU1FTyBjb2RlIHRvIGEgcmVsYXRpb24sIGluY2x1ZGluZyBpdHMgbmFtZSBhbmQgZGVzY3JpcHRpb24uCgogICAgUGFyYW1ldGVyczoKICAgICAgICBjYW1lb19jb2RlIChDQU1FT0NvZGUpOiBUaGUgQ0FNRU8gY29kZSB0byBtYXAuCgogICAgUmV0dXJuczoKICAgICAgICBSZWxhdGlvbjogVGhlIGNvcnJlc3BvbmRpbmcgcmVsYXRpb24uCgogICAgRXhhbXBsZToKICAgICAgICA+Pj4gbWFwX2NhbWVvX3RvX3JlbGF0aW9uKENBTUVPQ29kZSgiMTkwIikpCiAgICAgICAgUmVsYXRpb24oY2FtZW9fY29kZT1DQU1FT0NvZGUoIjE5MCIpLCBuYW1lPSJVc2UgY29udmVudGlvbmFsIG1pbGl0YXJ5IGZvcmNlLCBub3Qgc3BlY2lmaWVkIiwgZGVzY3JpcHRpb249IkFsbCB1c2VzIG9mIGNvbnZlbnRpb25hbCBmb3JjZSBhbmQgYWN0cyBvZiB3YXIgdHlwaWNhbGx5IGJ5IG9yZ2FuaXplZCBhcm1lZCBncm91cHMsIG5vdCBvdGhlcndpc2Ugc3BlY2lmaWVkLiIpCiAgICAiIiIKICAgIHBhc3MKCmRlZiBnZXRfY2hpbGRfcmVsYXRpb25zKGNhbWVvX2NvZGU6IENBTUVPQ29kZSkgLT4gTGlzdFtSZWxhdGlvbl06CiAgICAiIiIKICAgIFJldHJpZXZlcyBjaGlsZCByZWxhdGlvbnMgb2YgYSBnaXZlbiByZWxhdGlvbiBpZGVudGlmaWVkIGJ5IENBTUVPIGNvZGUuCgogICAgUGFyYW1ldGVyczoKICAgICAgICBjYW1lb19jb2RlIChDQU1FT0NvZGUpOiBUaGUgQ0FNRU8gY29kZSBvZiB0aGUgcmVsYXRpb24gd2hvc2UgY2hpbGRyZW4gYXJlIHNvdWdodC4gT25seSBmaXJzdCBsZXZlbCByZWxhdGlvbnMgYXJlIGFjY2VwdGVkLgoKICAgIFJldHVybnM6CiAgICAgICAgTGlzdFtSZWxhdGlvbl06IEEgbGlzdCBvZiBzZWNvbmQgbGV2ZWwgY2hpbGQgcmVsYXRpb25zLgoKICAgIEV4YW1wbGU6CiAgICAgICAgPj4+IGdldF9jaGlsZF9yZWxhdGlvbnMoQ0FNRU9Db2RlKCIxOSIpKQogICAgICAgIFtSZWxhdGlvbihjYWVtb19jb2RlPUNBTUVPQ29kZSgiMTkwIiksIG5hbWU9IlVzZSBjb252ZW50aW9uYWwgbWlsaXRhcnkgZm9yY2UsIG5vdCBzcGVjaWZpZWQiLCBkZXNjcmlwdGlvbj0iQWxsIHVzZXMgb2YgY29udmVudGlvbmFsIGZvcmNlIGFuZCBhY3RzIG9mIHdhciB0eXBpY2FsbHkgYnkgb3JnYW5pemVkIGFybWVkIGdyb3Vwcywgbm90IG90aGVyd2lzZSBzcGVjaWZpZWQuIiksIFJlbGF0aW9uKGNhbWVvX2NvZGU9Q0FNRU9Db2RlKCIxOTEiKSwgbmFtZT0iSW1wb3NlIGJsb2NrYWRlIG9yIHJlc3RyaWN0IG1vdmVtZW50IiwgZGVzY3JpcHRpb249IlByZXZlbnQgZW50cnkgaW50byBhbmQvb3IgZXhpdCBmcm9tIGEgdGVycml0b3J5IHVzaW5nIGFybWVkIGZvcmNlcy4iKSwgLi4uXQogICAgIiIiCiAgICBwYXNzCgpkZWYgZ2V0X3NpYmxpbmdfcmVsYXRpb25zKGNhbWVvX2NvZGU6IENBTUVPQ29kZSkgLT4gTGlzdFtSZWxhdGlvbl06CiAgICAiIiIKICAgIFJldHJpZXZlcyBzaWJsaW5nIHJlbGF0aW9ucyBvZiBhIGdpdmVuIHJlbGF0aW9uIGlkZW50aWZpZWQgYnkgQ0FNRU8gY29kZS4KCiAgICBQYXJhbWV0ZXJzOgogICAgICAgIGNhbWVvX2NvZGUgKENBTUVPQ29kZSk6IFRoZSBDQU1FTyBjb2RlIG9mIHRoZSByZWxhdGlvbiB3aG9zZSBzaWJsaW5ncyBhcmUgc291Z2h0LiBCb3RoIGZpcnN0IGFuZCBzZWNvbmQgbGV2ZWwgcmVsYXRpb25zIGFyZSBhY2NlcHRlZC4KCiAgICBSZXR1cm5zOgogICAgICAgIExpc3RbUmVsYXRpb25dOiBBIGxpc3Qgb2Ygc2libGluZyByZWxhdGlvbnMgYXQgdGhlIHNhbWUgbGV2ZWwuCgogICAgRXhhbXBsZToKICAgICAgICA+Pj4gZ2V0X3NpYmxpbmdfcmVsYXRpb25zKENBTUVPQ29kZSgiMTkzIikpCiAgICAgICAgW1JlbGF0aW9uKGNhZW1vX2NvZGU9Q0FNRU9Db2RlKCIxOTAiKSwgbmFtZT0iVXNlIGNvbnZlbnRpb25hbCBtaWxpdGFyeSBmb3JjZSwgbm90IHNwZWNpZmllZCIsIGRlc2NyaXB0aW9uPSJBbGwgdXNlcyBvZiBjb252ZW50aW9uYWwgZm9yY2UgYW5kIGFjdHMgb2Ygd2FyIHR5cGljYWxseSBieSBvcmdhbml6ZWQgYXJtZWQgZ3JvdXBzLCBub3Qgb3RoZXJ3aXNlIHNwZWNpZmllZC4iKSwgUmVsYXRpb24oY2FtZW9fY29kZT1DQU1FT0NvZGUoIjE5MSIpLCBuYW1lPSJJbXBvc2UgYmxvY2thZGUgb3IgcmVzdHJpY3QgbW92ZW1lbnQiLCBkZXNjcmlwdGlvbj0iUHJldmVudCBlbnRyeSBpbnRvIGFuZC9vciBleGl0IGZyb20gYSB0ZXJyaXRvcnkgdXNpbmcgYXJtZWQgZm9yY2VzLiIpLCAuLi5dCiAgICAiIiIKICAgIHBhc3MKCmRlZiBjb3VudF9ldmVudHMoZGF0ZV9yYW5nZTogT3B0aW9uYWxbRGF0ZVJhbmdlXSA9IE5vbmUsIGhlYWRfZW50aXRpZXM6IE9wdGlvbmFsW0xpc3RbSVNPQ29kZV1dID0gTm9uZSwgdGFpbF9lbnRpdGllczogT3B0aW9uYWxbTGlzdFtJU09Db2RlXV0gPSBOb25lLCByZWxhdGlvbnM6IE9wdGlvbmFsW0xpc3RbQ0FNRU9Db2RlXV0gPSBOb25lKSAtPiBpbnQ6CiAgICAiIiIKICAgIENvdW50cyB0aGUgbnVtYmVyIG9mIGV2ZW50cyBpbiB0aGUga25vd2xlZGdlIGdyYXBoIGJhc2VkIG9uIHNwZWNpZmllZCBjb25kaXRpb25zLgoKICAgIFBhcmFtZXRlcnM6CiAgICAgICAgZGF0ZV9yYW5nZSAoT3B0aW9uYWxbRGF0ZVJhbmdlXSk6IFJhbmdlIG9mIGRhdGVzIHRvIGZpbHRlciB0aGUgZXZlbnRzLiBJZiBOb25lLCBhbGwgZGF0ZXMgYXJlIGluY2x1ZGVkLgogICAgICAgIGhlYWRfZW50aXRpZXMgKE9wdGlvbmFsW0xpc3RbSVNPQ29kZV1dKTogTGlzdCBvZiBoZWFkIGVudGl0eSBJU08gY29kZXMgdG8gYmUgaW5jbHVkZWQuIElmIE5vbmUsIGFsbCBjb3VudHJpZXMgYXJlIGluY2x1ZGVkLgogICAgICAgIHRhaWxfZW50aXRpZXMgKE9wdGlvbmFsW0xpc3RbSVNPQ29kZV1dKTogTGlzdCBvZiB0YWlsIGVudGl0eSBJU08gY29kZXMgdG8gYmUgaW5jbHVkZWQuIElmIE5vbmUsIGFsbCBjb3VudHJpZXMgYXJlIGluY2x1ZGVkLgogICAgICAgIHJlbGF0aW9ucyAoT3B0aW9uYWxbTGlzdFtDQU1FT0NvZGVdXSk6IExpc3Qgb2YgcmVsYXRpb24gQ0FNRU8gY29kZXMgdG8gYmUgaW5jbHVkZWQuIElmIGZpcnN0IGxldmVsIHJlbGF0aW9ucyBhcmUgbGlzdGVkLCBhbGwgc2Vjb25kIGxldmVsIHJlbGF0aW9ucyB1bmRlciB0aGVtIGFyZSBpbmNsdWRlZC4gSWYgTm9uZSwgYWxsIHJlbGF0aW9ucyBhcmUgaW5jbHVkZWQuCgogICAgUmV0dXJuczoKICAgICAgICBpbnQ6IENvdW50IG9mIHVuaXF1ZSBldmVudHMgbWF0Y2hpbmcgdGhlIGNvbmRpdGlvbnMuCgogICAgRXhhbXBsZToKICAgICAgICA+Pj4gY291bnRfZXZlbnRzKGRhdGVfcmFuZ2U9RGF0ZVJhbmdlKHN0YXJ0X2RhdGU9RGF0ZSgiMjAyMi0wMS0wMSIpLCBlbmRfZGF0ZT1EYXRlKCIyMDIyLTAxLTMxIikpLCBoZWFkX2VudGl0aWVzPVtJU09Db2RlKCJVU0EiKSwgSVNPQ29kZSgiQ0hOIildLCB0YWlsX2VudGl0aWVzPU5vbmUsIHJlbGF0aW9ucz1bQ0FNRU9Db2RlKCIwMTAiKV0pCiAgICAgICAgNAogICAgIiIiCiAgICBwYXNzCgpkZWYgZ2V0X2V2ZW50cyhkYXRlX3JhbmdlOiBPcHRpb25hbFtEYXRlUmFuZ2VdID0gTm9uZSwgaGVhZF9lbnRpdGllczogT3B0aW9uYWxbTGlzdFtJU09Db2RlXV0gPSBOb25lLCB0YWlsX2VudGl0aWVzOiBPcHRpb25hbFtMaXN0W0lTT0NvZGVdXSA9IE5vbmUsIHJlbGF0aW9uczogT3B0aW9uYWxbTGlzdFtDQU1FT0NvZGVdXSA9IE5vbmUsIHRleHRfZGVzY3JpcHRpb246IE9wdGlvbmFsW3N0cl0gPSBOb25lKSAtPiBMaXN0W0V2ZW50XToKICAgICIiIgogICAgUmV0cmlldmVzIGV2ZW50cyBmcm9tIHRoZSBrbm93bGVkZ2UgZ3JhcGggYmFzZWQgb24gc3BlY2lmaWVkIGNvbmRpdGlvbnMuCiAgICBJbmhlcml0cyBjb21tb24gZmlsdGVyIHBhcmFtZXRlcnMgZnJvbSBjb3VudF9ldmVudHMuIFNlZSBjb3VudF9ldmVudHMgZm9yIG1vcmUgZGV0YWlscyBvbiB0aGVzZSBwYXJhbWV0ZXJzLgoKICAgIEFkZGl0aW9uYWwgUGFyYW1ldGVyczoKICAgICAgICB0ZXh0X2Rlc2NyaXB0aW9uIChPcHRpb25hbFtzdHJdKTogVGV4dHVhbCBkZXNjcmlwdGlvbiB0byBtYXRjaCB3aXRoIHRoZSBzb3VyY2UgbmV3cyBhcnRpY2xlcyBvZiBldmVudHMuIElmIE5vbmUsIHRoZSByZXR1cm5lZCBldmVudHMgYXJlIHNvcnRlZCBieSBkYXRlIGluIGRlc2NlbmRpbmcgb3JkZXI7IG90aGVyd2lzZSwgc29ydGVkIGJ5IHJlbGV2YW5jZSBvZiB0aGUgc291cmNlIG5ld3MgYXJ0aWNsZSB0byB0aGUgZGVzY3JpcHRpb24uCgogICAgUmV0dXJuczoKICAgICAgICBMaXN0W0V2ZW50XTogQSBsaXN0IG9mIG1heGltdW0gMzAgZXZlbnRzIG1hdGNoaW5nIHRoZSBzcGVjaWZpZWQgY29uZGl0aW9ucy4KCiAgICBFeGFtcGxlOgogICAgICAgID4+PiBnZXRfZXZlbnRzKGRhdGVfcmFuZ2U9RGF0ZVJhbmdlKHN0YXJ0X2RhdGU9RGF0ZSgiMjAyMi0wMS0wMSIpLCBlbmRfZGF0ZT1EYXRlKCIyMDIyLTAxLTMxIikpLCBoZWFkX2VudGl0aWVzPVtJU09Db2RlKCJVU0EiKSwgSVNPQ29kZSgiQ0hOIildLCB0YWlsX2VudGl0aWVzPU5vbmUsIHJlbGF0aW9ucz1bQ0FNRU9Db2RlKCIwMTAiKV0sIHRleHRfZGVzY3JpcHRpb249ImVjb25vbWljIHRyYWRlIikKICAgICAgICBbRXZlbnQoZGF0ZT1EYXRlKCIyMDIyLTAxLTE1IiksIGhlYWRfZW50aXR5PUlTT0NvZGUoIlVTQSIpLCByZWxhdGlvbj1DQU1FT0NvZGUoIjAxMCIpLCB0YWlsX2VudGl0eT1JU09Db2RlKCJDQU4iKSwgRXZlbnQoZGF0ZT1EYXRlKCIyMDIyLTAxLTEwIiksIGhlYWRfZW50aXR5PUlTT0NvZGUoIkNITiIpLCByZWxhdGlvbj1DQU1FT0NvZGUoIjAxMCIpLCB0YWlsX2VudGl0eT1JU09Db2RlKCJVU0EiKSwgLi4uXQogICAgIiIiCiAgICBwYXNzCgpkZWYgZ2V0X2VudGl0eV9kaXN0cmlidXRpb24oZGF0ZV9yYW5nZTogT3B0aW9uYWxbRGF0ZVJhbmdlXSA9IE5vbmUsIGludm9sdmVkX3JlbGF0aW9uczogT3B0aW9uYWxbTGlzdFtDQU1FT0NvZGVdXSA9IE5vbmUsIGludGVyYWN0ZWRfZW50aXRpZXM6IE9wdGlvbmFsW0xpc3RbSVNPQ29kZV1dID0gTm9uZSwgZW50aXR5X3JvbGU6IE9wdGlvbmFsW3N0cl0gPSBOb25lKSAtPiBEaWN0W0lTT0NvZGUsIGludF06CiAgICAiIiIKICAgIEdldHMgdGhlIGRpc3RyaWJ1dGlvbiBvZiBlbnRpdGllcyBpbiB0aGUga25vd2xlZGdlIGdyYXBoIHVuZGVyIHNwZWNpZmllZCBjb25kaXRpb25zLgoKICAgIFBhcmFtZXRlcnM6CiAgICAgICAgZGF0ZV9yYW5nZSAoT3B0aW9uYWxbRGF0ZVJhbmdlXSk6IFJhbmdlIG9mIGRhdGVzIHRvIGZpbHRlciB0aGUgZXZlbnRzLiBJZiBOb25lLCBhbGwgZGF0ZXMgYXJlIGluY2x1ZGVkLgogICAgICAgIGludm9sdmVkX3JlbGF0aW9ucyAoT3B0aW9uYWxbTGlzdFtDQU1FT0NvZGVdXSk6IExpc3Qgb2YgcmVsYXRpb25zIHRoYXQgdGhlIHJldHVybmVkIGVudGl0aWVzIG11c3QgYmUgaW52b2x2ZWQgaW4gYW55IG9mLiBJZiBmaXJzdCBsZXZlbCByZWxhdGlvbnMgYXJlIGxpc3RlZCwgYWxsIHNlY29uZCBsZXZlbCByZWxhdGlvbnMgdW5kZXIgdGhlbSBhcmUgaW5jbHVkZWQuIElmIE5vbmUsIGFsbCByZWxhdGlvbnMgYXJlIGluY2x1ZGVkLgogICAgICAgIGludGVyYWN0ZWRfZW50aXRpZXMgKE9wdGlvbmFsW0xpc3RbSVNPQ29kZV1dKTogTGlzdCBvZiBlbnRpdGllcyB0aGF0IHRoZSByZXR1cm5lZCBlbnRpdGllcyBtdXN0IGhhdmUgaW50ZXJhY3RlZCB3aXRoIGFueSBvZi4gSWYgTm9uZSwgYWxsIGVudGl0aWVzIGFyZSBpbmNsdWRlZC4KICAgICAgICBlbnRpdHlfcm9sZSAoT3B0aW9uYWxbRW50aXR5Um9sZV0pOiBTcGVjaWZpZXMgdGhlIHJvbGUgb2YgdGhlIHJldHVybmVkIGVudGl0eSBpbiB0aGUgZXZlbnRzLiBPcHRpb25zIGFyZSAnaGVhZCcsICd0YWlsJywgb3IgJ2JvdGgnLiBJZiAnYm90aCcgb3IgTm9uZSwgdGhlIHJldHVybmVkIGVudGl0eSBjYW4gYmUgZWl0aGVyIGhlYWQgb3IgdGFpbC4KCiAgICBSZXR1cm5zOgogICAgICAgIERpY3RbSVNPQ29kZSwgaW50XTogQSBkaWN0aW9uYXJ5IG1hcHBpbmcgcmV0dXJuZWQgZW50aXRpZXMnIElTTyBjb2RlcyB0byB0aGUgbnVtYmVyIG9mIGV2ZW50cyB3aXRoIHRoZSBzcGVjaWZpZWQgY29uZGl0aW9ucyBpbiB3aGljaCB0aGV5IGFyZSBpbnZvbHZlZCwgc29ydGVkIGJ5IGNvdW50cyBpbiBkZXNjZW5kaW5nIG9yZGVyLgoKICAgIEV4YW1wbGU6CiAgICAgICAgPj4+IGdldF9lbnRpdHlfZGlzdHJpYnV0aW9uKGRhdGVfcmFuZ2U9RGF0ZVJhbmdlKHN0YXJ0X2RhdGU9RGF0ZSgiMjAyMi0wMS0wMSIpLCBlbmRfZGF0ZT1EYXRlKCIyMDIyLTAxLTMxIikpLCBpbnZvbHZlZF9yZWxhdGlvbnM9W0NBTUVPQ29kZSgiMDEwIildLCBpbnRlcmFjdGVkX2VudGl0aWVzPVtJU09Db2RlKCJVU0EiKSwgSVNPQ29kZSgiQ0hOIildLCBlbnRpdHlfcm9sZT0idGFpbCIpCiAgICAgICAge0lTT0NvZGUoIlVTQSIpOiAzLCBJU09Db2RlKCJDSE4iKTogMX0KICAgICIiIgogICAgcGFzcwoKZGVmIGdldF9yZWxhdGlvbl9kaXN0cmlidXRpb24oZGF0ZV9yYW5nZTogT3B0aW9uYWxbRGF0ZVJhbmdlXSA9IE5vbmUsIGhlYWRfZW50aXRpZXM6IE9wdGlvbmFsW0xpc3RbSVNPQ29kZV1dID0gTm9uZSwgdGFpbF9lbnRpdGllczogT3B0aW9uYWxbTGlzdFtJU09Db2RlXV0gPSBOb25lKSAtPiBEaWN0W0NBTUVPQ29kZSwgaW50XToKICAgICIiIgogICAgR2V0cyB0aGUgZGlzdHJpYnV0aW9uIG9mIHNlY29uZCBsZXZlbCByZWxhdGlvbnMgaW4gdGhlIGtub3dsZWRnZSBncmFwaCB1bmRlciBzcGVjaWZpZWQgY29uZGl0aW9ucy4KCiAgICBQYXJhbWV0ZXJzOgogICAgICAgIGRhdGVfcmFuZ2UgKE9wdGlvbmFsW0RhdGVSYW5nZV0pOiBSYW5nZSBvZiBkYXRlcyB0byBmaWx0ZXIgdGhlIGV2ZW50cy4gSWYgTm9uZSwgYWxsIGRhdGVzIGFyZSBpbmNsdWRlZC4KICAgICAgICBoZWFkX2VudGl0aWVzIChPcHRpb25hbFtMaXN0W0lTT0NvZGVdXSk6IExpc3Qgb2YgaGVhZCBlbnRpdGllcyB0aGF0IHRoZSBldmVudHMgbXVzdCBpbnZvbHZlIGFueSBvZi4gSWYgTm9uZSwgYWxsIGhlYWQgZW50aXRpZXMgYXJlIGluY2x1ZGVkLgogICAgICAgIHRhaWxfZW50aXRpZXMgKE9wdGlvbmFsW0xpc3RbSVNPQ29kZV1dKTogTGlzdCBvZiB0YWlsIGVudGl0aWVzIHRoYXQgdGhlIGV2ZW50cyBtdXN0IGludm9sdmUgYW55IG9mLiBJZiBOb25lLCBhbGwgdGFpbCBlbnRpdGllcyBhcmUgaW5jbHVkZWQuCgogICAgUmV0dXJuczoKICAgICAgICBEaWN0W0NBTUVPQ29kZSwgaW50XTogQSBkaWN0aW9uYXJ5IG1hcHBpbmcgc2Vjb25kIGxldmVsIHJlbGF0aW9ucycgQ0FNRU8gY29kZXMgdG8gdGhlIG51bWJlciBvZiBldmVudHMgd2l0aCB0aGUgc3BlY2lmaWVkIGNvbmRpdGlvbnMgaW4gd2hpY2ggdGhleSBhcmUgaW52b2x2ZWQsIHNvcnRlZCBieSBjb3VudHMgaW4gZGVzY2VuZGluZyBvcmRlci4KCiAgICBFeGFtcGxlOgogICAgICAgID4+PiBnZXRfcmVsYXRpb25fZGlzdHJpYnV0aW9uKGRhdGVfcmFuZ2U9RGF0ZVJhbmdlKHN0YXJ0X2RhdGU9RGF0ZSgiMjAyMi0wMS0wMSIpLCBlbmRfZGF0ZT1EYXRlKCIyMDIyLTAxLTMxIikpLCBoZWFkX2VudGl0aWVzPVtJU09Db2RlKCJVU0EiKSwgSVNPQ29kZSgiQ0hOIildLCB0YWlsX2VudGl0aWVzPU5vbmUpCiAgICAgICAge0NBTUVPQ29kZSgiMDEwIik6IDMsIENBTUVPQ29kZSgiMDExIik6IDF9CiAgICAiIiIKICAgIHBhc3MKCmRlZiBjb3VudF9uZXdzX2FydGljbGVzKGRhdGVfcmFuZ2U6IE9wdGlvbmFsW0RhdGVSYW5nZV0gPSBOb25lLCBoZWFkX2VudGl0aWVzOiBPcHRpb25hbFtMaXN0W0lTT0NvZGVdXSA9IE5vbmUsIHRhaWxfZW50aXRpZXM6IE9wdGlvbmFsW0xpc3RbSVNPQ29kZV1dID0gTm9uZSwgcmVsYXRpb25zOiBPcHRpb25hbFtMaXN0W0NBTUVPQ29kZV1dID0gTm9uZSwga2V5d29yZHM6IE9wdGlvbmFsW0xpc3Rbc3RyXV0gPSBOb25lKSAtPiBpbnQ6CiAgICAiIiIKICAgIENvdW50cyB0aGUgbnVtYmVyIG9mIG5ld3MgYXJ0aWNsZXMgYmFzZWQgb24gc3BlY2lmaWVkIGNvbmRpdGlvbnMuCgogICAgUGFyYW1ldGVyczoKICAgICAgICBkYXRlX3JhbmdlIChPcHRpb25hbFtEYXRlUmFuZ2VdKTogUmFuZ2Ugb2YgZGF0ZXMgdG8gZmlsdGVyIHRoZSBuZXdzIGFydGljbGVzLiBJZiBOb25lLCBhbGwgZGF0ZXMgYXJlIGluY2x1ZGVkLgogICAgICAgIGhlYWRfZW50aXRpZXMgKE9wdGlvbmFsW0xpc3RbSVNPQ29kZV1dKTogQXQgbGVhc3Qgb25lIG9mIHRoZSBlbnRpdGllcyBtdXN0IGJlIG1lbnRpb25lZCBpbiB0aGUgYXJ0aWNsZXMgYW5kIGJlIHRoZSBoZWFkIGVudGl0eSBpbiB0aGUgZXZlbnRzLiBJZiBOb25lLCBhbGwgZW50aXRpZXMgYXJlIGluY2x1ZGVkLgogICAgICAgIHRhaWxfZW50aXRpZXMgKE9wdGlvbmFsW0xpc3RbSVNPQ29kZV1dKTogQXQgbGVhc3Qgb25lIG9mIHRoZSBlbnRpdGllcyBtdXN0IGJlIG1lbnRpb25lZCBpbiB0aGUgYXJ0aWNsZXMgYW5kIGJlIHRoZSB0YWlsIGVudGl0eSBpbiB0aGUgZXZlbnRzLiBJZiBOb25lLCBhbGwgZW50aXRpZXMgYXJlIGluY2x1ZGVkLgogICAgICAgIHJlbGF0aW9ucyAoT3B0aW9uYWxbTGlzdFtDQU1FT0NvZGVdXSk6IEF0IGxlYXN0IG9uZSBvZiB0aGUgcmVsYXRpb25zIG11c3QgYmUgbWVudGlvbmVkIGluIHRoZSBhcnRpY2xlcy4gSWYgZmlyc3QgbGV2ZWwgcmVsYXRpb25zIGFyZSBsaXN0ZWQsIGFsbCBzZWNvbmQgbGV2ZWwgcmVsYXRpb25zIHVuZGVyIHRoZW0gYXJlIGluY2x1ZGVkLiBJZiBOb25lLCBhbGwgcmVsYXRpb25zIGFyZSBpbmNsdWRlZC4KICAgICAgICBrZXl3b3JkcyAoT3B0aW9uYWxbTGlzdFtzdHJdXSk6IEF0IGxlYXN0IG9uZSBvZiB0aGUga2V5d29yZHMgbXVzdCBiZSBwcmVzZW50IGluIHRoZSBhcnRpY2xlcy4gSWYgTm9uZSwgYWxsIGFydGljbGVzIGFyZSBpbmNsdWRlZC4KCiAgICBSZXR1cm5zOgogICAgICAgIGludDogVGhlIGNvdW50IG9mIG5ld3MgYXJ0aWNsZXMgbWF0Y2hpbmcgdGhlIGNvbmRpdGlvbnMuCgogICAgRXhhbXBsZToKICAgICAgICA+Pj4gY291bnRfbmV3c19hcnRpY2xlcyhkYXRlX3JhbmdlPURhdGVSYW5nZShzdGFydF9kYXRlPURhdGUoIjIwMjItMDEtMDEiKSwgZW5kX2RhdGU9RGF0ZSgiMjAyMi0wMS0zMSIpKSwgaGVhZF9lbnRpdGllcz1bSVNPQ29kZSgiVVNBIiksIElTT0NvZGUoIkNITiIpXSwgdGFpbF9lbnRpdGllcz1bSVNPQ29kZSgiVVNBIiksIElTT0NvZGUoIkNITiIpXSwgcmVsYXRpb25zPVtDQU1FT0NvZGUoIjAxMCIpXSwga2V5d29yZHM9WyJ0cmFkZSJdKQogICAgICAgIDIKICAgICIiIgogICAgcGFzcwoKZGVmIGdldF9uZXdzX2FydGljbGVzKGRhdGVfcmFuZ2U6IE9wdGlvbmFsW0RhdGVSYW5nZV0gPSBOb25lLCBoZWFkX2VudGl0aWVzOiBPcHRpb25hbFtMaXN0W0lTT0NvZGVdXSA9IE5vbmUsIHRhaWxfZW50aXRpZXM6IE9wdGlvbmFsW0xpc3RbSVNPQ29kZV1dID0gTm9uZSwgcmVsYXRpb25zOiBPcHRpb25hbFtMaXN0W0NBTUVPQ29kZV1dID0gTm9uZSwga2V5d29yZHM6IE9wdGlvbmFsW0xpc3Rbc3RyXV0gPSBOb25lLCB0ZXh0X2Rlc2NyaXB0aW9uOiBPcHRpb25hbFtzdHJdID0gTm9uZSkgLT4gTGlzdFtUdXBsZVtEYXRlLCBzdHJdXToKICAgICIiIgogICAgUmV0cmlldmVzIG5ld3MgYXJ0aWNsZXMgYmFzZWQgb24gc3BlY2lmaWVkIGNvbmRpdGlvbnMuCiAgICBJbmhlcml0cyBjb21tb24gZmlsdGVyIHBhcmFtZXRlcnMgZnJvbSBjb3VudF9uZXdzX2FydGljbGVzLiBTZWUgY291bnRfbmV3c19hcnRpY2xlcyBmb3IgbW9yZSBkZXRhaWxzIG9uIHRoZXNlIHBhcmFtZXRlcnMuCgogICAgQWRkaXRpb25hbCBQYXJhbWV0ZXJzOgogICAgICAgIHRleHRfZGVzY3JpcHRpb24gKE9wdGlvbmFsW3N0cl0pOiBUZXh0dWFsIGRlc2NyaXB0aW9uIHRvIG1hdGNoIHdpdGggdGhlIG5ld3MgYXJ0aWNsZXMuIElmIE5vbmUsIHRoZSByZXR1cm5lZCBhcnRpY2xlcyBhcmUgc29ydGVkIGJ5IGRhdGUgaW4gZGVzY2VuZGluZyBvcmRlcjsgb3RoZXJ3aXNlLCBzb3J0ZWQgYnkgcmVsZXZhbmNlIHRvIHRoZSBkZXNjcmlwdGlvbi4KCiAgICBSZXR1cm5zOgogICAgICAgIExpc3RbVHVwbGVbRGF0ZSwgc3RyXV06IEEgbGlzdCBvZiBtYXhpbXVtIDE1IG5ld3MgYXJ0aWNsZXMgbWF0Y2hpbmcgdGhlIHNwZWNpZmllZCBjb25kaXRpb25zLCBlYWNoIHJlcHJlc2VudGVkIGJ5IGEgdHVwbGUgb2YgZGF0ZSBhbmQgdGl0bGUuCgogICAgRXhhbXBsZToKICAgICAgICA+Pj4gZ2V0X25ld3NfYXJ0aWNsZXMoZGF0ZV9yYW5nZT1EYXRlUmFuZ2Uoc3RhcnRfZGF0ZT1EYXRlKCIyMDIyLTAxLTAxIiksIGVuZF9kYXRlPURhdGUoIjIwMjItMDEtMzEiKSksIGhlYWRfZW50aXRpZXM9W0lTT0NvZGUoIlVTQSIpLCBJU09Db2RlKCJDSE4iKV0sIHRhaWxfZW50aXRpZXM9W0lTT0NvZGUoIlVTQSIpLCBJU09Db2RlKCJDSE4iKV0sIHJlbGF0aW9ucz1bQ0FNRU9Db2RlKCIwMTAiKV0sIGtleXdvcmRzPVsidHJhZGUiXSwgdGV4dF9kZXNjcmlwdGlvbj0iRWNvbm9taWMgdHJhZGUgaXMgZW5jb3VyYWdlZCBiZXR3ZWVuIFVTQSBhbmQgQ2hpbmEuIikKICAgICAgICBbKE5ld3NBcnRpY2xlLmRhdGU9RGF0ZSgiMjAyMi0wMS0xNSIpLCBOZXdzQXJ0aWNsZS50aXRsZT0iQ2hpbmEgYW5kIFVTQSBzaWduIHRyYWRlIGRlYWwiKSwgKE5ld3NBcnRpY2xlLmRhdGU9RGF0ZSgiMjAyMi0wMS0xMCIpLCBOZXdzQXJ0aWNsZS50aXRsZT0iVHJhZGUgYWdyZWVtZW50IGJldHdlZW4gVVNBIGFuZCBDaGluYSIpXQogICAgIiIiCiAgICBwYXNzCgpkZWYgYnJvd3NlX25ld3NfYXJ0aWNsZShkYXRlOiBEYXRlLCB0aXRsZTogc3RyKSAtPiBzdHI6CiAgICAiIiIKICAgIFJldHJpZXZlcyB0aGUgZnVsbCB0ZXh0IG9mIGEgbmV3cyBhcnRpY2xlIGJ5IGl0cyB0aXRsZS4KCiAgICBQYXJhbWV0ZXJzOgogICAgICAgIGRhdGUgKERhdGUpOiBUaGUgZGF0ZSBvZiB0aGUgbmV3cyBhcnRpY2xlIHRvIHJldHJpZXZlLgogICAgICAgIHRpdGxlIChzdHIpOiBUaGUgdGl0bGUgb2YgdGhlIG5ld3MgYXJ0aWNsZSB0byByZXRyaWV2ZS4KCiAgICBSZXR1cm5zOgogICAgICAgIHN0cjogVGhlIGRhdGUsIHRoZSB0aXRsZSBhbmQgZnVsbCBjb250ZW50cyBvZiB0aGUgbmV3cyBhcnRpY2xlLgoKICAgIEV4YW1wbGU6CiAgICAgICAgPj4+IGJyb3dzZV9uZXdzX2FydGljbGUoRGF0ZSgiMjAyMi0wMS0xMCIpLCAiVHJhZGUgYWdyZWVtZW50IGJldHdlZW4gVVNBIGFuZCBDaGluYSIpCiAgICAgICAgMjAyMi0wMS0xMDoKICAgICAgICBUcmFkZSBhZ3JlZW1lbnQgYmV0d2VlbiBVU0EgYW5kIENoaW5hCiAgICAgICAgT24gSmFudWFyeSAxMCwgMjAyMiwgYSB0cmFkZSBhZ3JlZW1lbnQgd2FzIHNpZ25lZCBiZXR3ZWVuIHRoZSBVU0EgYW5kIENoaW5hIHRvIHByb21vdGUgZWNvbm9taWMgY29vcGVyYXRpb24uLi4KICAgICIiIgogICAgcGFzcw==)1@dataclass2class  Date:3  """Represents  a  date."""4  date:  str  #  Date  in  the  format  ’YYYY-MM-DD’5  #  Example:  Date("2022-01-01")67@dataclass8class  DateRange:9  """Represents  a  range  of  dates  (inclusive)."""10  start_date:  Optional[Date]  #  If  None,  the  earliest  date  is  used11  end_date:  Optional[Date]  #  If  None,  the  current  date  is  used12  #  Example:  DateRange(start_date=Date("2022-01-01"),  end_date=Date("2022-01-31"))1314@dataclass15class  ISOCode:16  """Represents  an  ISO  alpha-3  country  code."""17  code:  str  #  3-letter  ISO  code18  #  Example:  ISOCode("USA")1920@dataclass21class  Country:22  """Represents  a  country  entity."""23  iso_code:  ISOCode24  name:  str25  #  Example:  Country(iso_code=ISOCode("USA"),  name="United  States")2627@dataclass28class  CAMEOCode:29  """Represents  a  CAMEO  verb  code."""30  code:  str  #  2-digit  CAMEO  code  for  first  level  relations,  3-digit  CAMEO  code  for  second  level  relations31  #  Example:  CAMEOCode("01"),  CAMEOCode("010")3233@dataclass34class  Relation:35  """Represents  a  relation."""36  cameo_code:  CAMEOCode37  name:  str38  description:  str  #  A  brief  description  of  what  event  the  relation  represents39  #  Example:  Relation(cameo_code=CAMEOCode("010"),  name="Make  statement,  not  specified",  description="All  public  statements  expressed  verbally  or  in  action,  not  otherwise  specified."4041@dataclass42class  Event:43  """Represents  an  event  characterized  by  date,  head  entity,  relation,  and  tail  entity."""44  date:  Date45  head_entity:  ISOCode46  relation:  CAMEOCode47  tail_entity:  ISOCode48  #  Example:  Event(date=Date("2022-01-01"),  head_entity=ISOCode("USA"),  relation=CAMEOCode("010"),  tail_entity=ISOCode("CAN"))4950@dataclass51class  NewsArticle:52  """Represents  a  news  article,  including  metadata  and  content."""53  date:  Date54  title:  str55  content:  str  #  Full  text  content  of  the  news  article56  events:  List[Event]  #  List  of  events  mentioned  in  the  article57  #  Example:  NewsArticle(date=Date("2022-01-01"),  title="Trade  agreement  between  USA  and  China",  content="On  January  1,  2022,  a  trade  agreement  was  signed  between  the  USA  and  China...",  events=[Event(date=Date("2022-01-01"),  head_entity=ISOCode("USA"),  relation=CAMEOCode("010"),  tail_entity=ISOCode("CHN")])5859  def  __str__(self):60  return  f"{self.date}:\n{self.title}\n{self.content}"6162def  map_country_name_to_iso(name:  str)  ->  List[Country]:63  """64  Maps  a  country  name  to  the  most  likely  corresponding  Country  objects  with  ISO  codes.6566  Parameters:67  name  (str):  The  country  name  to  map.6869  Returns:70  List[Country]:  A  list  of  5  most  likely  Country  objects  sorted  by  relevance.7172  Example:73  >>>  map_country_name_to_iso("Korea")74  [Country(iso_code=ISOCode("KOR"),  name="Republic  of  Korea"),  Country(iso_code=ISOCode("PRK"),  name="Democratic  People’s  Republic  of  Korea")]75  """76  pass7778def  map_iso_to_country_name(iso_code:  ISOCode)  ->  str:79  """80  Maps  an  ISO  code  to  a  country  name.8182  Parameters:83  iso_code  (ISOCode):  The  ISO  code  to  map.8485  Returns:86  str:  The  corresponding  country  name.8788  Example:89  >>>  map_iso_to_country_name(ISOCode("CHN"))90  "China"91  """92  pass9394def  map_relation_description_to_cameo(description:  str)  ->  List[Relation]:95  """96  Maps  a  relation  description  to  the  most  likely  Relation  objects.9798  Parameters:99  description  (str):  The  relation  description  to  map.100101  Returns:102  List[Relation]:  A  list  of  5  most  likely  Relations  sorted  by  relevance.103104  Example:105  >>>  map_relation_description_to_cameo("Fight  with  guns")106  [Reltion(cameo_code=CAMEOCode("19"),  name="Fight",  description="All  uses  of  conventional  force  and  acts  of  war  typically  by  organized  armed  groups."),  Relation(cameo_code=CAMEOCode("193"),  name="Fight  with  small  arms  and  light  weapons",  description="Attack  using  small  arms  and  light  weapons  such  as  rifles,  machine-guns,  and  mortar  shells."),  Relation(cameo_code=CAMEOCode("190"),  name="Use  conventional  military  force,  not  specified",  description="All  uses  of  conventional  force  and  acts  of  war  typically  by  organized  armed  groups,  not  otherwise  specified.")]107  """108  pass109110def  map_cameo_to_relation(cameo_code:  CAMEOCode)  ->  Relation:111  """112  Maps  a  CAMEO  code  to  a  relation,  including  its  name  and  description.113114  Parameters:115  cameo_code  (CAMEOCode):  The  CAMEO  code  to  map.116117  Returns:118  Relation:  The  corresponding  relation.119120  Example:121  >>>  map_cameo_to_relation(CAMEOCode("190"))122  Relation(cameo_code=CAMEOCode("190"),  name="Use  conventional  military  force,  not  specified",  description="All  uses  of  conventional  force  and  acts  of  war  typically  by  organized  armed  groups,  not  otherwise  specified.")123  """124  pass125126def  get_child_relations(cameo_code:  CAMEOCode)  ->  List[Relation]:127  """128  Retrieves  child  relations  of  a  given  relation  identified  by  CAMEO  code.129130  Parameters:131  cameo_code  (CAMEOCode):  The  CAMEO  code  of  the  relation  whose  children  are  sought.  Only  first  level  relations  are  accepted.132133  Returns:134  List[Relation]:  A  list  of  second  level  child  relations.135136  Example:137  >>>  get_child_relations(CAMEOCode("19"))138  [Relation(caemo_code=CAMEOCode("190"),  name="Use  conventional  military  force,  not  specified",  description="All  uses  of  conventional  force  and  acts  of  war  typically  by  organized  armed  groups,  not  otherwise  specified."),  Relation(cameo_code=CAMEOCode("191"),  name="Impose  blockade  or  restrict  movement",  description="Prevent  entry  into  and/or  exit  from  a  territory  using  armed  forces."),  ...]139  """140  pass141142def  get_sibling_relations(cameo_code:  CAMEOCode)  ->  List[Relation]:143  """144  Retrieves  sibling  relations  of  a  given  relation  identified  by  CAMEO  code.145146  Parameters:147  cameo_code  (CAMEOCode):  The  CAMEO  code  of  the  relation  whose  siblings  are  sought.  Both  first  and  second  level  relations  are  accepted.148149  Returns:150  List[Relation]:  A  list  of  sibling  relations  at  the  same  level.151152  Example:153  >>>  get_sibling_relations(CAMEOCode("193"))154  [Relation(caemo_code=CAMEOCode("190"),  name="Use  conventional  military  force,  not  specified",  description="All  uses  of  conventional  force  and  acts  of  war  typically  by  organized  armed  groups,  not  otherwise  specified."),  Relation(cameo_code=CAMEOCode("191"),  name="Impose  blockade  or  restrict  movement",  description="Prevent  entry  into  and/or  exit  from  a  territory  using  armed  forces."),  ...]155  """156  pass157158def  count_events(date_range:  Optional[DateRange]  =  None,  head_entities:  Optional[List[ISOCode]]  =  None,  tail_entities:  Optional[List[ISOCode]]  =  None,  relations:  Optional[List[CAMEOCode]]  =  None)  ->  int:159  """160  Counts  the  number  of  events  in  the  knowledge  graph  based  on  specified  conditions.161162  Parameters:163  date_range  (Optional[DateRange]):  Range  of  dates  to  filter  the  events.  If  None,  all  dates  are  included.164  head_entities  (Optional[List[ISOCode]]):  List  of  head  entity  ISO  codes  to  be  included.  If  None,  all  countries  are  included.165  tail_entities  (Optional[List[ISOCode]]):  List  of  tail  entity  ISO  codes  to  be  included.  If  None,  all  countries  are  included.166  relations  (Optional[List[CAMEOCode]]):  List  of  relation  CAMEO  codes  to  be  included.  If  first  level  relations  are  listed,  all  second  level  relations  under  them  are  included.  If  None,  all  relations  are  included.167168  Returns:169  int:  Count  of  unique  events  matching  the  conditions.170171  Example:172  >>>  count_events(date_range=DateRange(start_date=Date("2022-01-01"),  end_date=Date("2022-01-31")),  head_entities=[ISOCode("USA"),  ISOCode("CHN")],  tail_entities=None,  relations=[CAMEOCode("010")])173  4174  """175  pass176177def  get_events(date_range:  Optional[DateRange]  =  None,  head_entities:  Optional[List[ISOCode]]  =  None,  tail_entities:  Optional[List[ISOCode]]  =  None,  relations:  Optional[List[CAMEOCode]]  =  None,  text_description:  Optional[str]  =  None)  ->  List[Event]:178  """179  Retrieves  events  from  the  knowledge  graph  based  on  specified  conditions.180  Inherits  common  filter  parameters  from  count_events.  See  count_events  for  more  details  on  these  parameters.181182  Additional  Parameters:183  text_description  (Optional[str]):  Textual  description  to  match  with  the  source  news  articles  of  events.  If  None,  the  returned  events  are  sorted  by  date  in  descending  order;  otherwise,  sorted  by  relevance  of  the  source  news  article  to  the  description.184185  Returns:186  List[Event]:  A  list  of  maximum  30  events  matching  the  specified  conditions.187188  Example:189  >>>  get_events(date_range=DateRange(start_date=Date("2022-01-01"),  end_date=Date("2022-01-31")),  head_entities=[ISOCode("USA"),  ISOCode("CHN")],  tail_entities=None,  relations=[CAMEOCode("010")],  text_description="economic  trade")190  [Event(date=Date("2022-01-15"),  head_entity=ISOCode("USA"),  relation=CAMEOCode("010"),  tail_entity=ISOCode("CAN"),  Event(date=Date("2022-01-10"),  head_entity=ISOCode("CHN"),  relation=CAMEOCode("010"),  tail_entity=ISOCode("USA"),  ...]191  """192  pass193194def  get_entity_distribution(date_range:  Optional[DateRange]  =  None,  involved_relations:  Optional[List[CAMEOCode]]  =  None,  interacted_entities:  Optional[List[ISOCode]]  =  None,  entity_role:  Optional[str]  =  None)  ->  Dict[ISOCode,  int]:195  """196  Gets  the  distribution  of  entities  in  the  knowledge  graph  under  specified  conditions.197198  Parameters:199  date_range  (Optional[DateRange]):  Range  of  dates  to  filter  the  events.  If  None,  all  dates  are  included.200  involved_relations  (Optional[List[CAMEOCode]]):  List  of  relations  that  the  returned  entities  must  be  involved  in  any  of.  If  first  level  relations  are  listed,  all  second  level  relations  under  them  are  included.  If  None,  all  relations  are  included.201  interacted_entities  (Optional[List[ISOCode]]):  List  of  entities  that  the  returned  entities  must  have  interacted  with  any  of.  If  None,  all  entities  are  included.202  entity_role  (Optional[EntityRole]):  Specifies  the  role  of  the  returned  entity  in  the  events.  Options  are  ’head’,  ’tail’,  or  ’both’.  If  ’both’  or  None,  the  returned  entity  can  be  either  head  or  tail.203204  Returns:205  Dict[ISOCode,  int]:  A  dictionary  mapping  returned  entities’  ISO  codes  to  the  number  of  events  with  the  specified  conditions  in  which  they  are  involved,  sorted  by  counts  in  descending  order.206207  Example:208  >>>  get_entity_distribution(date_range=DateRange(start_date=Date("2022-01-01"),  end_date=Date("2022-01-31")),  involved_relations=[CAMEOCode("010")],  interacted_entities=[ISOCode("USA"),  ISOCode("CHN")],  entity_role="tail")209  {ISOCode("USA"):  3,  ISOCode("CHN"):  1}210  """211  pass212213def  get_relation_distribution(date_range:  Optional[DateRange]  =  None,  head_entities:  Optional[List[ISOCode]]  =  None,  tail_entities:  Optional[List[ISOCode]]  =  None)  ->  Dict[CAMEOCode,  int]:214  """215  Gets  the  distribution  of  second  level  relations  in  the  knowledge  graph  under  specified  conditions.216217  Parameters:218  date_range  (Optional[DateRange]):  Range  of  dates  to  filter  the  events.  If  None,  all  dates  are  included.219  head_entities  (Optional[List[ISOCode]]):  List  of  head  entities  that  the  events  must  involve  any  of.  If  None,  all  head  entities  are  included.220  tail_entities  (Optional[List[ISOCode]]):  List  of  tail  entities  that  the  events  must  involve  any  of.  If  None,  all  tail  entities  are  included.221222  Returns:223  Dict[CAMEOCode,  int]:  A  dictionary  mapping  second  level  relations’  CAMEO  codes  to  the  number  of  events  with  the  specified  conditions  in  which  they  are  involved,  sorted  by  counts  in  descending  order.224225  Example:226  >>>  get_relation_distribution(date_range=DateRange(start_date=Date("2022-01-01"),  end_date=Date("2022-01-31")),  head_entities=[ISOCode("USA"),  ISOCode("CHN")],  tail_entities=None)227  {CAMEOCode("010"):  3,  CAMEOCode("011"):  1}228  """229  pass230231def  count_news_articles(date_range:  Optional[DateRange]  =  None,  head_entities:  Optional[List[ISOCode]]  =  None,  tail_entities:  Optional[List[ISOCode]]  =  None,  relations:  Optional[List[CAMEOCode]]  =  None,  keywords:  Optional[List[str]]  =  None)  ->  int:232  """233  Counts  the  number  of  news  articles  based  on  specified  conditions.234235  Parameters:236  date_range  (Optional[DateRange]):  Range  of  dates  to  filter  the  news  articles.  If  None,  all  dates  are  included.237  head_entities  (Optional[List[ISOCode]]):  At  least  one  of  the  entities  must  be  mentioned  in  the  articles  and  be  the  head  entity  in  the  events.  If  None,  all  entities  are  included.238  tail_entities  (Optional[List[ISOCode]]):  At  least  one  of  the  entities  must  be  mentioned  in  the  articles  and  be  the  tail  entity  in  the  events.  If  None,  all  entities  are  included.239  relations  (Optional[List[CAMEOCode]]):  At  least  one  of  the  relations  must  be  mentioned  in  the  articles.  If  first  level  relations  are  listed,  all  second  level  relations  under  them  are  included.  If  None,  all  relations  are  included.240  keywords  (Optional[List[str]]):  At  least  one  of  the  keywords  must  be  present  in  the  articles.  If  None,  all  articles  are  included.241242  Returns:243  int:  The  count  of  news  articles  matching  the  conditions.244245  Example:246  >>>  count_news_articles(date_range=DateRange(start_date=Date("2022-01-01"),  end_date=Date("2022-01-31")),  head_entities=[ISOCode("USA"),  ISOCode("CHN")],  tail_entities=[ISOCode("USA"),  ISOCode("CHN")],  relations=[CAMEOCode("010")],  keywords=["trade"])247  2248  """249  pass250251def  get_news_articles(date_range:  Optional[DateRange]  =  None,  head_entities:  Optional[List[ISOCode]]  =  None,  tail_entities:  Optional[List[ISOCode]]  =  None,  relations:  Optional[List[CAMEOCode]]  =  None,  keywords:  Optional[List[str]]  =  None,  text_description:  Optional[str]  =  None)  ->  List[Tuple[Date,  str]]:252  """253  Retrieves  news  articles  based  on  specified  conditions.254  Inherits  common  filter  parameters  from  count_news_articles.  See  count_news_articles  for  more  details  on  these  parameters.255256  Additional  Parameters:257  text_description  (Optional[str]):  Textual  description  to  match  with  the  news  articles.  If  None,  the  returned  articles  are  sorted  by  date  in  descending  order;  otherwise,  sorted  by  relevance  to  the  description.258259  Returns:260  List[Tuple[Date,  str]]:  A  list  of  maximum  15  news  articles  matching  the  specified  conditions,  each  represented  by  a  tuple  of  date  and  title.261262  Example:263  >>>  get_news_articles(date_range=DateRange(start_date=Date("2022-01-01"),  end_date=Date("2022-01-31")),  head_entities=[ISOCode("USA"),  ISOCode("CHN")],  tail_entities=[ISOCode("USA"),  ISOCode("CHN")],  relations=[CAMEOCode("010")],  keywords=["trade"],  text_description="Economic  trade  is  encouraged  between  USA  and  China.")264  [(NewsArticle.date=Date("2022-01-15"),  NewsArticle.title="China  and  USA  sign  trade  deal"),  (NewsArticle.date=Date("2022-01-10"),  NewsArticle.title="Trade  agreement  between  USA  and  China")]265  """266  pass267268def  browse_news_article(date:  Date,  title:  str)  ->  str:269  """270  Retrieves  the  full  text  of  a  news  article  by  its  title.271272  Parameters:273  date  (Date):  The  date  of  the  news  article  to  retrieve.274  title  (str):  The  title  of  the  news  article  to  retrieve.275276  Returns:277  str:  The  date,  the  title  and  full  contents  of  the  news  article.278279  Example:280  >>>  browse_news_article(Date("2022-01-10"),  "Trade  agreement  between  USA  and  China")281  2022-01-10:282  Trade  agreement  between  USA  and  China283  On  January  10,  2022,  a  trade  agreement  was  signed  between  the  USA  and  China  to  promote  economic  cooperation...284  """285  pass’'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: M.3 API Implementation
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we provide the full implementation of the API, which is part
    of the environment and is accessible to the Python executor.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[⬇](data:text/plain;base64,QGRhdGFjbGFzcwpjbGFzcyBEYXRlOgogICAgIiIiUmVwcmVzZW50cyBhIGRhdGUuIiIiCiAgICBkYXRlOiBzdHIgIyBEYXRlIGluIHRoZSBmb3JtYXQgJ1lZWVktTU0tREQnCiAgICAjIEV4YW1wbGU6IERhdGUoIjIwMjItMDEtMDEiKQoKICAgIGRlZiBfX2luaXRfXyhzZWxmLCBkYXRlOiBzdHIpOgogICAgICAgICMgY2hlY2sgdHlwZQogICAgICAgIGlmIG5vdCBpc2luc3RhbmNlKGRhdGUsIHN0cik6CiAgICAgICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoZiJBdHRyaWJ1dGUgJ2RhdGUnIG9mIGNsYXNzIERhdGUgbXVzdCBiZSBhIHN0cmluZyBpbiB0aGUgZm9ybWF0ICdZWVlZLU1NLUREJywgYnV0IHJlY2VpdmVkOiB7ZGF0ZX0gaW4gdHlwZSB7dHlwZShkYXRlKX0iKQoKICAgICAgICAjIGNoZWNrIGlmIGRhdGUgaXMgaW4gdGhlIGNvcnJlY3QgZm9ybWF0IGJ5IHRyeWluZyB0byBjb252ZXJ0IGl0IHRvIGEgZGF0ZSBvYmplY3QKICAgICAgICB0cnk6CiAgICAgICAgICAgIGRhdGV0aW1lLmRhdGV0aW1lLnN0cnB0aW1lKGRhdGUsICclWS0lbS0lZCcpCiAgICAgICAgZXhjZXB0IFZhbHVlRXJyb3I6CiAgICAgICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoZiJEYXRlIG11c3QgYmUgaW4gdGhlIGZvcm1hdCAnWVlZWS1NTS1ERCcsIGJ1dCByZWNlaXZlZDoge2RhdGV9IikKICAgICAgICBpZiBkYXRlIDwgREVGQVVMVF9TVEFSVF9EQVRFOgogICAgICAgICAgICByYWlzZSBWYWx1ZUVycm9yKGYiRGF0ZSBtdXN0IGJlIG9uIG9yIGFmdGVyIHtERUZBVUxUX1NUQVJUX0RBVEV9LCBidXQgcmVjZWl2ZWQ6IHtkYXRlfSIpCiAgICAgICAgaWYgREVGQVVMVF9FTkRfREFURSBhbmQgZGF0ZSA+IERFRkFVTFRfRU5EX0RBVEU6CiAgICAgICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoZiJEYXRlIG11c3QgYmUgb24gb3IgYmVmb3JlIHRoZSBjdXJyZW50IGRhdGUge0RFRkFVTFRfRU5EX0RBVEV9LCBidXQgcmVjZWl2ZWQ6IHtkYXRlfSIpCgogICAgICAgIHNlbGYuZGF0ZSA9IGRhdGUKCiAgICBkZWYgX19zdHJfXyhzZWxmKToKICAgICAgICByZXR1cm4gZiJEYXRlKCd7c2VsZi5kYXRlfScpIgoKICAgIGRlZiBfX2hhc2hfXyhzZWxmKToKICAgICAgICByZXR1cm4gaGFzaChzZWxmLmRhdGUpCgogICAgZGVmIF9fZXFfXyhzZWxmLCBvdGhlcik6CiAgICAgICAgaWYgaXNpbnN0YW5jZShvdGhlciwgRGF0ZSk6CiAgICAgICAgICAgIHJldHVybiBzZWxmLmRhdGUgPT0gb3RoZXIuZGF0ZQogICAgICAgIHJldHVybiBGYWxzZQoKQGRhdGFjbGFzcwpjbGFzcyBEYXRlUmFuZ2U6CiAgICAiIiJSZXByZXNlbnRzIGEgcmFuZ2Ugb2YgZGF0ZXMgKGluY2x1c2l2ZSkuIiIiCiAgICBzdGFydF9kYXRlOiBPcHRpb25hbFtEYXRlXSAjIElmIE5vbmUsIHRoZSBlYXJsaWVzdCBkYXRlIGlzIHVzZWQKICAgIGVuZF9kYXRlOiBPcHRpb25hbFtEYXRlXSAjIElmIE5vbmUsIHRoZSBjdXJyZW50IGRhdGUgaXMgdXNlZAogICAgIyBFeGFtcGxlOiBEYXRlUmFuZ2Uoc3RhcnRfZGF0ZT1EYXRlKCIyMDIyLTAxLTAxIiksIGVuZF9kYXRlPURhdGUoIjIwMjItMDEtMzEiKSkKCiAgICBkZWYgX19pbml0X18oc2VsZiwgc3RhcnRfZGF0ZTogT3B0aW9uYWxbRGF0ZV0gPSBOb25lLCBlbmRfZGF0ZTogT3B0aW9uYWxbRGF0ZV0gPSBOb25lKToKICAgICAgICAjIGNoZWNrIHR5cGUKICAgICAgICBpZiBzdGFydF9kYXRlIGFuZCBub3QgaXNpbnN0YW5jZShzdGFydF9kYXRlLCBEYXRlKToKICAgICAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmIkF0dHJpYnV0ZSAnc3RhcnRfZGF0ZScgb2YgY2xhc3MgRGF0ZVJhbmdlIG11c3QgYmUgYSBEYXRlIG9iamVjdCwgYnV0IHJlY2VpdmVkIHR5cGUge3R5cGUoc3RhcnRfZGF0ZSl9IikKICAgICAgICBpZiBlbmRfZGF0ZSBhbmQgbm90IGlzaW5zdGFuY2UoZW5kX2RhdGUsIERhdGUpOgogICAgICAgICAgICByYWlzZSBWYWx1ZUVycm9yKGYiQXR0cmlidXRlICdlbmRfZGF0ZScgb2YgY2xhc3MgRGF0ZVJhbmdlIG11c3QgYmUgYSBEYXRlIG9iamVjdCwgYnV0IHJlY2VpdmVkIHR5cGUge3R5cGUoZW5kX2RhdGUpfSIpCgogICAgICAgIHNlbGYuc3RhcnRfZGF0ZSA9IHN0YXJ0X2RhdGUgaWYgc3RhcnRfZGF0ZSBlbHNlIERhdGUoREVGQVVMVF9TVEFSVF9EQVRFKQogICAgICAgIHNlbGYuZW5kX2RhdGUgPSBlbmRfZGF0ZSBpZiBlbmRfZGF0ZSBlbHNlIERhdGUoREVGQVVMVF9FTkRfREFURSkKICAgICAgICBpZiBzdGFydF9kYXRlIGFuZCBlbmRfZGF0ZSBhbmQgc3RhcnRfZGF0ZS5kYXRlID4gZW5kX2RhdGUuZGF0ZToKICAgICAgICAgICAgcmFpc2UgVmFsdWVFcnJvcigiU3RhcnQgZGF0ZSBtdXN0IGJlIGJlZm9yZSBvciBlcXVhbCB0byBlbmQgZGF0ZSwgYnV0IHJlY2VpdmVkOiBzdGFydF9kYXRlPXt9LCBlbmRfZGF0ZT17fSIuZm9ybWF0KHN0YXJ0X2RhdGUuZGF0ZSwgZW5kX2RhdGUuZGF0ZSkpCgogICAgZGVmIF9fc3RyX18oc2VsZik6CiAgICAgICAgcmV0dXJuIGYiRGF0ZVJhbmdlKHN0YXJ0X2RhdGU9e3NlbGYuc3RhcnRfZGF0ZX0sIGVuZF9kYXRlPXtzZWxmLmVuZF9kYXRlfSkiCgogICAgZGVmIF9faGFzaF9fKHNlbGYpOgogICAgICAgIHJldHVybiBoYXNoKChzZWxmLnN0YXJ0X2RhdGUsIHNlbGYuZW5kX2RhdGUpKQoKICAgIGRlZiBfX2VxX18oc2VsZiwgb3RoZXIpOgogICAgICAgIGlmIGlzaW5zdGFuY2Uob3RoZXIsIERhdGVSYW5nZSk6CiAgICAgICAgICAgIHJldHVybiBzZWxmLnN0YXJ0X2RhdGUgPT0gb3RoZXIuc3RhcnRfZGF0ZSBhbmQgc2VsZi5lbmRfZGF0ZSA9PSBvdGhlci5lbmRfZGF0ZQogICAgICAgIHJldHVybiBGYWxzZQoKQGRhdGFjbGFzcwpjbGFzcyBJU09Db2RlOgogICAgIiIiUmVwcmVzZW50cyBhbiBJU08gYWxwaGEtMyBjb3VudHJ5IGNvZGUuIiIiCiAgICBjb2RlOiBzdHIgIyAzLWxldHRlciBJU08gY29kZQogICAgIyBFeGFtcGxlOiBJU09Db2RlKCJVU0EiKQoKICAgIGRlZiBfX2luaXRfXyhzZWxmLCBjb2RlOiBzdHIpOgogICAgICAgICMgY2hlY2sgdHlwZQogICAgICAgIGlmIG5vdCBpc2luc3RhbmNlKGNvZGUsIHN0cik6CiAgICAgICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoZiJBdHRyaWJ1dGUgJ2NvZGUnIG9mIGNsYXNzIElTT0NvZGUgbXVzdCBiZSBhIHN0cmluZywgYnV0IHJlY2VpdmVkIHR5cGUge3R5cGUoY29kZSl9IikKCiAgICAgICAgaWYgbGVuKGNvZGUpICE9IDM6CiAgICAgICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoZiJJU08gY29kZSBtdXN0IGJlIGEgMy1sZXR0ZXIgc3RyaW5nLCBidXQgcmVjZWl2ZWQ6IHtjb2RlfSIpCiAgICAgICAgaWYgY29kZSBub3QgaW4gZGljdF9pc28yYWx0ZXJuYW1lczoKICAgICAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmIklTTyBjb2RlIG11c3QgYmUgYSB2YWxpZCBJU08gYWxwaGEtMyBjb3VudHJ5IGNvZGUsIGJ1dCByZWNlaXZlZDoge2NvZGV9IikKICAgICAgICBzZWxmLmNvZGUgPSBjb2RlCgogICAgZGVmIF9fc3RyX18oc2VsZik6CiAgICAgICAgcmV0dXJuIGYiSVNPQ29kZSgne3NlbGYuY29kZX0nKSIKCiAgICBkZWYgX19oYXNoX18oc2VsZik6CiAgICAgICAgcmV0dXJuIGhhc2goc2VsZi5jb2RlKQoKICAgIGRlZiBfX2VxX18oc2VsZiwgb3RoZXIpOgogICAgICAgIGlmIGlzaW5zdGFuY2Uob3RoZXIsIElTT0NvZGUpOgogICAgICAgICAgICByZXR1cm4gc2VsZi5jb2RlID09IG90aGVyLmNvZGUKICAgICAgICByZXR1cm4gRmFsc2UKCkBkYXRhY2xhc3MKY2xhc3MgQ291bnRyeToKICAgICIiIlJlcHJlc2VudHMgYSBjb3VudHJ5IGVudGl0eS4iIiIKICAgIGlzb19jb2RlOiBJU09Db2RlCiAgICBuYW1lOiBzdHIKICAgICMgRXhhbXBsZTogQ291bnRyeShpc29fY29kZT1JU09Db2RlKCJVU0EiKSwgbmFtZT0iVW5pdGVkIFN0YXRlcyIpCgogICAgZGVmIF9faW5pdF9fKHNlbGYsIGlzb19jb2RlOiBJU09Db2RlLCBuYW1lOiBzdHIpOgogICAgICAgICMgY2hlY2sgdHlwZQogICAgICAgIGlmIG5vdCBpc2luc3RhbmNlKGlzb19jb2RlLCBJU09Db2RlKToKICAgICAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmIkF0dHJpYnV0ZSAnaXNvX2NvZGUnIG9mIGNsYXNzIENvdW50cnkgbXVzdCBiZSBhbiBJU09Db2RlIG9iamVjdCwgYnV0IHJlY2VpdmVkIHR5cGUge3R5cGUoaXNvX2NvZGUpfSIpCiAgICAgICAgaWYgbm90IGlzaW5zdGFuY2UobmFtZSwgc3RyKToKICAgICAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmIkF0dHJpYnV0ZSAnbmFtZScgb2YgY2xhc3MgQ291bnRyeSBtdXN0IGJlIGEgc3RyaW5nLCBidXQgcmVjZWl2ZWQgdHlwZSB7dHlwZShuYW1lKX0iKQoKICAgICAgICBpZiBkaWN0X2lzbzJhbHRlcm5hbWVzW2lzb19jb2RlLmNvZGVdWzBdICE9IG5hbWU6CiAgICAgICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoZiJDb3VudHJ5IG5hbWUgbXVzdCBtYXRjaCB0aGUgbmFtZSBjb3JyZXNwb25kaW5nIHRvIHRoZSBJU08gY29kZSwgYnV0IHJlY2VpdmVkOiB7bmFtZX0gZm9yIElTTyBjb2RlOiB7aXNvX2NvZGUuY29kZX0iKQogICAgICAgIHNlbGYuaXNvX2NvZGUgPSBpc29fY29kZQogICAgICAgIHNlbGYubmFtZSA9IG5hbWUKCiAgICBkZWYgX19zdHJfXyhzZWxmKToKICAgICAgICByZXR1cm4gZiJDb3VudHJ5KGlzb19jb2RlPXtzZWxmLmlzb19jb2RlfSwgbmFtZT0ne3NlbGYubmFtZX0nKSIKCiAgICBkZWYgX19oYXNoX18oc2VsZik6CiAgICAgICAgcmV0dXJuIGhhc2goKHNlbGYuaXNvX2NvZGUsIHNlbGYubmFtZSkpCgogICAgZGVmIF9fZXFfXyhzZWxmLCBvdGhlcik6CiAgICAgICAgaWYgaXNpbnN0YW5jZShvdGhlciwgQ291bnRyeSk6CiAgICAgICAgICAgIHJldHVybiBzZWxmLmlzb19jb2RlID09IG90aGVyLmlzb19jb2RlIGFuZCBzZWxmLm5hbWUgPT0gb3RoZXIubmFtZQogICAgICAgIHJldHVybiBGYWxzZQoKQGRhdGFjbGFzcwpjbGFzcyBDQU1FT0NvZGU6CiAgICAiIiJSZXByZXNlbnRzIGEgQ0FNRU8gdmVyYiBjb2RlLiIiIgogICAgY29kZTogc3RyICMgMi1kaWdpdCBDQU1FTyBjb2RlIGZvciBmaXJzdCBsZXZlbCByZWxhdGlvbnMsIDMtZGlnaXQgQ0FNRU8gY29kZSBmb3Igc2Vjb25kIGxldmVsIHJlbGF0aW9ucwogICAgIyBFeGFtcGxlOiBDQU1FT0NvZGUoIjAxIiksIENBTUVPQ29kZSgiMDEwIikKCiAgICBkZWYgX19pbml0X18oc2VsZiwgY29kZTogc3RyKToKICAgICAgICAjIGNoZWNrIHR5cGUKICAgICAgICBpZiBub3QgaXNpbnN0YW5jZShjb2RlLCBzdHIpOgogICAgICAgICAgICByYWlzZSBWYWx1ZUVycm9yKGYiQXR0cmlidXRlICdjb2RlJyBvZiBjbGFzcyBDQU1FT0NvZGUgbXVzdCBiZSBhIHN0cmluZywgYnV0IHJlY2VpdmVkIHR5cGUge3R5cGUoY29kZSl9IikKCiAgICAgICAgaWYgbGVuKGNvZGUpIG5vdCBpbiBbMiwgM106CiAgICAgICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoZiJDQU1FTyBjb2RlIG11c3QgYmUgYSB2YWxpZCAyIG9yIDMtZGlnaXQgc3RyaW5nIGRlZmluZWQgaW4gdGhlICdDb25mbGljdCBhbmQgTWVkaWF0aW9uIEV2ZW50IE9ic2VydmF0aW9ucycgQ29kZWJvb2ssIGJ1dCByZWNlaXZlZDoge2NvZGV9IikKICAgICAgICBpZiBjb2RlIG5vdCBpbiBkaWN0X2NvZGUycmVsYXRpb246CiAgICAgICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoZiJDQU1FTyBjb2RlIG11c3QgYmUgYSB2YWxpZCBDQU1FTyBjb2RlIGRlZmluZWQgaW4gdGhlICdDb25mbGljdCBhbmQgTWVkaWF0aW9uIEV2ZW50IE9ic2VydmF0aW9ucycgQ29kZWJvb2ssIGJ1dCByZWNlaXZlZDoge2NvZGV9IikKICAgICAgICBzZWxmLmNvZGUgPSBjb2RlCgogICAgZGVmIF9fc3RyX18oc2VsZik6CiAgICAgICAgcmV0dXJuIGYiQ0FNRU9Db2RlKCd7c2VsZi5jb2RlfScpIgoKICAgIGRlZiBfX2hhc2hfXyhzZWxmKToKICAgICAgICByZXR1cm4gaGFzaChzZWxmLmNvZGUpCgogICAgZGVmIF9fZXFfXyhzZWxmLCBvdGhlcik6CiAgICAgICAgaWYgaXNpbnN0YW5jZShvdGhlciwgQ0FNRU9Db2RlKToKICAgICAgICAgICAgcmV0dXJuIHNlbGYuY29kZSA9PSBvdGhlci5jb2RlCiAgICAgICAgcmV0dXJuIEZhbHNlCgpAZGF0YWNsYXNzCmNsYXNzIFJlbGF0aW9uOgogICAgIiIiUmVwcmVzZW50cyBhIHJlbGF0aW9uLiIiIgogICAgY2FtZW9fY29kZTogQ0FNRU9Db2RlCiAgICBuYW1lOiBzdHIKICAgIGRlc2NyaXB0aW9uOiBzdHIgIyBBIGJyaWVmIGRlc2NyaXB0aW9uIG9mIHdoYXQgZXZlbnQgdGhlIHJlbGF0aW9uIHJlcHJlc2VudHMKICAgICMgRXhhbXBsZTogUmVsYXRpb24oY2FtZW9fY29kZT1DQU1FT0NvZGUoIjAxMCIpLCBuYW1lPSJNYWtlIHN0YXRlbWVudCwgbm90IHNwZWNpZmllZCIsIGRlc2NyaXB0aW9uPSJBbGwgcHVibGljIHN0YXRlbWVudHMgZXhwcmVzc2VkIHZlcmJhbGx5IG9yIGluIGFjdGlvbiwgbm90IG90aGVyd2lzZSBzcGVjaWZpZWQuIgoKICAgIGRlZiBfX2luaXRfXyhzZWxmLCBjYW1lb19jb2RlOiBDQU1FT0NvZGUsIG5hbWU6IHN0ciwgZGVzY3JpcHRpb246IHN0cik6CiAgICAgICAgIyBjaGVjayB0eXBlCiAgICAgICAgaWYgbm90IGlzaW5zdGFuY2UoY2FtZW9fY29kZSwgQ0FNRU9Db2RlKToKICAgICAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmIkF0dHJpYnV0ZSAnY2FtZW9fY29kZScgb2YgY2xhc3MgUmVsYXRpb24gbXVzdCBiZSBhIENBTUVPQ29kZSBvYmplY3QsIGJ1dCByZWNlaXZlZCB0eXBlIHt0eXBlKGNhbWVvX2NvZGUpfSIpCiAgICAgICAgaWYgbm90IGlzaW5zdGFuY2UobmFtZSwgc3RyKToKICAgICAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmIkF0dHJpYnV0ZSAnbmFtZScgb2YgY2xhc3MgUmVsYXRpb24gbXVzdCBiZSBhIHN0cmluZywgYnV0IHJlY2VpdmVkIHR5cGUge3R5cGUobmFtZSl9IikKICAgICAgICBpZiBub3QgaXNpbnN0YW5jZShkZXNjcmlwdGlvbiwgc3RyKToKICAgICAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmIkF0dHJpYnV0ZSAnZGVzY3JpcHRpb24nIG9mIGNsYXNzIFJlbGF0aW9uIG11c3QgYmUgYSBzdHJpbmcsIGJ1dCByZWNlaXZlZCB0eXBlIHt0eXBlKGRlc2NyaXB0aW9uKX0iKQoKICAgICAgICBpZiBkaWN0X2NvZGUycmVsYXRpb25bY2FtZW9fY29kZS5jb2RlXVsnTmFtZSddICE9IG5hbWU6CiAgICAgICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoZiJSZWxhdGlvbiBuYW1lIG11c3QgbWF0Y2ggdGhlIG5hbWUgY29ycmVzcG9uZGluZyB0byB0aGUgQ0FNRU8gY29kZSwgYnV0IHJlY2VpdmVkOiB7bmFtZX0gZm9yIENBTUVPIGNvZGUge2NhbWVvX2NvZGUuY29kZX0iKQogICAgICAgIGlmIGRpY3RfY29kZTJyZWxhdGlvbltjYW1lb19jb2RlLmNvZGVdWydEZXNjcmlwdGlvbiddICE9IGRlc2NyaXB0aW9uOgogICAgICAgICAgICByYWlzZSBWYWx1ZUVycm9yKGYiUmVsYXRpb24gZGVzY3JpcHRpb24gbXVzdCBtYXRjaCB0aGUgZGVzY3JpcHRpb24gY29ycmVzcG9uZGluZyB0byB0aGUgQ0FNRU8gY29kZSwgYnV0IHJlY2VpdmVkOiB7ZGVzY3JpcHRpb259IGZvciBDQU1FTyBjb2RlIHtjYW1lb19jb2RlLmNvZGV9IikKICAgICAgICBzZWxmLmNhbWVvX2NvZGUgPSBjYW1lb19jb2RlCiAgICAgICAgc2VsZi5uYW1lID0gbmFtZQogICAgICAgIHNlbGYuZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbgoKICAgIGRlZiBfX3N0cl9fKHNlbGYpOgogICAgICAgIHJldHVybiBmIlJlbGF0aW9uKGNhbWVvX2NvZGU9e3NlbGYuY2FtZW9fY29kZX0sIG5hbWU9J3tzZWxmLm5hbWV9JywgZGVzY3JpcHRpb249J3tzZWxmLmRlc2NyaXB0aW9ufScpIgoKICAgIGRlZiBfX2hhc2hfXyhzZWxmKToKICAgICAgICByZXR1cm4gaGFzaCgoc2VsZi5jYW1lb19jb2RlLCBzZWxmLm5hbWUsIHNlbGYuZGVzY3JpcHRpb24pKQoKICAgIGRlZiBfX2VxX18oc2VsZiwgb3RoZXIpOgogICAgICAgIGlmIGlzaW5zdGFuY2Uob3RoZXIsIFJlbGF0aW9uKToKICAgICAgICAgICAgcmV0dXJuIHNlbGYuY2FtZW9fY29kZSA9PSBvdGhlci5jYW1lb19jb2RlIGFuZCBzZWxmLm5hbWUgPT0gb3RoZXIubmFtZSBhbmQgc2VsZi5kZXNjcmlwdGlvbiA9PSBvdGhlci5kZXNjcmlwdGlvbgogICAgICAgIHJldHVybiBGYWxzZQoKQGRhdGFjbGFzcwpjbGFzcyBFdmVudDoKICAgICIiIlJlcHJlc2VudHMgYW4gZXZlbnQgY2hhcmFjdGVyaXplZCBieSBkYXRlLCBoZWFkIGVudGl0eSwgcmVsYXRpb24sIGFuZCB0YWlsIGVudGl0eS4iIiIKICAgIGRhdGU6IERhdGUKICAgIGhlYWRfZW50aXR5OiBJU09Db2RlCiAgICByZWxhdGlvbjogQ0FNRU9Db2RlCiAgICB0YWlsX2VudGl0eTogSVNPQ29kZQogICAgIyBFeGFtcGxlOiBFdmVudChkYXRlPURhdGUoIjIwMjItMDEtMDEiKSwgaGVhZF9lbnRpdHk9SVNPQ29kZSgiVVNBIiksIHJlbGF0aW9uPUNBTUVPQ29kZSgiMDEwIiksIHRhaWxfZW50aXR5PUlTT0NvZGUoIkNBTiIpKQoKICAgIGRlZiBfX2luaXRfXyhzZWxmLCBkYXRlOiBEYXRlLCBoZWFkX2VudGl0eTogSVNPQ29kZSwgcmVsYXRpb246IENBTUVPQ29kZSwgdGFpbF9lbnRpdHk6IElTT0NvZGUpOgogICAgICAgICMgY2hlY2sgdHlwZQogICAgICAgIGlmIG5vdCBpc2luc3RhbmNlKGRhdGUsIERhdGUpOgogICAgICAgICAgICByYWlzZSBWYWx1ZUVycm9yKGYiQXR0cmlidXRlICdkYXRlJyBvZiBjbGFzcyBFdmVudCBtdXN0IGJlIGEgRGF0ZSBvYmplY3QsIGJ1dCByZWNlaXZlZCB0eXBlIHt0eXBlKGRhdGUpfSIpCiAgICAgICAgaWYgbm90IGlzaW5zdGFuY2UoaGVhZF9lbnRpdHksIElTT0NvZGUpOgogICAgICAgICAgICByYWlzZSBWYWx1ZUVycm9yKGYiQXR0cmlidXRlICdoZWFkX2VudGl0eScgb2YgY2xhc3MgRXZlbnQgbXVzdCBiZSBhbiBJU09Db2RlIG9iamVjdCwgYnV0IHJlY2VpdmVkIHR5cGUge3R5cGUoaGVhZF9lbnRpdHkpfSIpCiAgICAgICAgaWYgbm90IGlzaW5zdGFuY2UocmVsYXRpb24sIENBTUVPQ29kZSk6CiAgICAgICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoZiJBdHRyaWJ1dGUgJ3JlbGF0aW9uJyBvZiBjbGFzcyBFdmVudCBtdXN0IGJlIGEgQ0FNRU9Db2RlIG9iamVjdCwgYnV0IHJlY2VpdmVkIHR5cGUge3R5cGUocmVsYXRpb24pfSIpCiAgICAgICAgaWYgbm90IGlzaW5zdGFuY2UodGFpbF9lbnRpdHksIElTT0NvZGUpOgogICAgICAgICAgICByYWlzZSBWYWx1ZUVycm9yKGYiQXR0cmlidXRlICd0YWlsX2VudGl0eScgb2YgY2xhc3MgRXZlbnQgbXVzdCBiZSBhbiBJU09Db2RlIG9iamVjdCwgYnV0IHJlY2VpdmVkIHR5cGUge3R5cGUodGFpbF9lbnRpdHkpfSIpCgogICAgICAgIHNlbGYuZGF0ZSA9IGRhdGUKICAgICAgICBzZWxmLmhlYWRfZW50aXR5ID0gaGVhZF9lbnRpdHkKICAgICAgICBzZWxmLnJlbGF0aW9uID0gcmVsYXRpb24KICAgICAgICBzZWxmLnRhaWxfZW50aXR5ID0gdGFpbF9lbnRpdHkKCiAgICBkZWYgX19zdHJfXyhzZWxmKToKICAgICAgICByZXR1cm4gZiJFdmVudChkYXRlPXtzZWxmLmRhdGV9LCBoZWFkX2VudGl0eT17c2VsZi5oZWFkX2VudGl0eX0sIHJlbGF0aW9uPXtzZWxmLnJlbGF0aW9ufSwgdGFpbF9lbnRpdHk9e3NlbGYudGFpbF9lbnRpdHl9KSIKCiAgICBkZWYgX19oYXNoX18oc2VsZik6CiAgICAgICAgcmV0dXJuIGhhc2goKHNlbGYuZGF0ZSwgc2VsZi5oZWFkX2VudGl0eSwgc2VsZi5yZWxhdGlvbiwgc2VsZi50YWlsX2VudGl0eSkpCgogICAgZGVmIF9fZXFfXyhzZWxmLCBvdGhlcik6CiAgICAgICAgaWYgaXNpbnN0YW5jZShvdGhlciwgRXZlbnQpOgogICAgICAgICAgICByZXR1cm4gc2VsZi5kYXRlID09IG90aGVyLmRhdGUgYW5kIHNlbGYuaGVhZF9lbnRpdHkgPT0gb3RoZXIuaGVhZF9lbnRpdHkgYW5kIHNlbGYucmVsYXRpb24gPT0gb3RoZXIucmVsYXRpb24gYW5kIHNlbGYudGFpbF9lbnRpdHkgPT0gb3RoZXIudGFpbF9lbnRpdHkKICAgICAgICByZXR1cm4gRmFsc2UKCkBkYXRhY2xhc3MKY2xhc3MgTmV3c0FydGljbGU6CiAgICAiIiJSZXByZXNlbnRzIGEgbmV3cyBhcnRpY2xlLCBpbmNsdWRpbmcgbWV0YWRhdGEgYW5kIGNvbnRlbnQuIiIiCiAgICBkYXRlOiBEYXRlCiAgICB0aXRsZTogc3RyCiAgICBjb250ZW50OiBzdHIgIyBGdWxsIHRleHQgY29udGVudCBvZiB0aGUgbmV3cyBhcnRpY2xlCiAgICBldmVudHM6IExpc3RbRXZlbnRdICMgTGlzdCBvZiBldmVudHMgbWVudGlvbmVkIGluIHRoZSBhcnRpY2xlCiAgICAjIEV4YW1wbGU6IE5ld3NBcnRpY2xlKGRhdGU9RGF0ZSgiMjAyMi0wMS0wMSIpLCB0aXRsZT0iVHJhZGUgYWdyZWVtZW50IGJldHdlZW4gVVNBIGFuZCBDaGluYSIsIGNvbnRlbnQ9Ik9uIEphbnVhcnkgMSwgMjAyMiwgYSB0cmFkZSBhZ3JlZW1lbnQgd2FzIHNpZ25lZCBiZXR3ZWVuIHRoZSBVU0EgYW5kIENoaW5hLi4uIiwgZXZlbnRzPVtFdmVudChkYXRlPURhdGUoIjIwMjItMDEtMDEiKSwgaGVhZF9lbnRpdHk9SVNPQ29kZSgiVVNBIiksIHJlbGF0aW9uPUNBTUVPQ29kZSgiMDEwIiksIHRhaWxfZW50aXR5PUlTT0NvZGUoIkNITiIpXSkKCiAgICBkZWYgX19pbml0X18oc2VsZiwgZGF0ZTogRGF0ZSwgdGl0bGU6IHN0ciwgY29udGVudDogc3RyLCBldmVudHM6IExpc3RbRXZlbnRdKToKICAgICAgICAjIGNoZWNrIHR5cGUKICAgICAgICBpZiBub3QgaXNpbnN0YW5jZShkYXRlLCBEYXRlKToKICAgICAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmIkF0dHJpYnV0ZSAnZGF0ZScgb2YgY2xhc3MgTmV3c0FydGljbGUgbXVzdCBiZSBhIERhdGUgb2JqZWN0LCBidXQgcmVjZWl2ZWQgdHlwZSB7dHlwZShkYXRlKX0iKQogICAgICAgIGlmIG5vdCBpc2luc3RhbmNlKHRpdGxlLCBzdHIpOgogICAgICAgICAgICByYWlzZSBWYWx1ZUVycm9yKGYiQXR0cmlidXRlICd0aXRsZScgb2YgY2xhc3MgTmV3c0FydGljbGUgbXVzdCBiZSBhIHN0cmluZywgYnV0IHJlY2VpdmVkIHR5cGUge3R5cGUodGl0bGUpfSIpCiAgICAgICAgaWYgbm90IGlzaW5zdGFuY2UoY29udGVudCwgc3RyKToKICAgICAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmIkF0dHJpYnV0ZSAnY29udGVudCcgb2YgY2xhc3MgTmV3c0FydGljbGUgbXVzdCBiZSBhIHN0cmluZywgYnV0IHJlY2VpdmVkIHR5cGUge3R5cGUoY29udGVudCl9IikKICAgICAgICBpZiBub3QgaXNpbnN0YW5jZShldmVudHMsIGxpc3QpOgogICAgICAgICAgICByYWlzZSBWYWx1ZUVycm9yKGYiQXR0cmlidXRlICdldmVudHMnIG9mIGNsYXNzIE5ld3NBcnRpY2xlIG11c3QgYmUgYSBsaXN0LCBidXQgcmVjZWl2ZWQgdHlwZSB7dHlwZShldmVudHMpfSIpCgogICAgICAgIHNlbGYuZGF0ZSA9IGRhdGUKICAgICAgICBzZWxmLnRpdGxlID0gdGl0bGUKICAgICAgICBzZWxmLmNvbnRlbnQgPSBjb250ZW50CiAgICAgICAgc2VsZi5ldmVudHMgPSBldmVudHMKCiAgICBkZWYgX19zdHJfXyhzZWxmKToKICAgICAgICByZXR1cm4gZiJ7c2VsZi5kYXRlfTpcbntzZWxmLnRpdGxlfVxue3NlbGYuY29udGVudH0iCgogICAgZGVmIF9faGFzaF9fKHNlbGYpOgogICAgICAgIHJldHVybiBoYXNoKChzZWxmLmRhdGUsIHNlbGYudGl0bGUsIHNlbGYuY29udGVudCkpCgogICAgZGVmIF9fZXFfXyhzZWxmLCBvdGhlcik6CiAgICAgICAgaWYgaXNpbnN0YW5jZShvdGhlciwgTmV3c0FydGljbGUpOgogICAgICAgICAgICByZXR1cm4gc2VsZi5kYXRlID09IG90aGVyLmRhdGUgYW5kIHNlbGYudGl0bGUgPT0gb3RoZXIudGl0bGUgYW5kIHNlbGYuY29udGVudCA9PSBvdGhlci5jb250ZW50CiAgICAgICAgcmV0dXJuIEZhbHNlCgpkZWYgbWFwX2NvdW50cnlfbmFtZV90b19pc28obmFtZTogc3RyKSAtPiBMaXN0W0NvdW50cnldOgogICAgIiIiCiAgICBNYXBzIGEgY291bnRyeSBuYW1lIHRvIHRoZSBtb3N0IGxpa2VseSBjb3JyZXNwb25kaW5nIENvdW50cnkgb2JqZWN0cyB3aXRoIElTTyBjb2Rlcy4KCiAgICBQYXJhbWV0ZXJzOgogICAgICAgIG5hbWUgKHN0cik6IFRoZSBjb3VudHJ5IG5hbWUgdG8gbWFwLgoKICAgIFJldHVybnM6CiAgICAgICAgTGlzdFtDb3VudHJ5XTogQSBsaXN0IG9mIDUgbW9zdCBsaWtlbHkgQ291bnRyeSBvYmplY3RzIHNvcnRlZCBieSByZWxldmFuY2UuCgogICAgRXhhbXBsZToKICAgICAgICA+Pj4gbWFwX2NvdW50cnlfbmFtZV90b19pc28oIktvcmVhIikKICAgICAgICBbQ291bnRyeShpc29fY29kZT1JU09Db2RlKCJLT1IiKSwgbmFtZT0iUmVwdWJsaWMgb2YgS29yZWEiKSwgQ291bnRyeShpc29fY29kZT1JU09Db2RlKCJQUksiKSwgbmFtZT0iRGVtb2NyYXRpYyBQZW9wbGUncyBSZXB1YmxpYyBvZiBLb3JlYSIpXQogICAgIiIiCiAgICAjIGNoZWNrIHR5cGUKICAgIGlmIG5vdCBpc2luc3RhbmNlKG5hbWUsIHN0cik6CiAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmIklucHV0ICduYW1lJyBtdXN0IGJlIGEgc3RyaW5nLCBidXQgcmVjZWl2ZWQgdHlwZSB7dHlwZShuYW1lKX0iKQoKICAgIGlmIG5hbWUgaW4gZGljdF9jb3VudHJ5bmFtZTJpc286CiAgICAgICAgcmV0dXJuIFtDb3VudHJ5KGlzb19jb2RlPUlTT0NvZGUoZGljdF9jb3VudHJ5bmFtZTJpc29bbmFtZV0pLCBuYW1lPW5hbWUpXQogICAgZWxzZToKICAgICAgICAjIGdldCB0b3AgNSBJU08gY29kZXMgd2l0aCB0aGUgaGlnaGVzdCBjb3NpbmUgc2ltaWxhcml0eQogICAgICAgIG5hbWVfZW1iZWRkaW5ncyA9IGdldF9lbWJlZGRpbmcobmFtZSkKICAgICAgICBzaW1pbGFyaXRpZXMgPSBjb3NpbmVfc2ltaWxhcml0eShjb3VudHJ5X2VtYmVkZGluZ3MsIG5hbWVfZW1iZWRkaW5ncykKICAgICAgICB0b3BfaW5kaWNlcyA9IG5wLmFyZ3NvcnQoc2ltaWxhcml0aWVzKVs6Oi0xXVs6NV0KICAgICAgICBjb3VudHJpZXMgPSBbXQogICAgICAgIGZvciBpZHggaW4gdG9wX2luZGljZXM6CiAgICAgICAgICAgIGlzb19jb2RlID0gbGlzdChkaWN0X2lzbzJhbHRlcm5hbWVzLmtleXMoKSlbaWR4XQogICAgICAgICAgICBjdXJyX25hbWUgPSBkaWN0X2lzbzJhbHRlcm5hbWVzW2lzb19jb2RlXVswXQogICAgICAgICAgICBjb3VudHJpZXMuYXBwZW5kKENvdW50cnkoaXNvX2NvZGU9SVNPQ29kZShpc29fY29kZSksIG5hbWU9Y3Vycl9uYW1lKSkKICAgICAgICByZXR1cm4gY291bnRyaWVzCgpkZWYgbWFwX2lzb190b19jb3VudHJ5X25hbWUoaXNvX2NvZGU6IElTT0NvZGUpIC0+IHN0cjoKICAgICIiIgogICAgTWFwcyBhbiBJU08gY29kZSB0byBhIGNvdW50cnkgbmFtZS4KCiAgICBQYXJhbWV0ZXJzOgogICAgICAgIGlzb19jb2RlIChJU09Db2RlKTogVGhlIElTTyBjb2RlIHRvIG1hcC4KCiAgICBSZXR1cm5zOgogICAgICAgIHN0cjogVGhlIGNvcnJlc3BvbmRpbmcgY291bnRyeSBuYW1lLgoKICAgIEV4YW1wbGU6CiAgICAgICAgPj4+IG1hcF9pc29fdG9fY291bnRyeV9uYW1lKElTT0NvZGUoIkNITiIpKQogICAgICAgICJDaGluYSIKICAgICIiIgogICAgIyBjaGVjayB0eXBlCiAgICBpZiBub3QgaXNpbnN0YW5jZShpc29fY29kZSwgSVNPQ29kZSk6CiAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmIklucHV0ICdpc29fY29kZScgbXVzdCBiZSBhbiBJU09Db2RlIG9iamVjdCwgYnV0IHJlY2VpdmVkIHR5cGUge3R5cGUoaXNvX2NvZGUpfSIpCgogICAgcmV0dXJuIGRpY3RfaXNvMmFsdGVybmFtZXNbaXNvX2NvZGUuY29kZV1bMF0KCmRlZiBtYXBfcmVsYXRpb25fZGVzY3JpcHRpb25fdG9fY2FtZW8oZGVzY3JpcHRpb246IHN0cikgLT4gTGlzdFtSZWxhdGlvbl06CiAgICAiIiIKICAgIE1hcHMgYSByZWxhdGlvbiBkZXNjcmlwdGlvbiB0byB0aGUgbW9zdCBsaWtlbHkgUmVsYXRpb24gb2JqZWN0cy4KCiAgICBQYXJhbWV0ZXJzOgogICAgICAgIGRlc2NyaXB0aW9uIChzdHIpOiBUaGUgcmVsYXRpb24gZGVzY3JpcHRpb24gdG8gbWFwLgoKICAgIFJldHVybnM6CiAgICAgICAgTGlzdFtSZWxhdGlvbl06IEEgbGlzdCBvZiA1IG1vc3QgbGlrZWx5IFJlbGF0aW9ucyBzb3J0ZWQgYnkgcmVsZXZhbmNlLgoKICAgIEV4YW1wbGU6CiAgICAgICAgPj4+IG1hcF9yZWxhdGlvbl9kZXNjcmlwdGlvbl90b19jYW1lbygiRmlnaHQgd2l0aCBndW5zIikKICAgICAgICBbUmVsdGlvbihjYW1lb19jb2RlPUNBTUVPQ29kZSgiMTkiKSwgbmFtZT0iRmlnaHQiLCBkZXNjcmlwdGlvbj0iQWxsIHVzZXMgb2YgY29udmVudGlvbmFsIGZvcmNlIGFuZCBhY3RzIG9mIHdhciB0eXBpY2FsbHkgYnkgb3JnYW5pemVkIGFybWVkIGdyb3Vwcy4iKSwgUmVsYXRpb24oY2FtZW9fY29kZT1DQU1FT0NvZGUoIjE5MyIpLCBuYW1lPSJGaWdodCB3aXRoIHNtYWxsIGFybXMgYW5kIGxpZ2h0IHdlYXBvbnMiLCBkZXNjcmlwdGlvbj0iQXR0YWNrIHVzaW5nIHNtYWxsIGFybXMgYW5kIGxpZ2h0IHdlYXBvbnMgc3VjaCBhcyByaWZsZXMsIG1hY2hpbmUtZ3VucywgYW5kIG1vcnRhciBzaGVsbHMuIiksIFJlbGF0aW9uKGNhbWVvX2NvZGU9Q0FNRU9Db2RlKCIxOTAiKSwgbmFtZT0iVXNlIGNvbnZlbnRpb25hbCBtaWxpdGFyeSBmb3JjZSwgbm90IHNwZWNpZmllZCIsIGRlc2NyaXB0aW9uPSJBbGwgdXNlcyBvZiBjb252ZW50aW9uYWwgZm9yY2UgYW5kIGFjdHMgb2Ygd2FyIHR5cGljYWxseSBieSBvcmdhbml6ZWQgYXJtZWQgZ3JvdXBzLCBub3Qgb3RoZXJ3aXNlIHNwZWNpZmllZC4iKV0KICAgICIiIgogICAgIyBjaGVjayB0eXBlCiAgICBpZiBub3QgaXNpbnN0YW5jZShkZXNjcmlwdGlvbiwgc3RyKToKICAgICAgICByYWlzZSBWYWx1ZUVycm9yKGYiSW5wdXQgJ2Rlc2NyaXB0aW9uJyBtdXN0IGJlIGEgc3RyaW5nLCBidXQgcmVjZWl2ZWQgdHlwZSB7dHlwZShkZXNjcmlwdGlvbil9IikKCiAgICBpZiBkZXNjcmlwdGlvbiBpbiBkaWN0X3JlbGF0aW9uMmNvZGU6CiAgICAgICAgY29kZSA9IGRpY3RfcmVsYXRpb24yY29kZVtkZXNjcmlwdGlvbl0KICAgICAgICByZXR1cm4gW1JlbGF0aW9uKGNhbWVvX2NvZGU9Q0FNRU9Db2RlKGNvZGUpLCBuYW1lPWRpY3RfY29kZTJyZWxhdGlvbltjb2RlXVsnTmFtZSddLCBkZXNjcmlwdGlvbj1kaWN0X2NvZGUycmVsYXRpb25bY29kZV1bJ0Rlc2NyaXB0aW9uJ10pXQogICAgZWxzZToKICAgICAgICAjIGdldCB0b3AgNSBDQU1FTyBjb2RlcyB3aXRoIHRoZSBoaWdoZXN0IGNvc2luZSBzaW1pbGFyaXR5CiAgICAgICAgZGVzY3JpcHRpb25fZW1iZWRkaW5nID0gZ2V0X2VtYmVkZGluZyhkZXNjcmlwdGlvbikKICAgICAgICBzaW1pbGFyaXRpZXMgPSBjb3NpbmVfc2ltaWxhcml0eShyZWxhdGlvbl9lbWJlZGRpbmdzLCBkZXNjcmlwdGlvbl9lbWJlZGRpbmcpCiAgICAgICAgdG9wX2luZGljZXMgPSBucC5hcmdzb3J0KHNpbWlsYXJpdGllcylbOjotMV1bOjVdCiAgICAgICAgcmVsYXRpb25zID0gW10KICAgICAgICBmb3IgaWR4IGluIHRvcF9pbmRpY2VzOgogICAgICAgICAgICBjb2RlID0gbGlzdChkaWN0X2NvZGUycmVsYXRpb24ua2V5cygpKVtpZHhdCiAgICAgICAgICAgIHJlbGF0aW9ucy5hcHBlbmQoUmVsYXRpb24oY2FtZW9fY29kZT1DQU1FT0NvZGUoY29kZSksIG5hbWU9ZGljdF9jb2RlMnJlbGF0aW9uW2NvZGVdWydOYW1lJ10sIGRlc2NyaXB0aW9uPWRpY3RfY29kZTJyZWxhdGlvbltjb2RlXVsnRGVzY3JpcHRpb24nXSkpCiAgICAgICAgcmV0dXJuIHJlbGF0aW9ucwoKZGVmIG1hcF9jYW1lb190b19yZWxhdGlvbihjYW1lb19jb2RlOiBDQU1FT0NvZGUpIC0+IFJlbGF0aW9uOgogICAgIiIiCiAgICBNYXBzIGEgQ0FNRU8gY29kZSB0byBhIHJlbGF0aW9uLCBpbmNsdWRpbmcgaXRzIG5hbWUgYW5kIGRlc2NyaXB0aW9uLgoKICAgIFBhcmFtZXRlcnM6CiAgICAgICAgY2FtZW9fY29kZSAoQ0FNRU9Db2RlKTogVGhlIENBTUVPIGNvZGUgdG8gbWFwLgoKICAgIFJldHVybnM6CiAgICAgICAgUmVsYXRpb246IFRoZSBjb3JyZXNwb25kaW5nIHJlbGF0aW9uLgoKICAgIEV4YW1wbGU6CiAgICAgICAgPj4+IG1hcF9jYW1lb190b19yZWxhdGlvbihDQU1FT0NvZGUoIjE5MCIpKQogICAgICAgIFJlbGF0aW9uKGNhbWVvX2NvZGU9Q0FNRU9Db2RlKCIxOTAiKSwgbmFtZT0iVXNlIGNvbnZlbnRpb25hbCBtaWxpdGFyeSBmb3JjZSwgbm90IHNwZWNpZmllZCIsIGRlc2NyaXB0aW9uPSJBbGwgdXNlcyBvZiBjb252ZW50aW9uYWwgZm9yY2UgYW5kIGFjdHMgb2Ygd2FyIHR5cGljYWxseSBieSBvcmdhbml6ZWQgYXJtZWQgZ3JvdXBzLCBub3Qgb3RoZXJ3aXNlIHNwZWNpZmllZC4iKQogICAgIiIiCiAgICAjIGNoZWNrIHR5cGUKICAgIGlmIG5vdCBpc2luc3RhbmNlKGNhbWVvX2NvZGUsIENBTUVPQ29kZSk6CiAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmIklucHV0ICdjYW1lb19jb2RlJyBtdXN0IGJlIGEgQ0FNRU9Db2RlIG9iamVjdCwgYnV0IHJlY2VpdmVkIHR5cGUge3R5cGUoY2FtZW9fY29kZSl9IikKCiAgICBpbmZvID0gZGljdF9jb2RlMnJlbGF0aW9uW2NhbWVvX2NvZGUuY29kZV0KICAgIHJldHVybiBSZWxhdGlvbihjYW1lb19jb2RlPWNhbWVvX2NvZGUsIG5hbWU9aW5mb1snTmFtZSddLCBkZXNjcmlwdGlvbj1pbmZvWydEZXNjcmlwdGlvbiddKQoKZGVmIGdldF9wYXJlbnRfcmVsYXRpb24oY2FtZW9fY29kZTogQ0FNRU9Db2RlKSAtPiBSZWxhdGlvbjoKICAgICIiIgogICAgUmV0cmlldmVzIHRoZSBwYXJlbnQgcmVsYXRpb24gb2YgYSBnaXZlbiByZWxhdGlvbiBpZGVudGlmaWVkIGJ5IENBTUVPIGNvZGUuCgogICAgUGFyYW1ldGVyczoKICAgICAgICBjYW1lb19jb2RlIChDQU1FT0NvZGUpOiBUaGUgQ0FNRU8gY29kZSBvZiB0aGUgcmVsYXRpb24gd2hvc2UgcGFyZW50IGlzIHNvdWdodC4gT25seSBzZWNvbmQgbGV2ZWwgcmVsYXRpb25zIGFyZSBhY2NlcHRlZC4KCiAgICBSZXR1cm5zOgogICAgICAgIFJlbGF0aW9uOiBUaGUgZmlyc3QgbGV2ZWwgcGFyZW50IHJlbGF0aW9uLgoKICAgIEV4YW1wbGU6CiAgICAgICAgPj4+IGdldF9wYXJlbnRfcmVsYXRpb24oQ0FNRU9Db2RlKCIxOTMiKSkKICAgICAgICBSZWxhdGlvbihjYW1lb19jb2RlPUNBTUVPQ29kZSgiMTkiKSwgbmFtZT0iRmlnaHQiLCBkZXNjcmlwdGlvbj0iQWxsIHVzZXMgb2YgY29udmVudGlvbmFsIGZvcmNlIGFuZCBhY3RzIG9mIHdhciB0eXBpY2FsbHkgYnkgb3JnYW5pemVkIGFybWVkIGdyb3Vwcy4iKQogICAgIiIiCiAgICAjIGNoZWNrIHR5cGUKICAgIGlmIG5vdCBpc2luc3RhbmNlKGNhbWVvX2NvZGUsIENBTUVPQ29kZSk6CiAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmIklucHV0ICdjYW1lb19jb2RlJyBtdXN0IGJlIGEgQ0FNRU9Db2RlIG9iamVjdCwgYnV0IHJlY2VpdmVkIHR5cGUge3R5cGUoY2FtZW9fY29kZSl9IikKCiAgICBpZiBsZW4oY2FtZW9fY29kZS5jb2RlKSAhPSAzOgogICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoIk9ubHkgc2Vjb25kIGxldmVsIHJlbGF0aW9ucyBhcmUgYWNjZXB0ZWQsIGJ1dCByZWNlaXZlZDoge30iLmZvcm1hdChjYW1lb19jb2RlLmNvZGUpKQogICAgcGFyZW50X2NvZGUgPWNhbWVvX2NvZGUuY29kZVs6Ml0KICAgIHJldHVybiBtYXBfY2FtZW9fdG9fcmVsYXRpb24oQ0FNRU9Db2RlKHBhcmVudF9jb2RlKSkKCmRlZiBnZXRfY2hpbGRfcmVsYXRpb25zKGNhbWVvX2NvZGU6IENBTUVPQ29kZSkgLT4gTGlzdFtSZWxhdGlvbl06CiAgICAiIiIKICAgIFJldHJpZXZlcyBjaGlsZCByZWxhdGlvbnMgb2YgYSBnaXZlbiByZWxhdGlvbiBpZGVudGlmaWVkIGJ5IENBTUVPIGNvZGUuCgogICAgUGFyYW1ldGVyczoKICAgICAgICBjYW1lb19jb2RlIChDQU1FT0NvZGUpOiBUaGUgQ0FNRU8gY29kZSBvZiB0aGUgcmVsYXRpb24gd2hvc2UgY2hpbGRyZW4gYXJlIHNvdWdodC4gT25seSBmaXJzdCBsZXZlbCByZWxhdGlvbnMgYXJlIGFjY2VwdGVkLgoKICAgIFJldHVybnM6CiAgICAgICAgTGlzdFtSZWxhdGlvbl06IEEgbGlzdCBvZiBzZWNvbmQgbGV2ZWwgY2hpbGQgcmVsYXRpb25zLgoKICAgIEV4YW1wbGU6CiAgICAgICAgPj4+IGdldF9jaGlsZF9yZWxhdGlvbnMoQ0FNRU9Db2RlKCIxOSIpKQogICAgICAgIFtSZWxhdGlvbihjYWVtb19jb2RlPUNBTUVPQ29kZSgiMTkwIiksIG5hbWU9IlVzZSBjb252ZW50aW9uYWwgbWlsaXRhcnkgZm9yY2UsIG5vdCBzcGVjaWZpZWQiLCBkZXNjcmlwdGlvbj0iQWxsIHVzZXMgb2YgY29udmVudGlvbmFsIGZvcmNlIGFuZCBhY3RzIG9mIHdhciB0eXBpY2FsbHkgYnkgb3JnYW5pemVkIGFybWVkIGdyb3Vwcywgbm90IG90aGVyd2lzZSBzcGVjaWZpZWQuIiksIFJlbGF0aW9uKGNhbWVvX2NvZGU9Q0FNRU9Db2RlKCIxOTEiKSwgbmFtZT0iSW1wb3NlIGJsb2NrYWRlIG9yIHJlc3RyaWN0IG1vdmVtZW50IiwgZGVzY3JpcHRpb249IlByZXZlbnQgZW50cnkgaW50byBhbmQvb3IgZXhpdCBmcm9tIGEgdGVycml0b3J5IHVzaW5nIGFybWVkIGZvcmNlcy4iKSwgLi4uXQogICAgIiIiCiAgICAjIGNoZWNrIHR5cGUKICAgIGlmIG5vdCBpc2luc3RhbmNlKGNhbWVvX2NvZGUsIENBTUVPQ29kZSk6CiAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmIklucHV0ICdjYW1lb19jb2RlJyBtdXN0IGJlIGEgQ0FNRU9Db2RlIG9iamVjdCwgYnV0IHJlY2VpdmVkIHR5cGUge3R5cGUoY2FtZW9fY29kZSl9IikKCiAgICBpZiBsZW4oY2FtZW9fY29kZS5jb2RlKSAhPSAyOgogICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoIk9ubHkgZmlyc3QgbGV2ZWwgcmVsYXRpb25zIGFyZSBhY2NlcHRlZCwgYnV0IHJlY2VpdmVkOiB7fSIuZm9ybWF0KGNhbWVvX2NvZGUuY29kZSkpCiAgICBjaGlsZHJlbiA9IFtdCiAgICBmb3IgY29kZSwgaW5mbyBpbiBkaWN0X2NvZGUycmVsYXRpb24uaXRlbXMoKToKICAgICAgICBpZiBjb2RlWzoyXSA9PSBjYW1lb19jb2RlLmNvZGUgYW5kIGxlbihjb2RlKSA9PSAzOgogICAgICAgICAgICBjaGlsZHJlbi5hcHBlbmQoUmVsYXRpb24oY2FtZW9fY29kZT1DQU1FT0NvZGUoY29kZSksIG5hbWU9aW5mb1snTmFtZSddLCBkZXNjcmlwdGlvbj1pbmZvWydEZXNjcmlwdGlvbiddKSkKICAgIHJldHVybiBjaGlsZHJlbgoKZGVmIGdldF9zaWJsaW5nX3JlbGF0aW9ucyhjYW1lb19jb2RlOiBDQU1FT0NvZGUpIC0+IExpc3RbUmVsYXRpb25dOgogICAgIiIiCiAgICBSZXRyaWV2ZXMgc2libGluZyByZWxhdGlvbnMgb2YgYSBnaXZlbiByZWxhdGlvbiBpZGVudGlmaWVkIGJ5IENBTUVPIGNvZGUuCgogICAgUGFyYW1ldGVyczoKICAgICAgICBjYW1lb19jb2RlIChDQU1FT0NvZGUpOiBUaGUgQ0FNRU8gY29kZSBvZiB0aGUgcmVsYXRpb24gd2hvc2Ugc2libGluZ3MgYXJlIHNvdWdodC4gQm90aCBmaXJzdCBhbmQgc2Vjb25kIGxldmVsIHJlbGF0aW9ucyBhcmUgYWNjZXB0ZWQuCgogICAgUmV0dXJuczoKICAgICAgICBMaXN0W1JlbGF0aW9uXTogQSBsaXN0IG9mIHNpYmxpbmcgcmVsYXRpb25zIGF0IHRoZSBzYW1lIGxldmVsLgoKICAgIEV4YW1wbGU6CiAgICAgICAgPj4+IGdldF9zaWJsaW5nX3JlbGF0aW9ucyhDQU1FT0NvZGUoIjE5MyIpKQogICAgICAgIFtSZWxhdGlvbihjYWVtb19jb2RlPUNBTUVPQ29kZSgiMTkwIiksIG5hbWU9IlVzZSBjb252ZW50aW9uYWwgbWlsaXRhcnkgZm9yY2UsIG5vdCBzcGVjaWZpZWQiLCBkZXNjcmlwdGlvbj0iQWxsIHVzZXMgb2YgY29udmVudGlvbmFsIGZvcmNlIGFuZCBhY3RzIG9mIHdhciB0eXBpY2FsbHkgYnkgb3JnYW5pemVkIGFybWVkIGdyb3Vwcywgbm90IG90aGVyd2lzZSBzcGVjaWZpZWQuIiksIFJlbGF0aW9uKGNhbWVvX2NvZGU9Q0FNRU9Db2RlKCIxOTEiKSwgbmFtZT0iSW1wb3NlIGJsb2NrYWRlIG9yIHJlc3RyaWN0IG1vdmVtZW50IiwgZGVzY3JpcHRpb249IlByZXZlbnQgZW50cnkgaW50byBhbmQvb3IgZXhpdCBmcm9tIGEgdGVycml0b3J5IHVzaW5nIGFybWVkIGZvcmNlcy4iKSwgLi4uXQogICAgIiIiCiAgICAjIGNoZWNrIHR5cGUKICAgIGlmIG5vdCBpc2luc3RhbmNlKGNhbWVvX2NvZGUsIENBTUVPQ29kZSk6CiAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmIklucHV0ICdjYW1lb19jb2RlJyBtdXN0IGJlIGEgQ0FNRU9Db2RlIG9iamVjdCwgYnV0IHJlY2VpdmVkIHR5cGUge3R5cGUoY2FtZW9fY29kZSl9IikKCiAgICBpZiBsZW4oY2FtZW9fY29kZS5jb2RlKSA9PSAzOgogICAgICAgIHJldHVybiBnZXRfY2hpbGRfcmVsYXRpb25zKGdldF9wYXJlbnRfcmVsYXRpb24oY2FtZW9fY29kZSkuY2FtZW9fY29kZSkKICAgIGVsaWYgbGVuKGNhbWVvX2NvZGUuY29kZSkgPT0gMjoKICAgICAgICAjIGdldCAnMDEnIHRvICcyMCcgcmVsYXRpb25zCiAgICAgICAgZmlyc3RfbGV2ZWxfY29kZXMgPSBbc3RyKGkpLnpmaWxsKDIpIGZvciBpIGluIHJhbmdlKDEsIDIxKV0KICAgICAgICByZWxhdGlvbnMgPSBbXQogICAgICAgIGZvciBjb2RlIGluIGZpcnN0X2xldmVsX2NvZGVzOgogICAgICAgICAgICByZWxhdGlvbnMuYXBwZW5kKG1hcF9jYW1lb190b19yZWxhdGlvbihDQU1FT0NvZGUoY29kZSkpKQogICAgICAgIHJldHVybiByZWxhdGlvbnMKCmRlZiBjb3VudF9ldmVudHMoZGF0ZV9yYW5nZTogT3B0aW9uYWxbRGF0ZVJhbmdlXSA9IE5vbmUsIGhlYWRfZW50aXRpZXM6IE9wdGlvbmFsW0xpc3RbSVNPQ29kZV1dID0gTm9uZSwgdGFpbF9lbnRpdGllczogT3B0aW9uYWxbTGlzdFtJU09Db2RlXV0gPSBOb25lLCByZWxhdGlvbnM6IE9wdGlvbmFsW0xpc3RbQ0FNRU9Db2RlXV0gPSBOb25lKSAtPiBpbnQ6CiAgICAiIiIKICAgIENvdW50cyB0aGUgbnVtYmVyIG9mIGV2ZW50cyBpbiB0aGUga25vd2xlZGdlIGdyYXBoIGJhc2VkIG9uIHNwZWNpZmllZCBjb25kaXRpb25zLgoKICAgIFBhcmFtZXRlcnM6CiAgICAgICAgZGF0ZV9yYW5nZSAoT3B0aW9uYWxbRGF0ZVJhbmdlXSk6IFJhbmdlIG9mIGRhdGVzIHRvIGZpbHRlciB0aGUgZXZlbnRzLiBJZiBOb25lLCBhbGwgZGF0ZXMgYXJlIGluY2x1ZGVkLgogICAgICAgIGhlYWRfZW50aXRpZXMgKE9wdGlvbmFsW0xpc3RbSVNPQ29kZV1dKTogTGlzdCBvZiBoZWFkIGVudGl0eSBJU08gY29kZXMgdG8gYmUgaW5jbHVkZWQuIElmIE5vbmUsIGFsbCBjb3VudHJpZXMgYXJlIGluY2x1ZGVkLgogICAgICAgIHRhaWxfZW50aXRpZXMgKE9wdGlvbmFsW0xpc3RbSVNPQ29kZV1dKTogTGlzdCBvZiB0YWlsIGVudGl0eSBJU08gY29kZXMgdG8gYmUgaW5jbHVkZWQuIElmIE5vbmUsIGFsbCBjb3VudHJpZXMgYXJlIGluY2x1ZGVkLgogICAgICAgIHJlbGF0aW9ucyAoT3B0aW9uYWxbTGlzdFtDQU1FT0NvZGVdXSk6IExpc3Qgb2YgcmVsYXRpb24gQ0FNRU8gY29kZXMgdG8gYmUgaW5jbHVkZWQuIElmIGZpcnN0IGxldmVsIHJlbGF0aW9ucyBhcmUgbGlzdGVkLCBhbGwgc2Vjb25kIGxldmVsIHJlbGF0aW9ucyB1bmRlciB0aGVtIGFyZSBpbmNsdWRlZC4gSWYgTm9uZSwgYWxsIHJlbGF0aW9ucyBhcmUgaW5jbHVkZWQuCgogICAgUmV0dXJuczoKICAgICAgICBpbnQ6IENvdW50IG9mIHVuaXF1ZSBldmVudHMgbWF0Y2hpbmcgdGhlIGNvbmRpdGlvbnMuCgogICAgRXhhbXBsZToKICAgICAgICA+Pj4gY291bnRfZXZlbnRzKGRhdGVfcmFuZ2U9RGF0ZVJhbmdlKHN0YXJ0X2RhdGU9RGF0ZSgiMjAyMi0wMS0wMSIpLCBlbmRfZGF0ZT1EYXRlKCIyMDIyLTAxLTMxIikpLCBoZWFkX2VudGl0aWVzPVtJU09Db2RlKCJVU0EiKSwgSVNPQ29kZSgiQ0hOIildLCB0YWlsX2VudGl0aWVzPU5vbmUsIHJlbGF0aW9ucz1bQ0FNRU9Db2RlKCIwMTAiKV0pCiAgICAgICAgNAogICAgIiIiCiAgICAjIGNoZWNrIHR5cGUKICAgIGlmIGRhdGVfcmFuZ2UgYW5kIG5vdCBpc2luc3RhbmNlKGRhdGVfcmFuZ2UsIERhdGVSYW5nZSk6CiAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmIklucHV0ICdkYXRlX3JhbmdlJyBtdXN0IGJlIGEgRGF0ZVJhbmdlIG9iamVjdCwgYnV0IHJlY2VpdmVkIHR5cGUge3R5cGUoZGF0ZV9yYW5nZSl9IikKICAgIGlmIGhlYWRfZW50aXRpZXMgYW5kIG5vdCBpc2luc3RhbmNlKGhlYWRfZW50aXRpZXMsIGxpc3QpOgogICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoZiJJbnB1dCAnaGVhZF9lbnRpdGllcycgbXVzdCBiZSBhIGxpc3QsIGJ1dCByZWNlaXZlZCB0eXBlIHt0eXBlKGhlYWRfZW50aXRpZXMpfSIpCiAgICBpZiBoZWFkX2VudGl0aWVzIGFuZCBub3QgYWxsKGlzaW5zdGFuY2UoaXNvLCBJU09Db2RlKSBmb3IgaXNvIGluIGhlYWRfZW50aXRpZXMpOgogICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoZiJFbGVtZW50cyBpbiAnaGVhZF9lbnRpdGllcycgbXVzdCBiZSBJU09Db2RlIG9iamVjdHMiKQogICAgaWYgdGFpbF9lbnRpdGllcyBhbmQgbm90IGlzaW5zdGFuY2UodGFpbF9lbnRpdGllcywgbGlzdCk6CiAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmIklucHV0ICd0YWlsX2VudGl0aWVzJyBtdXN0IGJlIGEgbGlzdCwgYnV0IHJlY2VpdmVkIHR5cGUge3R5cGUodGFpbF9lbnRpdGllcyl9IikKICAgIGlmIHRhaWxfZW50aXRpZXMgYW5kIG5vdCBhbGwoaXNpbnN0YW5jZShpc28sIElTT0NvZGUpIGZvciBpc28gaW4gdGFpbF9lbnRpdGllcyk6CiAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmIkVsZW1lbnRzIGluICd0YWlsX2VudGl0aWVzJyBtdXN0IGJlIElTT0NvZGUgb2JqZWN0cyIpCiAgICBpZiByZWxhdGlvbnMgYW5kIG5vdCBpc2luc3RhbmNlKHJlbGF0aW9ucywgbGlzdCk6CiAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmIklucHV0ICdyZWxhdGlvbnMnIG11c3QgYmUgYSBsaXN0LCBidXQgcmVjZWl2ZWQgdHlwZSB7dHlwZShyZWxhdGlvbnMpfSIpCiAgICBpZiByZWxhdGlvbnMgYW5kIG5vdCBhbGwoaXNpbnN0YW5jZShjb2RlLCBDQU1FT0NvZGUpIGZvciBjb2RlIGluIHJlbGF0aW9ucyk6CiAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmIkVsZW1lbnRzIGluICdyZWxhdGlvbnMnIG11c3QgYmUgQ0FNRU9Db2RlIG9iamVjdHMiKQoKICAgICMgcHJvY2VzcyBkYXRhX2tnIGJ5IGZpbHRlcmluZyBiYXNlZCBvbiB0aGUgc3BlY2lmaWVkIGNvbmRpdGlvbnMKICAgIGN1cnJfZGF0YSA9IGRhdGFfa2cuY29weSgpCiAgICBjdXJyX2RhdGEuZHJvcF9kdXBsaWNhdGVzKHN1YnNldD1bJ1F1YWRFdmVudENvZGUnXSwgaW5wbGFjZT1UcnVlKQogICAgY3Vycl9kYXRhID0gY3Vycl9kYXRhW2N1cnJfZGF0YVsnRGF0ZVN0ciddIDw9IERFRkFVTFRfRU5EX0RBVEVdCiAgICBpZiBkYXRlX3JhbmdlOgogICAgICAgIGN1cnJfZGF0YSA9IGN1cnJfZGF0YVsoY3Vycl9kYXRhWydEYXRlU3RyJ10gPj0gZGF0ZV9yYW5nZS5zdGFydF9kYXRlLmRhdGUpICYgKGN1cnJfZGF0YVsnRGF0ZVN0ciddIDw9IGRhdGVfcmFuZ2UuZW5kX2RhdGUuZGF0ZSldCiAgICBpZiBoZWFkX2VudGl0aWVzOgogICAgICAgIGN1cnJfZGF0YSA9IGN1cnJfZGF0YVtjdXJyX2RhdGFbJ0FjdG9yMUNvdW50cnlDb2RlJ10uaXNpbihbaXNvLmNvZGUgZm9yIGlzbyBpbiBoZWFkX2VudGl0aWVzXSldCiAgICBpZiB0YWlsX2VudGl0aWVzOgogICAgICAgIGN1cnJfZGF0YSA9IGN1cnJfZGF0YVtjdXJyX2RhdGFbJ0FjdG9yMkNvdW50cnlDb2RlJ10uaXNpbihbaXNvLmNvZGUgZm9yIGlzbyBpbiB0YWlsX2VudGl0aWVzXSldCiAgICBpZiByZWxhdGlvbnM6CiAgICAgICAgIyBpZiBmaXJzdCBsZXZlbCByZWxhdGlvbnMgYXJlIGxpc3RlZCwgaW5jbHVkZSBhbGwgc2Vjb25kIGxldmVsIHJlbGF0aW9ucyB1bmRlciB0aGVtCiAgICAgICAgZm9yIGNvZGUgaW4gcmVsYXRpb25zOgogICAgICAgICAgICBpZiBsZW4oY29kZS5jb2RlKSA9PSAyOgogICAgICAgICAgICAgICAgcmVsYXRpb25zLmV4dGVuZChbQ0FNRU9Db2RlKGMpIGZvciBjIGluIGRpY3RfY29kZTJyZWxhdGlvbiBpZiBjWzoyXSA9PSBjb2RlLmNvZGUgYW5kIGxlbihjKSA9PSAzXSkKICAgICAgICBjdXJyX2RhdGEgPSBjdXJyX2RhdGFbY3Vycl9kYXRhWydFdmVudEJhc2VDb2RlJ10uaXNpbihbY29kZS5jb2RlIGZvciBjb2RlIGluIHJlbGF0aW9uc10pXQogICAgcmV0dXJuIGxlbihjdXJyX2RhdGEpCgpkZWYgZ2V0X2V2ZW50cyhkYXRlX3JhbmdlOiBPcHRpb25hbFtEYXRlUmFuZ2VdID0gTm9uZSwgaGVhZF9lbnRpdGllczogT3B0aW9uYWxbTGlzdFtJU09Db2RlXV0gPSBOb25lLCB0YWlsX2VudGl0aWVzOiBPcHRpb25hbFtMaXN0W0lTT0NvZGVdXSA9IE5vbmUsIHJlbGF0aW9uczogT3B0aW9uYWxbTGlzdFtDQU1FT0NvZGVdXSA9IE5vbmUsIHRleHRfZGVzY3JpcHRpb246IE9wdGlvbmFsW3N0cl0gPSBOb25lKSAtPiBMaXN0W0V2ZW50XToKICAgICIiIgogICAgUmV0cmlldmVzIGV2ZW50cyBmcm9tIHRoZSBrbm93bGVkZ2UgZ3JhcGggYmFzZWQgb24gc3BlY2lmaWVkIGNvbmRpdGlvbnMuCiAgICBJbmhlcml0cyBjb21tb24gZmlsdGVyIHBhcmFtZXRlcnMgZnJvbSBjb3VudF9ldmVudHMuIFNlZSBjb3VudF9ldmVudHMgZm9yIG1vcmUgZGV0YWlscyBvbiB0aGVzZSBwYXJhbWV0ZXJzLgoKICAgIEFkZGl0aW9uYWwgUGFyYW1ldGVyczoKICAgICAgICB0ZXh0X2Rlc2NyaXB0aW9uIChPcHRpb25hbFtzdHJdKTogVGV4dHVhbCBkZXNjcmlwdGlvbiB0byBtYXRjaCB3aXRoIHRoZSBzb3VyY2UgbmV3cyBhcnRpY2xlcyBvZiBldmVudHMuIElmIE5vbmUsIHRoZSByZXR1cm5lZCBldmVudHMgYXJlIHNvcnRlZCBieSBkYXRlIGluIGRlc2NlbmRpbmcgb3JkZXI7IG90aGVyd2lzZSwgc29ydGVkIGJ5IHJlbGV2YW5jZSBvZiB0aGUgc291cmNlIG5ld3MgYXJ0aWNsZSB0byB0aGUgZGVzY3JpcHRpb24uCgogICAgUmV0dXJuczoKICAgICAgICBMaXN0W0V2ZW50XTogQSBsaXN0IG9mIG1heGltdW0gMzAgZXZlbnRzIG1hdGNoaW5nIHRoZSBzcGVjaWZpZWQgY29uZGl0aW9ucy4KCiAgICBFeGFtcGxlOgogICAgICAgID4+PiBnZXRfZXZlbnRzKGRhdGVfcmFuZ2U9RGF0ZVJhbmdlKHN0YXJ0X2RhdGU9RGF0ZSgiMjAyMi0wMS0wMSIpLCBlbmRfZGF0ZT1EYXRlKCIyMDIyLTAxLTMxIikpLCBoZWFkX2VudGl0aWVzPVtJU09Db2RlKCJVU0EiKSwgSVNPQ29kZSgiQ0hOIildLCB0YWlsX2VudGl0aWVzPU5vbmUsIHJlbGF0aW9ucz1bQ0FNRU9Db2RlKCIwMTAiKV0sIHRleHRfZGVzY3JpcHRpb249ImVjb25vbWljIHRyYWRlIikKICAgICAgICBbRXZlbnQoZGF0ZT1EYXRlKCIyMDIyLTAxLTE1IiksIGhlYWRfZW50aXR5PUlTT0NvZGUoIlVTQSIpLCByZWxhdGlvbj1DQU1FT0NvZGUoIjAxMCIpLCB0YWlsX2VudGl0eT1JU09Db2RlKCJDQU4iKSwgRXZlbnQoZGF0ZT1EYXRlKCIyMDIyLTAxLTEwIiksIGhlYWRfZW50aXR5PUlTT0NvZGUoIkNITiIpLCByZWxhdGlvbj1DQU1FT0NvZGUoIjAxMCIpLCB0YWlsX2VudGl0eT1JU09Db2RlKCJVU0EiKSwgLi4uXQogICAgIiIiCiAgICAjIGNoZWNrIHR5cGUKICAgIGlmIGRhdGVfcmFuZ2UgYW5kIG5vdCBpc2luc3RhbmNlKGRhdGVfcmFuZ2UsIERhdGVSYW5nZSk6CiAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmIklucHV0ICdkYXRlX3JhbmdlJyBtdXN0IGJlIGEgRGF0ZVJhbmdlIG9iamVjdCwgYnV0IHJlY2VpdmVkIHR5cGUge3R5cGUoZGF0ZV9yYW5nZSl9IikKICAgIGlmIGhlYWRfZW50aXRpZXMgYW5kIG5vdCBpc2luc3RhbmNlKGhlYWRfZW50aXRpZXMsIGxpc3QpOgogICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoZiJJbnB1dCAnaGVhZF9lbnRpdGllcycgbXVzdCBiZSBhIGxpc3QsIGJ1dCByZWNlaXZlZCB0eXBlIHt0eXBlKGhlYWRfZW50aXRpZXMpfSIpCiAgICBpZiBoZWFkX2VudGl0aWVzIGFuZCBub3QgYWxsKGlzaW5zdGFuY2UoaXNvLCBJU09Db2RlKSBmb3IgaXNvIGluIGhlYWRfZW50aXRpZXMpOgogICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoZiJFbGVtZW50cyBpbiAnaGVhZF9lbnRpdGllcycgbXVzdCBiZSBJU09Db2RlIG9iamVjdHMiKQogICAgaWYgdGFpbF9lbnRpdGllcyBhbmQgbm90IGlzaW5zdGFuY2UodGFpbF9lbnRpdGllcywgbGlzdCk6CiAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmIklucHV0ICd0YWlsX2VudGl0aWVzJyBtdXN0IGJlIGEgbGlzdCwgYnV0IHJlY2VpdmVkIHR5cGUge3R5cGUodGFpbF9lbnRpdGllcyl9IikKICAgIGlmIHRhaWxfZW50aXRpZXMgYW5kIG5vdCBhbGwoaXNpbnN0YW5jZShpc28sIElTT0NvZGUpIGZvciBpc28gaW4gdGFpbF9lbnRpdGllcyk6CiAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmIkVsZW1lbnRzIGluICd0YWlsX2VudGl0aWVzJyBtdXN0IGJlIElTT0NvZGUgb2JqZWN0cyIpCiAgICBpZiByZWxhdGlvbnMgYW5kIG5vdCBpc2luc3RhbmNlKHJlbGF0aW9ucywgbGlzdCk6CiAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmIklucHV0ICdyZWxhdGlvbnMnIG11c3QgYmUgYSBsaXN0LCBidXQgcmVjZWl2ZWQgdHlwZSB7dHlwZShyZWxhdGlvbnMpfSIpCiAgICBpZiByZWxhdGlvbnMgYW5kIG5vdCBhbGwoaXNpbnN0YW5jZShjb2RlLCBDQU1FT0NvZGUpIGZvciBjb2RlIGluIHJlbGF0aW9ucyk6CiAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmIkVsZW1lbnRzIGluICdyZWxhdGlvbnMnIG11c3QgYmUgQ0FNRU9Db2RlIG9iamVjdHMiKQogICAgaWYgdGV4dF9kZXNjcmlwdGlvbiBhbmQgbm90IGlzaW5zdGFuY2UodGV4dF9kZXNjcmlwdGlvbiwgc3RyKToKICAgICAgICByYWlzZSBWYWx1ZUVycm9yKGYiSW5wdXQgJ3RleHRfZGVzY3JpcHRpb24nIG11c3QgYmUgYSBzdHJpbmcsIGJ1dCByZWNlaXZlZCB0eXBlIHt0eXBlKHRleHRfZGVzY3JpcHRpb24pfSIpCgogICAgIyBwcm9jZXNzIGRhdGFfa2cgYnkgZmlsdGVyaW5nIGJhc2VkIG9uIHRoZSBzcGVjaWZpZWQgY29uZGl0aW9ucwogICAgY3Vycl9kYXRhID0gZGF0YV9rZy5jb3B5KCkKICAgIGN1cnJfZGF0YSA9IGN1cnJfZGF0YVtjdXJyX2RhdGFbJ0RhdGVTdHInXSA8PSBERUZBVUxUX0VORF9EQVRFXQogICAgaWYgZGF0ZV9yYW5nZToKICAgICAgICBjdXJyX2RhdGEgPSBjdXJyX2RhdGFbKGN1cnJfZGF0YVsnRGF0ZVN0ciddID49IGRhdGVfcmFuZ2Uuc3RhcnRfZGF0ZS5kYXRlKSAmIChjdXJyX2RhdGFbJ0RhdGVTdHInXSA8PSBkYXRlX3JhbmdlLmVuZF9kYXRlLmRhdGUpXQogICAgaWYgaGVhZF9lbnRpdGllczoKICAgICAgICBjdXJyX2RhdGEgPSBjdXJyX2RhdGFbY3Vycl9kYXRhWydBY3RvcjFDb3VudHJ5Q29kZSddLmlzaW4oW2lzby5jb2RlIGZvciBpc28gaW4gaGVhZF9lbnRpdGllc10pXQogICAgaWYgdGFpbF9lbnRpdGllczoKICAgICAgICBjdXJyX2RhdGEgPSBjdXJyX2RhdGFbY3Vycl9kYXRhWydBY3RvcjJDb3VudHJ5Q29kZSddLmlzaW4oW2lzby5jb2RlIGZvciBpc28gaW4gdGFpbF9lbnRpdGllc10pXQogICAgaWYgcmVsYXRpb25zOgogICAgICAgICMgaWYgZmlyc3QgbGV2ZWwgcmVsYXRpb25zIGFyZSBsaXN0ZWQsIGluY2x1ZGUgYWxsIHNlY29uZCBsZXZlbCByZWxhdGlvbnMgdW5kZXIgdGhlbQogICAgICAgIGZvciBjb2RlIGluIHJlbGF0aW9uczoKICAgICAgICAgICAgaWYgbGVuKGNvZGUuY29kZSkgPT0gMjoKICAgICAgICAgICAgICAgIHJlbGF0aW9ucy5leHRlbmQoW0NBTUVPQ29kZShjKSBmb3IgYyBpbiBkaWN0X2NvZGUycmVsYXRpb24gaWYgY1s6Ml0gPT0gY29kZS5jb2RlIGFuZCBsZW4oYykgPT0gM10pCiAgICAgICAgY3Vycl9kYXRhID0gY3Vycl9kYXRhW2N1cnJfZGF0YVsnRXZlbnRCYXNlQ29kZSddLmlzaW4oW2NvZGUuY29kZSBmb3IgY29kZSBpbiByZWxhdGlvbnNdKV0KICAgIGlmIG5vdCB0ZXh0X2Rlc2NyaXB0aW9uOgogICAgICAgICMgZ2V0IG1heCAzMCBldmVudHMgZnJvbSB0aGUgZmlsdGVyZWQgZGF0YQogICAgICAgIGV2ZW50cyA9IFtdCiAgICAgICAgY3Vycl9kYXRhLmRyb3BfZHVwbGljYXRlcyhzdWJzZXQ9WydRdWFkRXZlbnRDb2RlJ10sIGlucGxhY2U9VHJ1ZSkKICAgICAgICAjIHNvcnRlZCBieSBkYXRlIGluIGRlc2NlbmRpbmcgb3JkZXIKICAgICAgICBjdXJyX2RhdGEuc29ydF92YWx1ZXMoYnk9J0RhdGVTdHInLCBhc2NlbmRpbmc9RmFsc2UsIGlucGxhY2U9VHJ1ZSkKICAgICAgICBjb3VudCA9IDAKICAgICAgICBmb3IgXywgcm93IGluIGN1cnJfZGF0YS5pdGVycm93cygpOgogICAgICAgICAgICBpZiBjb3VudCA+PSAzMDoKICAgICAgICAgICAgICAgIGJyZWFrCiAgICAgICAgICAgIGV2ZW50cy5hcHBlbmQoRXZlbnQoZGF0ZT1EYXRlKHJvd1snRGF0ZVN0ciddKSwgaGVhZF9lbnRpdHk9SVNPQ29kZShyb3dbJ0FjdG9yMUNvdW50cnlDb2RlJ10pLCByZWxhdGlvbj1DQU1FT0NvZGUocm93WydFdmVudEJhc2VDb2RlJ10pLCB0YWlsX2VudGl0eT1JU09Db2RlKHJvd1snQWN0b3IyQ291bnRyeUNvZGUnXSkpKQogICAgICAgIHJldHVybiBldmVudHNbOjMwXQogICAgZWxzZToKICAgICAgICAjIGNvbmNhdCB0aGUgRG9jaWRzIGxpc3Qgb2YgY3VycmVudCBkYXRhIHRvIGdldCB0aGUgbmV3cyBhcnRpY2xlcwogICAgICAgIGRvY2lkc19saXN0ID0gW2V2YWwoZG9jaWRzKSBmb3IgZG9jaWRzIGluIGN1cnJfZGF0YVsnRG9jaWRzJ10udW5pcXVlKCkudG9saXN0KCldCiAgICAgICAgZG9jaWRzID0gbGlzdChzZXQoW2l0ZW0gZm9yIHN1Ymxpc3QgaW4gZG9jaWRzX2xpc3QgZm9yIGl0ZW0gaW4gc3VibGlzdF0pKQogICAgICAgIGRvY2lkcyA9IFtzdHIoZG9jaWQpIGZvciBkb2NpZCBpbiBkb2NpZHNdCiAgICAgICAgbmV3c19hcnRpY2xlcyA9IGRhdGFfbmV3c1tkYXRhX25ld3NbJ0RvY2lkJ10uaXNpbihkb2NpZHMpXQogICAgICAgICMgZ2V0IHRoZSBtYXggMzAgZG9jaWRzIHdpdGggdGhlIGhpZ2hlc3QgQk0yNSBzY29yZSB0byB0aGUgdGV4dF9kZXNjcmlwdGlvbgogICAgICAgIGNvcnB1cyA9IG5ld3NfYXJ0aWNsZXNbJ1RpdGxlJ10gKyAnICcgKyBuZXdzX2FydGljbGVzWydUZXh0J10KICAgICAgICB0b2tlbml6ZWRfY29ycHVzID0gW2RvYy5zcGxpdCgiICIpIGZvciBkb2MgaW4gY29ycHVzXQogICAgICAgIGJtMjUgPSBCTTI1T2thcGkodG9rZW5pemVkX2NvcnB1cykKICAgICAgICB0b2tlbml6ZWRfcXVlcnkgPSB0ZXh0X2Rlc2NyaXB0aW9uLnNwbGl0KCIgIikKICAgICAgICBkb2Nfc2NvcmVzID0gYm0yNS5nZXRfc2NvcmVzKHRva2VuaXplZF9xdWVyeSkKICAgICAgICB0b3BfaW5kaWNlcyA9IG5wLmFyZ3NvcnQoZG9jX3Njb3JlcylbOjotMV1bOjMwXQogICAgICAgIG5ld3NfYXJ0aWNsZXMgPSBuZXdzX2FydGljbGVzLmlsb2NbdG9wX2luZGljZXNdCiAgICAgICAgZG9jaWRzID0gbmV3c19hcnRpY2xlc1snRG9jaWQnXS50b2xpc3QoKQogICAgICAgICMgZ2V0IG1heCAzMCBldmVudHMgZnJvbSB0aGUgZmlsdGVyZWQgZGF0YQogICAgICAgIGV2ZW50cyA9IHNldCgpCiAgICAgICAgZm9yIGRvY2lkIGluIGRvY2lkczoKICAgICAgICAgICAgaWYgbGVuKGV2ZW50cykgPj0gMzA6CiAgICAgICAgICAgICAgICBicmVhawogICAgICAgICAgICBkb2NfY3Vycl9kYXRhID0gY3Vycl9kYXRhW2N1cnJfZGF0YVsnRG9jaWQnXSA9PSBkb2NpZF0KICAgICAgICAgICAgIyByZXZlcnNlIHRoZSBvcmRlciBvZiB0aGUgZXZlbnRzIHRvIGdldCB0aGUgbGF0ZXN0IGV2ZW50cyBmaXJzdAogICAgICAgICAgICBkb2NfY3Vycl9kYXRhID0gZG9jX2N1cnJfZGF0YS5zb3J0X3ZhbHVlcyhieT0nRGF0ZVN0cicsIGFzY2VuZGluZz1GYWxzZSkKICAgICAgICAgICAgZm9yIF8sIHJvdyBpbiBkb2NfY3Vycl9kYXRhLml0ZXJyb3dzKCk6CiAgICAgICAgICAgICAgICBldmVudHMuYWRkKEV2ZW50KGRhdGU9RGF0ZShyb3dbJ0RhdGVTdHInXSksIGhlYWRfZW50aXR5PUlTT0NvZGUocm93WydBY3RvcjFDb3VudHJ5Q29kZSddKSwgcmVsYXRpb249Q0FNRU9Db2RlKHJvd1snRXZlbnRCYXNlQ29kZSddKSwgdGFpbF9lbnRpdHk9SVNPQ29kZShyb3dbJ0FjdG9yMkNvdW50cnlDb2RlJ10pKSkKICAgICAgICByZXR1cm4gbGlzdChldmVudHMpCgpkZWYgZ2V0X2VudGl0eV9kaXN0cmlidXRpb24oZGF0ZV9yYW5nZTogT3B0aW9uYWxbRGF0ZVJhbmdlXSA9IE5vbmUsIGludm9sdmVkX3JlbGF0aW9uczogT3B0aW9uYWxbTGlzdFtDQU1FT0NvZGVdXSA9IE5vbmUsIGludGVyYWN0ZWRfZW50aXRpZXM6IE9wdGlvbmFsW0xpc3RbSVNPQ29kZV1dID0gTm9uZSwgZW50aXR5X3JvbGU6IE9wdGlvbmFsW3N0cl0gPSBOb25lKSAtPiBEaWN0W0lTT0NvZGUsIGludF06CiAgICAiIiIKICAgIEdldHMgdGhlIGRpc3RyaWJ1dGlvbiBvZiBlbnRpdGllcyBpbiB0aGUga25vd2xlZGdlIGdyYXBoIHVuZGVyIHNwZWNpZmllZCBjb25kaXRpb25zLgoKICAgIFBhcmFtZXRlcnM6CiAgICAgICAgZGF0ZV9yYW5nZSAoT3B0aW9uYWxbRGF0ZVJhbmdlXSk6IFJhbmdlIG9mIGRhdGVzIHRvIGZpbHRlciB0aGUgZXZlbnRzLiBJZiBOb25lLCBhbGwgZGF0ZXMgYXJlIGluY2x1ZGVkLgogICAgICAgIGludm9sdmVkX3JlbGF0aW9ucyAoT3B0aW9uYWxbTGlzdFtDQU1FT0NvZGVdXSk6IExpc3Qgb2YgcmVsYXRpb25zIHRoYXQgdGhlIHJldHVybmVkIGVudGl0aWVzIG11c3QgYmUgaW52b2x2ZWQgaW4gYW55IG9mLiBJZiBmaXJzdCBsZXZlbCByZWxhdGlvbnMgYXJlIGxpc3RlZCwgYWxsIHNlY29uZCBsZXZlbCByZWxhdGlvbnMgdW5kZXIgdGhlbSBhcmUgaW5jbHVkZWQuIElmIE5vbmUsIGFsbCByZWxhdGlvbnMgYXJlIGluY2x1ZGVkLgogICAgICAgIGludGVyYWN0ZWRfZW50aXRpZXMgKE9wdGlvbmFsW0xpc3RbSVNPQ29kZV1dKTogTGlzdCBvZiBlbnRpdGllcyB0aGF0IHRoZSByZXR1cm5lZCBlbnRpdGllcyBtdXN0IGhhdmUgaW50ZXJhY3RlZCB3aXRoIGFueSBvZi4gSWYgTm9uZSwgYWxsIGVudGl0aWVzIGFyZSBpbmNsdWRlZC4KICAgICAgICBlbnRpdHlfcm9sZSAoT3B0aW9uYWxbRW50aXR5Um9sZV0pOiBTcGVjaWZpZXMgdGhlIHJvbGUgb2YgdGhlIHJldHVybmVkIGVudGl0eSBpbiB0aGUgZXZlbnRzLiBPcHRpb25zIGFyZSAnaGVhZCcsICd0YWlsJywgb3IgJ2JvdGgnLiBJZiAnYm90aCcgb3IgTm9uZSwgdGhlIHJldHVybmVkIGVudGl0eSBjYW4gYmUgZWl0aGVyIGhlYWQgb3IgdGFpbC4KCiAgICBSZXR1cm5zOgogICAgICAgIERpY3RbSVNPQ29kZSwgaW50XTogQSBkaWN0aW9uYXJ5IG1hcHBpbmcgcmV0dXJuZWQgZW50aXRpZXMnIElTTyBjb2RlcyB0byB0aGUgbnVtYmVyIG9mIGV2ZW50cyB3aXRoIHRoZSBzcGVjaWZpZWQgY29uZGl0aW9ucyBpbiB3aGljaCB0aGV5IGFyZSBpbnZvbHZlZCwgc29ydGVkIGJ5IGNvdW50cyBpbiBkZXNjZW5kaW5nIG9yZGVyLgoKICAgIEV4YW1wbGU6CiAgICAgICAgPj4+IGdldF9lbnRpdHlfZGlzdHJpYnV0aW9uKGRhdGVfcmFuZ2U9RGF0ZVJhbmdlKHN0YXJ0X2RhdGU9RGF0ZSgiMjAyMi0wMS0wMSIpLCBlbmRfZGF0ZT1EYXRlKCIyMDIyLTAxLTMxIikpLCBpbnZvbHZlZF9yZWxhdGlvbnM9W0NBTUVPQ29kZSgiMDEwIildLCBpbnRlcmFjdGVkX2VudGl0aWVzPVtJU09Db2RlKCJVU0EiKSwgSVNPQ29kZSgiQ0hOIildLCBlbnRpdHlfcm9sZT0idGFpbCIpCiAgICAgICAge0lTT0NvZGUoIlVTQSIpOiAzLCBJU09Db2RlKCJDSE4iKTogMX0KICAgICIiIgogICAgIyBjaGVjayB0eXBlCiAgICBpZiBkYXRlX3JhbmdlIGFuZCBub3QgaXNpbnN0YW5jZShkYXRlX3JhbmdlLCBEYXRlUmFuZ2UpOgogICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoZiJJbnB1dCAnZGF0ZV9yYW5nZScgbXVzdCBiZSBhIERhdGVSYW5nZSBvYmplY3QsIGJ1dCByZWNlaXZlZCB0eXBlIHt0eXBlKGRhdGVfcmFuZ2UpfSIpCiAgICBpZiBpbnZvbHZlZF9yZWxhdGlvbnMgYW5kIG5vdCBpc2luc3RhbmNlKGludm9sdmVkX3JlbGF0aW9ucywgbGlzdCk6CiAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmIklucHV0ICdpbnZvbHZlZF9yZWxhdGlvbnMnIG11c3QgYmUgYSBsaXN0LCBidXQgcmVjZWl2ZWQgdHlwZSB7dHlwZShpbnZvbHZlZF9yZWxhdGlvbnMpfSIpCiAgICBpZiBpbnZvbHZlZF9yZWxhdGlvbnMgYW5kIG5vdCBhbGwoaXNpbnN0YW5jZShjb2RlLCBDQU1FT0NvZGUpIGZvciBjb2RlIGluIGludm9sdmVkX3JlbGF0aW9ucyk6CiAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmIkVsZW1lbnRzIGluICdpbnZvbHZlZF9yZWxhdGlvbnMnIG11c3QgYmUgQ0FNRU9Db2RlIG9iamVjdHMiKQogICAgaWYgaW50ZXJhY3RlZF9lbnRpdGllcyBhbmQgbm90IGlzaW5zdGFuY2UoaW50ZXJhY3RlZF9lbnRpdGllcywgbGlzdCk6CiAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmIklucHV0ICdpbnRlcmFjdGVkX2VudGl0aWVzJyBtdXN0IGJlIGEgbGlzdCwgYnV0IHJlY2VpdmVkIHR5cGUge3R5cGUoaW50ZXJhY3RlZF9lbnRpdGllcyl9IikKICAgIGlmIGludGVyYWN0ZWRfZW50aXRpZXMgYW5kIG5vdCBhbGwoaXNpbnN0YW5jZShpc28sIElTT0NvZGUpIGZvciBpc28gaW4gaW50ZXJhY3RlZF9lbnRpdGllcyk6CiAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmIkVsZW1lbnRzIGluICdpbnRlcmFjdGVkX2VudGl0aWVzJyBtdXN0IGJlIElTT0NvZGUgb2JqZWN0cyIpCiAgICBpZiBlbnRpdHlfcm9sZSBhbmQgZW50aXR5X3JvbGUgbm90IGluIFsnaGVhZCcsICd0YWlsJywgJ2JvdGgnXToKICAgICAgICByYWlzZSBWYWx1ZUVycm9yKGYiSW5wdXQgJ2VudGl0eV9yb2xlJyBtdXN0IGJlIGEgc3RyaW5nICdoZWFkJywgJ3RhaWwnLCBvciAnYm90aCcsIGJ1dCByZWNlaXZlZDoge2VudGl0eV9yb2xlfSIpCgogICAgIyBwcm9jZXNzIGRhdGFfa2cgYnkgZmlsdGVyaW5nIGJhc2VkIG9uIHRoZSBzcGVjaWZpZWQgY29uZGl0aW9ucwogICAgY3Vycl9kYXRhID0gZGF0YV9rZy5jb3B5KCkKICAgIGN1cnJfZGF0YS5kcm9wX2R1cGxpY2F0ZXMoc3Vic2V0PVsnUXVhZEV2ZW50Q29kZSddLCBpbnBsYWNlPVRydWUpCiAgICBjdXJyX2RhdGEgPSBjdXJyX2RhdGFbY3Vycl9kYXRhWydEYXRlU3RyJ10gPD0gREVGQVVMVF9FTkRfREFURV0KICAgIGlmIGRhdGVfcmFuZ2U6CiAgICAgICAgY3Vycl9kYXRhID0gY3Vycl9kYXRhWyhjdXJyX2RhdGFbJ0RhdGVTdHInXSA+PSBkYXRlX3JhbmdlLnN0YXJ0X2RhdGUuZGF0ZSkgJiAoY3Vycl9kYXRhWydEYXRlU3RyJ10gPD0gZGF0ZV9yYW5nZS5lbmRfZGF0ZS5kYXRlKV0KICAgIGlmIGludm9sdmVkX3JlbGF0aW9uczoKICAgICAgICAjIGlmIGZpcnN0IGxldmVsIHJlbGF0aW9ucyBhcmUgbGlzdGVkLCBpbmNsdWRlIGFsbCBzZWNvbmQgbGV2ZWwgcmVsYXRpb25zIHVuZGVyIHRoZW0KICAgICAgICBmb3IgY29kZSBpbiBpbnZvbHZlZF9yZWxhdGlvbnM6CiAgICAgICAgICAgIGlmIGxlbihjb2RlLmNvZGUpID09IDI6CiAgICAgICAgICAgICAgICBpbnZvbHZlZF9yZWxhdGlvbnMuZXh0ZW5kKFtDQU1FT0NvZGUoYykgZm9yIGMgaW4gZGljdF9jb2RlMnJlbGF0aW9uIGlmIGNbOjJdID09IGNvZGUuY29kZSBhbmQgbGVuKGMpID09IDNdKQogICAgICAgIGN1cnJfZGF0YSA9IGN1cnJfZGF0YVtjdXJyX2RhdGFbJ0V2ZW50QmFzZUNvZGUnXS5pc2luKFtjb2RlLmNvZGUgZm9yIGNvZGUgaW4gaW52b2x2ZWRfcmVsYXRpb25zXSldCiAgICBpZiBpbnRlcmFjdGVkX2VudGl0aWVzOgogICAgICAgIGlmIGVudGl0eV9yb2xlPT0naGVhZCc6CiAgICAgICAgICAgIGN1cnJfZGF0YSA9IGN1cnJfZGF0YVtjdXJyX2RhdGFbJ0FjdG9yMkNvdW50cnlDb2RlJ10uaXNpbihbaXNvLmNvZGUgZm9yIGlzbyBpbiBpbnRlcmFjdGVkX2VudGl0aWVzXSldCiAgICAgICAgZWxpZiBlbnRpdHlfcm9sZT09J3RhaWwnOgogICAgICAgICAgICBjdXJyX2RhdGEgPSBjdXJyX2RhdGFbY3Vycl9kYXRhWydBY3RvcjFDb3VudHJ5Q29kZSddLmlzaW4oW2lzby5jb2RlIGZvciBpc28gaW4gaW50ZXJhY3RlZF9lbnRpdGllc10pXQogICAgICAgIGVsc2U6CiAgICAgICAgICAgIGN1cnJfZGF0YSA9IGN1cnJfZGF0YVsoY3Vycl9kYXRhWydBY3RvcjFDb3VudHJ5Q29kZSddLmlzaW4oW2lzby5jb2RlIGZvciBpc28gaW4gaW50ZXJhY3RlZF9lbnRpdGllc10pKSB8IChjdXJyX2RhdGFbJ0FjdG9yMkNvdW50cnlDb2RlJ10uaXNpbihbaXNvLmNvZGUgZm9yIGlzbyBpbiBpbnRlcmFjdGVkX2VudGl0aWVzXSkpXQogICAgIyBjb3VudCB0aGUgbnVtYmVyIG9mIGV2ZW50cyBmb3IgZWFjaCBlbnRpdHkKICAgIGVudGl0eV9jb3VudHMgPSBjdXJyX2RhdGFbJ0FjdG9yMUNvdW50cnlDb2RlJ10uX2FwcGVuZChjdXJyX2RhdGFbJ0FjdG9yMkNvdW50cnlDb2RlJ10pLnZhbHVlX2NvdW50cygpCiAgICBlbnRpdHlfY291bnRzID0gZW50aXR5X2NvdW50cy50b19kaWN0KCkKICAgICMgc29ydCB0aGUgZGljdGlvbmFyeSBieSB2YWx1ZXMgaW4gZGVzY2VuZGluZyBvcmRlcgogICAgZW50aXR5X2NvdW50cyA9IGRpY3Qoc29ydGVkKGVudGl0eV9jb3VudHMuaXRlbXMoKSwga2V5PWxhbWJkYSBpdGVtOiBpdGVtWzFdLCByZXZlcnNlPVRydWUpKQogICAgZW50aXR5X2NvdW50cyA9IHtJU09Db2RlKGtleSk6IHZhbHVlIGZvciBrZXksIHZhbHVlIGluIGVudGl0eV9jb3VudHMuaXRlbXMoKX0KICAgIHJldHVybiBlbnRpdHlfY291bnRzCgpkZWYgZ2V0X3JlbGF0aW9uX2Rpc3RyaWJ1dGlvbihkYXRlX3JhbmdlOiBPcHRpb25hbFtEYXRlUmFuZ2VdID0gTm9uZSwgaGVhZF9lbnRpdGllczogT3B0aW9uYWxbTGlzdFtJU09Db2RlXV0gPSBOb25lLCB0YWlsX2VudGl0aWVzOiBPcHRpb25hbFtMaXN0W0lTT0NvZGVdXSA9IE5vbmUpIC0+IERpY3RbQ0FNRU9Db2RlLCBpbnRdOgogICAgIiIiCiAgICBHZXRzIHRoZSBkaXN0cmlidXRpb24gb2Ygc2Vjb25kIGxldmVsIHJlbGF0aW9ucyBpbiB0aGUga25vd2xlZGdlIGdyYXBoIHVuZGVyIHNwZWNpZmllZCBjb25kaXRpb25zLgoKICAgIFBhcmFtZXRlcnM6CiAgICAgICAgZGF0ZV9yYW5nZSAoT3B0aW9uYWxbRGF0ZVJhbmdlXSk6IFJhbmdlIG9mIGRhdGVzIHRvIGZpbHRlciB0aGUgZXZlbnRzLiBJZiBOb25lLCBhbGwgZGF0ZXMgYXJlIGluY2x1ZGVkLgogICAgICAgIGhlYWRfZW50aXRpZXMgKE9wdGlvbmFsW0xpc3RbSVNPQ29kZV1dKTogTGlzdCBvZiBoZWFkIGVudGl0aWVzIHRoYXQgdGhlIGV2ZW50cyBtdXN0IGludm9sdmUgYW55IG9mLiBJZiBOb25lLCBhbGwgaGVhZCBlbnRpdGllcyBhcmUgaW5jbHVkZWQuCiAgICAgICAgdGFpbF9lbnRpdGllcyAoT3B0aW9uYWxbTGlzdFtJU09Db2RlXV0pOiBMaXN0IG9mIHRhaWwgZW50aXRpZXMgdGhhdCB0aGUgZXZlbnRzIG11c3QgaW52b2x2ZSBhbnkgb2YuIElmIE5vbmUsIGFsbCB0YWlsIGVudGl0aWVzIGFyZSBpbmNsdWRlZC4KCiAgICBSZXR1cm5zOgogICAgICAgIERpY3RbQ0FNRU9Db2RlLCBpbnRdOiBBIGRpY3Rpb25hcnkgbWFwcGluZyBzZWNvbmQgbGV2ZWwgcmVsYXRpb25zJyBDQU1FTyBjb2RlcyB0byB0aGUgbnVtYmVyIG9mIGV2ZW50cyB3aXRoIHRoZSBzcGVjaWZpZWQgY29uZGl0aW9ucyBpbiB3aGljaCB0aGV5IGFyZSBpbnZvbHZlZCwgc29ydGVkIGJ5IGNvdW50cyBpbiBkZXNjZW5kaW5nIG9yZGVyLgoKICAgIEV4YW1wbGU6CiAgICAgICAgPj4+IGdldF9yZWxhdGlvbl9kaXN0cmlidXRpb24oZGF0ZV9yYW5nZT1EYXRlUmFuZ2Uoc3RhcnRfZGF0ZT1EYXRlKCIyMDIyLTAxLTAxIiksIGVuZF9kYXRlPURhdGUoIjIwMjItMDEtMzEiKSksIGhlYWRfZW50aXRpZXM9W0lTT0NvZGUoIlVTQSIpLCBJU09Db2RlKCJDSE4iKV0sIHRhaWxfZW50aXRpZXM9Tm9uZSkKICAgICAgICB7Q0FNRU9Db2RlKCIwMTAiKTogMywgQ0FNRU9Db2RlKCIwMTEiKTogMX0KICAgICIiIgogICAgIyBjaGVjayB0eXBlCiAgICBpZiBkYXRlX3JhbmdlIGFuZCBub3QgaXNpbnN0YW5jZShkYXRlX3JhbmdlLCBEYXRlUmFuZ2UpOgogICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoZiJJbnB1dCAnZGF0ZV9yYW5nZScgbXVzdCBiZSBhIERhdGVSYW5nZSBvYmplY3QsIGJ1dCByZWNlaXZlZCB0eXBlIHt0eXBlKGRhdGVfcmFuZ2UpfSIpCiAgICBpZiBoZWFkX2VudGl0aWVzIGFuZCBub3QgaXNpbnN0YW5jZShoZWFkX2VudGl0aWVzLCBsaXN0KToKICAgICAgICByYWlzZSBWYWx1ZUVycm9yKGYiSW5wdXQgJ2hlYWRfZW50aXRpZXMnIG11c3QgYmUgYSBsaXN0LCBidXQgcmVjZWl2ZWQgdHlwZSB7dHlwZShoZWFkX2VudGl0aWVzKX0iKQogICAgaWYgaGVhZF9lbnRpdGllcyBhbmQgbm90IGFsbChpc2luc3RhbmNlKGlzbywgSVNPQ29kZSkgZm9yIGlzbyBpbiBoZWFkX2VudGl0aWVzKToKICAgICAgICByYWlzZSBWYWx1ZUVycm9yKGYiRWxlbWVudHMgaW4gJ2hlYWRfZW50aXRpZXMnIG11c3QgYmUgSVNPQ29kZSBvYmplY3RzIikKICAgIGlmIHRhaWxfZW50aXRpZXMgYW5kIG5vdCBpc2luc3RhbmNlKHRhaWxfZW50aXRpZXMsIGxpc3QpOgogICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoZiJJbnB1dCAndGFpbF9lbnRpdGllcycgbXVzdCBiZSBhIGxpc3QsIGJ1dCByZWNlaXZlZCB0eXBlIHt0eXBlKHRhaWxfZW50aXRpZXMpfSIpCiAgICBpZiB0YWlsX2VudGl0aWVzIGFuZCBub3QgYWxsKGlzaW5zdGFuY2UoaXNvLCBJU09Db2RlKSBmb3IgaXNvIGluIHRhaWxfZW50aXRpZXMpOgogICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoZiJFbGVtZW50cyBpbiAndGFpbF9lbnRpdGllcycgbXVzdCBiZSBJU09Db2RlIG9iamVjdHMiKQoKICAgICMgcHJvY2VzcyBkYXRhX2tnIGJ5IGZpbHRlcmluZyBiYXNlZCBvbiB0aGUgc3BlY2lmaWVkIGNvbmRpdGlvbnMKICAgIGN1cnJfZGF0YSA9IGRhdGFfa2cuY29weSgpCiAgICBjdXJyX2RhdGEuZHJvcF9kdXBsaWNhdGVzKHN1YnNldD1bJ1F1YWRFdmVudENvZGUnXSwgaW5wbGFjZT1UcnVlKQogICAgY3Vycl9kYXRhID0gY3Vycl9kYXRhW2N1cnJfZGF0YVsnRGF0ZVN0ciddIDw9IERFRkFVTFRfRU5EX0RBVEVdCiAgICBpZiBkYXRlX3JhbmdlOgogICAgICAgIGN1cnJfZGF0YSA9IGN1cnJfZGF0YVsoY3Vycl9kYXRhWydEYXRlU3RyJ10gPj0gZGF0ZV9yYW5nZS5zdGFydF9kYXRlLmRhdGUpICYgKGN1cnJfZGF0YVsnRGF0ZVN0ciddIDw9IGRhdGVfcmFuZ2UuZW5kX2RhdGUuZGF0ZSldCiAgICBpZiBoZWFkX2VudGl0aWVzOgogICAgICAgIGN1cnJfZGF0YSA9IGN1cnJfZGF0YVtjdXJyX2RhdGFbJ0FjdG9yMUNvdW50cnlDb2RlJ10uaXNpbihbaXNvLmNvZGUgZm9yIGlzbyBpbiBoZWFkX2VudGl0aWVzXSldCiAgICBpZiB0YWlsX2VudGl0aWVzOgogICAgICAgIGN1cnJfZGF0YSA9IGN1cnJfZGF0YVtjdXJyX2RhdGFbJ0FjdG9yMkNvdW50cnlDb2RlJ10uaXNpbihbaXNvLmNvZGUgZm9yIGlzbyBpbiB0YWlsX2VudGl0aWVzXSldCiAgICAjIGNvdW50IHRoZSBudW1iZXIgb2YgZXZlbnRzIGZvciBlYWNoIHJlbGF0aW9uCiAgICByZWxhdGlvbl9jb3VudHMgPSBjdXJyX2RhdGFbJ0V2ZW50QmFzZUNvZGUnXS52YWx1ZV9jb3VudHMoKQogICAgcmVsYXRpb25fY291bnRzID0gcmVsYXRpb25fY291bnRzLnRvX2RpY3QoKQogICAgIyBzb3J0IHRoZSBkaWN0aW9uYXJ5IGJ5IHZhbHVlcyBpbiBkZXNjZW5kaW5nIG9yZGVyCiAgICByZWxhdGlvbl9jb3VudHMgPSBkaWN0KHNvcnRlZChyZWxhdGlvbl9jb3VudHMuaXRlbXMoKSwga2V5PWxhbWJkYSBpdGVtOiBpdGVtWzFdLCByZXZlcnNlPVRydWUpKQogICAgcmVsYXRpb25fY291bnRzID0ge0NBTUVPQ29kZShrZXkpOiB2YWx1ZSBmb3Iga2V5LCB2YWx1ZSBpbiByZWxhdGlvbl9jb3VudHMuaXRlbXMoKX0KICAgIHJldHVybiByZWxhdGlvbl9jb3VudHMKCmRlZiBjb3VudF9uZXdzX2FydGljbGVzKGRhdGVfcmFuZ2U6IE9wdGlvbmFsW0RhdGVSYW5nZV0gPSBOb25lLCBoZWFkX2VudGl0aWVzOiBPcHRpb25hbFtMaXN0W0lTT0NvZGVdXSA9IE5vbmUsIHRhaWxfZW50aXRpZXM6IE9wdGlvbmFsW0xpc3RbSVNPQ29kZV1dID0gTm9uZSwgcmVsYXRpb25zOiBPcHRpb25hbFtMaXN0W0NBTUVPQ29kZV1dID0gTm9uZSwga2V5d29yZHM6IE9wdGlvbmFsW0xpc3Rbc3RyXV0gPSBOb25lKSAtPiBpbnQ6CiAgICAiIiIKICAgIENvdW50cyB0aGUgbnVtYmVyIG9mIG5ld3MgYXJ0aWNsZXMgYmFzZWQgb24gc3BlY2lmaWVkIGNvbmRpdGlvbnMuCgogICAgUGFyYW1ldGVyczoKICAgICAgICBkYXRlX3JhbmdlIChPcHRpb25hbFtEYXRlUmFuZ2VdKTogUmFuZ2Ugb2YgZGF0ZXMgdG8gZmlsdGVyIHRoZSBuZXdzIGFydGljbGVzLiBJZiBOb25lLCBhbGwgZGF0ZXMgYXJlIGluY2x1ZGVkLgogICAgICAgIGhlYWRfZW50aXRpZXMgKE9wdGlvbmFsW0xpc3RbSVNPQ29kZV1dKTogQXQgbGVhc3Qgb25lIG9mIHRoZSBlbnRpdGllcyBtdXN0IGJlIG1lbnRpb25lZCBpbiB0aGUgYXJ0aWNsZXMgYW5kIGJlIHRoZSBoZWFkIGVudGl0eSBpbiB0aGUgZXZlbnRzLiBJZiBOb25lLCBhbGwgZW50aXRpZXMgYXJlIGluY2x1ZGVkLgogICAgICAgIHRhaWxfZW50aXRpZXMgKE9wdGlvbmFsW0xpc3RbSVNPQ29kZV1dKTogQXQgbGVhc3Qgb25lIG9mIHRoZSBlbnRpdGllcyBtdXN0IGJlIG1lbnRpb25lZCBpbiB0aGUgYXJ0aWNsZXMgYW5kIGJlIHRoZSB0YWlsIGVudGl0eSBpbiB0aGUgZXZlbnRzLiBJZiBOb25lLCBhbGwgZW50aXRpZXMgYXJlIGluY2x1ZGVkLgogICAgICAgIHJlbGF0aW9ucyAoT3B0aW9uYWxbTGlzdFtDQU1FT0NvZGVdXSk6IEF0IGxlYXN0IG9uZSBvZiB0aGUgcmVsYXRpb25zIG11c3QgYmUgbWVudGlvbmVkIGluIHRoZSBhcnRpY2xlcy4gSWYgZmlyc3QgbGV2ZWwgcmVsYXRpb25zIGFyZSBsaXN0ZWQsIGFsbCBzZWNvbmQgbGV2ZWwgcmVsYXRpb25zIHVuZGVyIHRoZW0gYXJlIGluY2x1ZGVkLiBJZiBOb25lLCBhbGwgcmVsYXRpb25zIGFyZSBpbmNsdWRlZC4KICAgICAgICBrZXl3b3JkcyAoT3B0aW9uYWxbTGlzdFtzdHJdXSk6IEF0IGxlYXN0IG9uZSBvZiB0aGUga2V5d29yZHMgbXVzdCBiZSBwcmVzZW50IGluIHRoZSBhcnRpY2xlcy4gSWYgTm9uZSwgYWxsIGFydGljbGVzIGFyZSBpbmNsdWRlZC4KCiAgICBSZXR1cm5zOgogICAgICAgIGludDogVGhlIGNvdW50IG9mIG5ld3MgYXJ0aWNsZXMgbWF0Y2hpbmcgdGhlIGNvbmRpdGlvbnMuCgogICAgRXhhbXBsZToKICAgICAgICA+Pj4gY291bnRfbmV3c19hcnRpY2xlcyhkYXRlX3JhbmdlPURhdGVSYW5nZShzdGFydF9kYXRlPURhdGUoIjIwMjItMDEtMDEiKSwgZW5kX2RhdGU9RGF0ZSgiMjAyMi0wMS0zMSIpKSwgaGVhZF9lbnRpdGllcz1bSVNPQ29kZSgiVVNBIiksIElTT0NvZGUoIkNITiIpXSwgdGFpbF9lbnRpdGllcz1bSVNPQ29kZSgiVVNBIiksIElTT0NvZGUoIkNITiIpXSwgcmVsYXRpb25zPVtDQU1FT0NvZGUoIjAxMCIpXSwga2V5d29yZHM9WyJ0cmFkZSJdKQogICAgICAgIDIKICAgICIiIgogICAgIyBjaGVjayB0eXBlCiAgICBpZiBkYXRlX3JhbmdlIGFuZCBub3QgaXNpbnN0YW5jZShkYXRlX3JhbmdlLCBEYXRlUmFuZ2UpOgogICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoZiJJbnB1dCAnZGF0ZV9yYW5nZScgbXVzdCBiZSBhIERhdGVSYW5nZSBvYmplY3QsIGJ1dCByZWNlaXZlZCB0eXBlIHt0eXBlKGRhdGVfcmFuZ2UpfSIpCiAgICBpZiBoZWFkX2VudGl0aWVzIGFuZCBub3QgaXNpbnN0YW5jZShoZWFkX2VudGl0aWVzLCBsaXN0KToKICAgICAgICByYWlzZSBWYWx1ZUVycm9yKGYiSW5wdXQgJ2hlYWRfZW50aXRpZXMnIG11c3QgYmUgYSBsaXN0LCBidXQgcmVjZWl2ZWQgdHlwZSB7dHlwZShoZWFkX2VudGl0aWVzKX0iKQogICAgaWYgaGVhZF9lbnRpdGllcyBhbmQgbm90IGFsbChpc2luc3RhbmNlKGlzbywgSVNPQ29kZSkgZm9yIGlzbyBpbiBoZWFkX2VudGl0aWVzKToKICAgICAgICByYWlzZSBWYWx1ZUVycm9yKGYiRWxlbWVudHMgaW4gJ2hlYWRfZW50aXRpZXMnIG11c3QgYmUgSVNPQ29kZSBvYmplY3RzIikKICAgIGlmIHRhaWxfZW50aXRpZXMgYW5kIG5vdCBpc2luc3RhbmNlKHRhaWxfZW50aXRpZXMsIGxpc3QpOgogICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoZiJJbnB1dCAndGFpbF9lbnRpdGllcycgbXVzdCBiZSBhIGxpc3QsIGJ1dCByZWNlaXZlZCB0eXBlIHt0eXBlKHRhaWxfZW50aXRpZXMpfSIpCiAgICBpZiB0YWlsX2VudGl0aWVzIGFuZCBub3QgYWxsKGlzaW5zdGFuY2UoaXNvLCBJU09Db2RlKSBmb3IgaXNvIGluIHRhaWxfZW50aXRpZXMpOgogICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoZiJFbGVtZW50cyBpbiAndGFpbF9lbnRpdGllcycgbXVzdCBiZSBJU09Db2RlIG9iamVjdHMiKQogICAgaWYgcmVsYXRpb25zIGFuZCBub3QgaXNpbnN0YW5jZShyZWxhdGlvbnMsIGxpc3QpOgogICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoZiJJbnB1dCAncmVsYXRpb25zJyBtdXN0IGJlIGEgbGlzdCwgYnV0IHJlY2VpdmVkIHR5cGUge3R5cGUocmVsYXRpb25zKX0iKQogICAgaWYgcmVsYXRpb25zIGFuZCBub3QgYWxsKGlzaW5zdGFuY2UoY29kZSwgQ0FNRU9Db2RlKSBmb3IgY29kZSBpbiByZWxhdGlvbnMpOgogICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoZiJFbGVtZW50cyBpbiAncmVsYXRpb25zJyBtdXN0IGJlIENBTUVPQ29kZSBvYmplY3RzIikKICAgIGlmIGtleXdvcmRzIGFuZCBub3QgaXNpbnN0YW5jZShrZXl3b3JkcywgbGlzdCk6CiAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmIklucHV0ICdrZXl3b3JkcycgbXVzdCBiZSBhIGxpc3QsIGJ1dCByZWNlaXZlZCB0eXBlIHt0eXBlKGtleXdvcmRzKX0iKQogICAgaWYga2V5d29yZHMgYW5kIG5vdCBhbGwoaXNpbnN0YW5jZShrZXl3b3JkLCBzdHIpIGZvciBrZXl3b3JkIGluIGtleXdvcmRzKToKICAgICAgICByYWlzZSBWYWx1ZUVycm9yKGYiRWxlbWVudHMgaW4gJ2tleXdvcmRzJyBtdXN0IGJlIHN0cmluZ3MiKQoKICAgICMgcHJvY2VzcyBkYXRhX2tnIGJ5IGZpbHRlcmluZyBiYXNlZCBvbiB0aGUgc3BlY2lmaWVkIGNvbmRpdGlvbnMKICAgIGN1cnJfZGF0YSA9IGRhdGFfa2cuY29weSgpCiAgICBjdXJyX2RhdGEuZHJvcF9kdXBsaWNhdGVzKHN1YnNldD1bJ1F1YWRFdmVudENvZGUnXSwgaW5wbGFjZT1UcnVlKQogICAgY3Vycl9kYXRhID0gY3Vycl9kYXRhW2N1cnJfZGF0YVsnRGF0ZVN0ciddIDw9IERFRkFVTFRfRU5EX0RBVEVdCiAgICBpZiBkYXRlX3JhbmdlOgogICAgICAgIGN1cnJfZGF0YSA9IGN1cnJfZGF0YVsoY3Vycl9kYXRhWydEYXRlU3RyJ10gPj0gZGF0ZV9yYW5nZS5zdGFydF9kYXRlLmRhdGUpICYgKGN1cnJfZGF0YVsnRGF0ZVN0ciddIDw9IGRhdGVfcmFuZ2UuZW5kX2RhdGUuZGF0ZSldCiAgICBpZiBoZWFkX2VudGl0aWVzOgogICAgICAgIGN1cnJfZGF0YSA9IGN1cnJfZGF0YVtjdXJyX2RhdGFbJ0FjdG9yMUNvdW50cnlDb2RlJ10uaXNpbihbaXNvLmNvZGUgZm9yIGlzbyBpbiBoZWFkX2VudGl0aWVzXSldCiAgICBpZiB0YWlsX2VudGl0aWVzOgogICAgICAgIGN1cnJfZGF0YSA9IGN1cnJfZGF0YVtjdXJyX2RhdGFbJ0FjdG9yMkNvdW50cnlDb2RlJ10uaXNpbihbaXNvLmNvZGUgZm9yIGlzbyBpbiB0YWlsX2VudGl0aWVzXSldCiAgICBpZiByZWxhdGlvbnM6CiAgICAgICAgIyBpZiBmaXJzdCBsZXZlbCByZWxhdGlvbnMgYXJlIGxpc3RlZCwgaW5jbHVkZSBhbGwgc2Vjb25kIGxldmVsIHJlbGF0aW9ucyB1bmRlciB0aGVtCiAgICAgICAgZm9yIGNvZGUgaW4gcmVsYXRpb25zOgogICAgICAgICAgICBpZiBsZW4oY29kZS5jb2RlKSA9PSAyOgogICAgICAgICAgICAgICAgcmVsYXRpb25zLmV4dGVuZChbQ0FNRU9Db2RlKGMpIGZvciBjIGluIGRpY3RfY29kZTJyZWxhdGlvbiBpZiBjWzoyXSA9PSBjb2RlLmNvZGUgYW5kIGxlbihjKSA9PSAzXSkKICAgICAgICBjdXJyX2RhdGEgPSBjdXJyX2RhdGFbY3Vycl9kYXRhWydFdmVudEJhc2VDb2RlJ10uaXNpbihbY29kZS5jb2RlIGZvciBjb2RlIGluIHJlbGF0aW9uc10pXQogICAgIyBjb25jYXQgdGhlIERvY2lkcyBsaXN0IG9mIGN1cnJlbnQgZGF0YSB0byBnZXQgdGhlIG5ld3MgYXJ0aWNsZXMKICAgIGRvY2lkc19saXN0ID0gW2V2YWwoZG9jaWRzKSBmb3IgZG9jaWRzIGluIGN1cnJfZGF0YVsnRG9jaWRzJ10udW5pcXVlKCkudG9saXN0KCldCiAgICBkb2NpZHMgPSBsaXN0KHNldChbaXRlbSBmb3Igc3VibGlzdCBpbiBkb2NpZHNfbGlzdCBmb3IgaXRlbSBpbiBzdWJsaXN0XSkpCiAgICBkb2NpZHMgPSBbc3RyKGRvY2lkKSBmb3IgZG9jaWQgaW4gZG9jaWRzXQogICAgbmV3c19hcnRpY2xlcyA9IGRhdGFfbmV3c1tkYXRhX25ld3NbJ0RvY2lkJ10uaXNpbihkb2NpZHMpXQogICAgaWYga2V5d29yZHM6CiAgICAgICAgIyBmaWx0ZXIgdGhlIG5ld3MgYXJ0aWNsZXMgdGhhdCBjb250YWluIGF0IGxlYXN0IG9uZSBvZiB0aGUga2V5d29yZHMgaW4gdGhlIHRpdGxlIG9yIHRleHQgc3RyaW5nCiAgICAgICAgbmV3c19hcnRpY2xlcyA9IG5ld3NfYXJ0aWNsZXNbbmV3c19hcnRpY2xlc1snVGl0bGUnXS5zdHIuY29udGFpbnMoJ3wnLmpvaW4oa2V5d29yZHMpLCBjYXNlPUZhbHNlKSB8IG5ld3NfYXJ0aWNsZXNbJ1RleHQnXS5zdHIuY29udGFpbnMoJ3wnLmpvaW4oa2V5d29yZHMpLCBjYXNlPUZhbHNlKV0KICAgIHJldHVybiBsZW4obmV3c19hcnRpY2xlcykKCmRlZiBnZXRfbmV3c19hcnRpY2xlcyhkYXRlX3JhbmdlOiBPcHRpb25hbFtEYXRlUmFuZ2VdID0gTm9uZSwgaGVhZF9lbnRpdGllczogT3B0aW9uYWxbTGlzdFtJU09Db2RlXV0gPSBOb25lLCB0YWlsX2VudGl0aWVzOiBPcHRpb25hbFtMaXN0W0lTT0NvZGVdXSA9IE5vbmUsIHJlbGF0aW9uczogT3B0aW9uYWxbTGlzdFtDQU1FT0NvZGVdXSA9IE5vbmUsIGtleXdvcmRzOiBPcHRpb25hbFtMaXN0W3N0cl1dID0gTm9uZSwgdGV4dF9kZXNjcmlwdGlvbjogT3B0aW9uYWxbc3RyXSA9IE5vbmUpIC0+IExpc3RbVHVwbGVbRGF0ZSwgc3RyXV06CiAgICAiIiIKICAgIFJldHJpZXZlcyBuZXdzIGFydGljbGVzIGJhc2VkIG9uIHNwZWNpZmllZCBjb25kaXRpb25zLgogICAgSW5oZXJpdHMgY29tbW9uIGZpbHRlciBwYXJhbWV0ZXJzIGZyb20gY291bnRfbmV3c19hcnRpY2xlcy4gU2VlIGNvdW50X25ld3NfYXJ0aWNsZXMgZm9yIG1vcmUgZGV0YWlscyBvbiB0aGVzZSBwYXJhbWV0ZXJzLgoKICAgIEFkZGl0aW9uYWwgUGFyYW1ldGVyczoKICAgICAgICB0ZXh0X2Rlc2NyaXB0aW9uIChPcHRpb25hbFtzdHJdKTogVGV4dHVhbCBkZXNjcmlwdGlvbiB0byBtYXRjaCB3aXRoIHRoZSBuZXdzIGFydGljbGVzLiBJZiBOb25lLCB0aGUgcmV0dXJuZWQgYXJ0aWNsZXMgYXJlIHNvcnRlZCBieSBkYXRlIGluIGRlc2NlbmRpbmcgb3JkZXI7IG90aGVyd2lzZSwgc29ydGVkIGJ5IHJlbGV2YW5jZSB0byB0aGUgZGVzY3JpcHRpb24uCgogICAgUmV0dXJuczoKICAgICAgICBMaXN0W1R1cGxlW0RhdGUsIHN0cl1dOiBBIGxpc3Qgb2YgbWF4aW11bSAxNSBuZXdzIGFydGljbGVzIG1hdGNoaW5nIHRoZSBzcGVjaWZpZWQgY29uZGl0aW9ucywgZWFjaCByZXByZXNlbnRlZCBieSBhIHR1cGxlIG9mIGRhdGUgYW5kIHRpdGxlLgoKICAgIEV4YW1wbGU6CiAgICAgICAgPj4+IGdldF9uZXdzX2FydGljbGVzKGRhdGVfcmFuZ2U9RGF0ZVJhbmdlKHN0YXJ0X2RhdGU9RGF0ZSgiMjAyMi0wMS0wMSIpLCBlbmRfZGF0ZT1EYXRlKCIyMDIyLTAxLTMxIikpLCBoZWFkX2VudGl0aWVzPVtJU09Db2RlKCJVU0EiKSwgSVNPQ29kZSgiQ0hOIildLCB0YWlsX2VudGl0aWVzPVtJU09Db2RlKCJVU0EiKSwgSVNPQ29kZSgiQ0hOIildLCByZWxhdGlvbnM9W0NBTUVPQ29kZSgiMDEwIildLCBrZXl3b3Jkcz1bInRyYWRlIl0sIHRleHRfZGVzY3JpcHRpb249IkVjb25vbWljIHRyYWRlIGlzIGVuY291cmFnZWQgYmV0d2VlbiBVU0EgYW5kIENoaW5hLiIpCiAgICAgICAgWyhOZXdzQXJ0aWNsZS5kYXRlPURhdGUoIjIwMjItMDEtMTUiKSwgTmV3c0FydGljbGUudGl0bGU9IkNoaW5hIGFuZCBVU0Egc2lnbiB0cmFkZSBkZWFsIiksIChOZXdzQXJ0aWNsZS5kYXRlPURhdGUoIjIwMjItMDEtMTAiKSwgTmV3c0FydGljbGUudGl0bGU9IlRyYWRlIGFncmVlbWVudCBiZXR3ZWVuIFVTQSBhbmQgQ2hpbmEiKV0KICAgICIiIgogICAgIyBjaGVjayB0eXBlCiAgICBpZiBkYXRlX3JhbmdlIGFuZCBub3QgaXNpbnN0YW5jZShkYXRlX3JhbmdlLCBEYXRlUmFuZ2UpOgogICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoZiJJbnB1dCAnZGF0ZV9yYW5nZScgbXVzdCBiZSBhIERhdGVSYW5nZSBvYmplY3QsIGJ1dCByZWNlaXZlZCB0eXBlIHt0eXBlKGRhdGVfcmFuZ2UpfSIpCiAgICBpZiBoZWFkX2VudGl0aWVzIGFuZCBub3QgaXNpbnN0YW5jZShoZWFkX2VudGl0aWVzLCBsaXN0KToKICAgICAgICByYWlzZSBWYWx1ZUVycm9yKGYiSW5wdXQgJ2hlYWRfZW50aXRpZXMnIG11c3QgYmUgYSBsaXN0LCBidXQgcmVjZWl2ZWQgdHlwZSB7dHlwZShoZWFkX2VudGl0aWVzKX0iKQogICAgaWYgaGVhZF9lbnRpdGllcyBhbmQgbm90IGFsbChpc2luc3RhbmNlKGlzbywgSVNPQ29kZSkgZm9yIGlzbyBpbiBoZWFkX2VudGl0aWVzKToKICAgICAgICByYWlzZSBWYWx1ZUVycm9yKGYiRWxlbWVudHMgaW4gJ2hlYWRfZW50aXRpZXMnIG11c3QgYmUgSVNPQ29kZSBvYmplY3RzIikKICAgIGlmIHRhaWxfZW50aXRpZXMgYW5kIG5vdCBpc2luc3RhbmNlKHRhaWxfZW50aXRpZXMsIGxpc3QpOgogICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoZiJJbnB1dCAndGFpbF9lbnRpdGllcycgbXVzdCBiZSBhIGxpc3QsIGJ1dCByZWNlaXZlZCB0eXBlIHt0eXBlKHRhaWxfZW50aXRpZXMpfSIpCiAgICBpZiB0YWlsX2VudGl0aWVzIGFuZCBub3QgYWxsKGlzaW5zdGFuY2UoaXNvLCBJU09Db2RlKSBmb3IgaXNvIGluIHRhaWxfZW50aXRpZXMpOgogICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoZiJFbGVtZW50cyBpbiAndGFpbF9lbnRpdGllcycgbXVzdCBiZSBJU09Db2RlIG9iamVjdHMiKQogICAgaWYgcmVsYXRpb25zIGFuZCBub3QgaXNpbnN0YW5jZShyZWxhdGlvbnMsIGxpc3QpOgogICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoZiJJbnB1dCAncmVsYXRpb25zJyBtdXN0IGJlIGEgbGlzdCwgYnV0IHJlY2VpdmVkIHR5cGUge3R5cGUocmVsYXRpb25zKX0iKQogICAgaWYgcmVsYXRpb25zIGFuZCBub3QgYWxsKGlzaW5zdGFuY2UoY29kZSwgQ0FNRU9Db2RlKSBmb3IgY29kZSBpbiByZWxhdGlvbnMpOgogICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoZiJFbGVtZW50cyBpbiAncmVsYXRpb25zJyBtdXN0IGJlIENBTUVPQ29kZSBvYmplY3RzIikKICAgIGlmIGtleXdvcmRzIGFuZCBub3QgaXNpbnN0YW5jZShrZXl3b3JkcywgbGlzdCk6CiAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmIklucHV0ICdrZXl3b3JkcycgbXVzdCBiZSBhIGxpc3QsIGJ1dCByZWNlaXZlZCB0eXBlIHt0eXBlKGtleXdvcmRzKX0iKQogICAgaWYga2V5d29yZHMgYW5kIG5vdCBhbGwoaXNpbnN0YW5jZShrZXl3b3JkLCBzdHIpIGZvciBrZXl3b3JkIGluIGtleXdvcmRzKToKICAgICAgICByYWlzZSBWYWx1ZUVycm9yKGYiRWxlbWVudHMgaW4gJ2tleXdvcmRzJyBtdXN0IGJlIHN0cmluZ3MiKQogICAgaWYgdGV4dF9kZXNjcmlwdGlvbiBhbmQgbm90IGlzaW5zdGFuY2UodGV4dF9kZXNjcmlwdGlvbiwgc3RyKToKICAgICAgICByYWlzZSBWYWx1ZUVycm9yKGYiSW5wdXQgJ3RleHRfZGVzY3JpcHRpb24nIG11c3QgYmUgYSBzdHJpbmcsIGJ1dCByZWNlaXZlZCB0eXBlIHt0eXBlKHRleHRfZGVzY3JpcHRpb24pfSIpCgogICAgIyBwcm9jZXNzIGRhdGFfa2cgYnkgZmlsdGVyaW5nIGJhc2VkIG9uIHRoZSBzcGVjaWZpZWQgY29uZGl0aW9ucwogICAgY3Vycl9kYXRhID0gZGF0YV9rZy5jb3B5KCkKICAgIGN1cnJfZGF0YS5kcm9wX2R1cGxpY2F0ZXMoc3Vic2V0PVsnUXVhZEV2ZW50Q29kZSddLCBpbnBsYWNlPVRydWUpCiAgICBjdXJyX2RhdGEgPSBjdXJyX2RhdGFbY3Vycl9kYXRhWydEYXRlU3RyJ10gPD0gREVGQVVMVF9FTkRfREFURV0KICAgIGlmIGRhdGVfcmFuZ2U6CiAgICAgICAgY3Vycl9kYXRhID0gY3Vycl9kYXRhWwogICAgICAgICAgICAoY3Vycl9kYXRhWydEYXRlU3RyJ10gPj0gZGF0ZV9yYW5nZS5zdGFydF9kYXRlLmRhdGUpICYgKGN1cnJfZGF0YVsnRGF0ZVN0ciddIDw9IGRhdGVfcmFuZ2UuZW5kX2RhdGUuZGF0ZSldCiAgICBpZiBoZWFkX2VudGl0aWVzOgogICAgICAgIGN1cnJfZGF0YSA9IGN1cnJfZGF0YVtjdXJyX2RhdGFbJ0FjdG9yMUNvdW50cnlDb2RlJ10uaXNpbihbaXNvLmNvZGUgZm9yIGlzbyBpbiBoZWFkX2VudGl0aWVzXSldCiAgICBpZiB0YWlsX2VudGl0aWVzOgogICAgICAgIGN1cnJfZGF0YSA9IGN1cnJfZGF0YVtjdXJyX2RhdGFbJ0FjdG9yMkNvdW50cnlDb2RlJ10uaXNpbihbaXNvLmNvZGUgZm9yIGlzbyBpbiB0YWlsX2VudGl0aWVzXSldCiAgICBpZiByZWxhdGlvbnM6CiAgICAgICAgIyBpZiBmaXJzdCBsZXZlbCByZWxhdGlvbnMgYXJlIGxpc3RlZCwgaW5jbHVkZSBhbGwgc2Vjb25kIGxldmVsIHJlbGF0aW9ucyB1bmRlciB0aGVtCiAgICAgICAgZm9yIGNvZGUgaW4gcmVsYXRpb25zOgogICAgICAgICAgICBpZiBsZW4oY29kZS5jb2RlKSA9PSAyOgogICAgICAgICAgICAgICAgcmVsYXRpb25zLmV4dGVuZChbQ0FNRU9Db2RlKGMpIGZvciBjIGluIGRpY3RfY29kZTJyZWxhdGlvbiBpZiBjWzoyXSA9PSBjb2RlLmNvZGUgYW5kIGxlbihjKSA9PSAzXSkKICAgICAgICBjdXJyX2RhdGEgPSBjdXJyX2RhdGFbY3Vycl9kYXRhWydFdmVudEJhc2VDb2RlJ10uaXNpbihbY29kZS5jb2RlIGZvciBjb2RlIGluIHJlbGF0aW9uc10pXQogICAgZG9jaWRzX2xpc3QgPSBbZXZhbChkb2NpZHMpIGZvciBkb2NpZHMgaW4gY3Vycl9kYXRhWydEb2NpZHMnXS51bmlxdWUoKS50b2xpc3QoKV0KICAgIGRvY2lkcyA9IGxpc3Qoc2V0KFtpdGVtIGZvciBzdWJsaXN0IGluIGRvY2lkc19saXN0IGZvciBpdGVtIGluIHN1Ymxpc3RdKSkKICAgIGRvY2lkcyA9IFtzdHIoZG9jaWQpIGZvciBkb2NpZCBpbiBkb2NpZHNdCiAgICBuZXdzX2FydGljbGVzID0gZGF0YV9uZXdzW2RhdGFfbmV3c1snRG9jaWQnXS5pc2luKGRvY2lkcyldCiAgICBpZiBrZXl3b3JkczoKICAgICAgICAjIGZpbHRlciB0aGUgbmV3cyBhcnRpY2xlcyB0aGF0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIG9mIHRoZSBrZXl3b3JkcyBpbiB0aGUgdGl0bGUgb3IgdGV4dCBzdHJpbmcKICAgICAgICBuZXdzX2FydGljbGVzID0gbmV3c19hcnRpY2xlc1tuZXdzX2FydGljbGVzWydUaXRsZSddLnN0ci5jb250YWlucygnfCcuam9pbihrZXl3b3JkcyksIGNhc2U9RmFsc2UpIHwgbmV3c19hcnRpY2xlc1snVGV4dCddLnN0ci5jb250YWlucygnfCcuam9pbihrZXl3b3JkcyksIGNhc2U9RmFsc2UpXQogICAgaWYgbm90IHRleHRfZGVzY3JpcHRpb246CiAgICAgICAgIyBnZXQgbWF4IDE1IG5ld3MgYXJ0aWNsZXMgZnJvbSB0aGUgZmlsdGVyZWQgZGF0YQogICAgICAgICMgc29ydGVkIGJ5IGRhdGUgaW4gZGVzY2VuZGluZyBvcmRlcgogICAgICAgIG5ld3NfYXJ0aWNsZXMuc29ydF92YWx1ZXMoYnk9J0RhdGUnLCBhc2NlbmRpbmc9RmFsc2UsIGlucGxhY2U9VHJ1ZSkKICAgICAgICBuZXdzX2FydGljbGVzID0gbmV3c19hcnRpY2xlc1tbJ0RhdGUnLCAnVGl0bGUnXV0uaGVhZCgxNSkKICAgICAgICByZXR1cm4gWyhEYXRlKHJvd1snRGF0ZSddKSwgcm93WydUaXRsZSddKSBmb3IgXywgcm93IGluIG5ld3NfYXJ0aWNsZXMuaXRlcnJvd3MoKV0KICAgIGVsc2U6CiAgICAgICAgIyBnZXQgdGhlIG1heCAxNSBuZXdzIGFydGljbGVzIHdpdGggdGhlIGhpZ2hlc3QgQk0yNSBzY29yZSB0byB0aGUgdGV4dF9kZXNjcmlwdGlvbgogICAgICAgIGNvcnB1cyA9IG5ld3NfYXJ0aWNsZXNbJ1RpdGxlJ10gKyAnICcgKyBuZXdzX2FydGljbGVzWydUZXh0J10KICAgICAgICB0b2tlbml6ZWRfY29ycHVzID0gW2RvYy5zcGxpdCgiICIpIGZvciBkb2MgaW4gY29ycHVzXQogICAgICAgIGJtMjUgPSBCTTI1T2thcGkodG9rZW5pemVkX2NvcnB1cykKICAgICAgICB0b2tlbml6ZWRfcXVlcnkgPSB0ZXh0X2Rlc2NyaXB0aW9uLnNwbGl0KCIgIikKICAgICAgICBkb2Nfc2NvcmVzID0gYm0yNS5nZXRfc2NvcmVzKHRva2VuaXplZF9xdWVyeSkKICAgICAgICB0b3BfaW5kaWNlcyA9IG5wLmFyZ3NvcnQoZG9jX3Njb3JlcylbOjotMV1bOjE1XQogICAgICAgIG5ld3NfYXJ0aWNsZXMgPSBuZXdzX2FydGljbGVzLmlsb2NbdG9wX2luZGljZXNdCiAgICAgICAgcmV0dXJuIFsoRGF0ZShyb3dbJ0RhdGUnXSksIHJvd1snVGl0bGUnXSkgZm9yIF8sIHJvdyBpbiBuZXdzX2FydGljbGVzLml0ZXJyb3dzKCldCgpkZWYgYnJvd3NlX25ld3NfYXJ0aWNsZShkYXRlOiBEYXRlLCB0aXRsZTogc3RyKSAtPiBzdHI6CiAgICAiIiIKICAgIFJldHJpZXZlcyB0aGUgZnVsbCB0ZXh0IG9mIGEgbmV3cyBhcnRpY2xlIGJ5IGl0cyB0aXRsZS4KCiAgICBQYXJhbWV0ZXJzOgogICAgICAgIGRhdGUgKERhdGUpOiBUaGUgZGF0ZSBvZiB0aGUgbmV3cyBhcnRpY2xlIHRvIHJldHJpZXZlLgogICAgICAgIHRpdGxlIChzdHIpOiBUaGUgdGl0bGUgb2YgdGhlIG5ld3MgYXJ0aWNsZSB0byByZXRyaWV2ZS4KCiAgICBSZXR1cm5zOgogICAgICAgIHN0cjogVGhlIGRhdGUsIHRoZSB0aXRsZSBhbmQgZnVsbCBjb250ZW50cyBvZiB0aGUgbmV3cyBhcnRpY2xlLgoKICAgIEV4YW1wbGU6CiAgICAgICAgPj4+IGJyb3dzZV9uZXdzX2FydGljbGUoRGF0ZSgiMjAyMi0wMS0xMCIpLCAiVHJhZGUgYWdyZWVtZW50IGJldHdlZW4gVVNBIGFuZCBDaGluYSIpCiAgICAgICAgMjAyMi0wMS0xMDoKICAgICAgICBUcmFkZSBhZ3JlZW1lbnQgYmV0d2VlbiBVU0EgYW5kIENoaW5hCiAgICAgICAgT24gSmFudWFyeSAxMCwgMjAyMiwgYSB0cmFkZSBhZ3JlZW1lbnQgd2FzIHNpZ25lZCBiZXR3ZWVuIHRoZSBVU0EgYW5kIENoaW5hIHRvIHByb21vdGUgZWNvbm9taWMgY29vcGVyYXRpb24uLi4KICAgICIiIgogICAgIyBjaGVjayB0eXBlCiAgICBpZiBub3QgaXNpbnN0YW5jZShkYXRlLCBEYXRlKToKICAgICAgICByYWlzZSBWYWx1ZUVycm9yKGYiSW5wdXQgJ2RhdGUnIG11c3QgYmUgYSBEYXRlIG9iamVjdCwgYnV0IHJlY2VpdmVkIHR5cGUge3R5cGUoZGF0ZSl9IikKICAgIGlmIG5vdCBpc2luc3RhbmNlKHRpdGxlLCBzdHIpOgogICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoZiJJbnB1dCAndGl0bGUnIG11c3QgYmUgYSBzdHJpbmcsIGJ1dCByZWNlaXZlZCB0eXBlIHt0eXBlKHRpdGxlKX0iKQoKICAgICMgcHJvY2VzcyBkYXRhX25ld3MgdG8gZmluZCB0aGUgbmV3cyBhcnRpY2xlIHdpdGggdGhlIHNwZWNpZmllZCBkYXRlIGFuZCB0aXRsZQogICAgY3Vycl9kYXRhID0gZGF0YV9uZXdzWyhkYXRhX25ld3NbJ0RhdGUnXSA9PSBkYXRlLmRhdGUpICYgKGRhdGFfbmV3c1snVGl0bGUnXSA9PSB0aXRsZSldCiAgICBpZiBsZW4oY3Vycl9kYXRhKSA9PSAwOgogICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoZiJObyBuZXdzIGFydGljbGUgZm91bmQgd2l0aCB0aGUgc3BlY2lmaWVkIGRhdGUge2RhdGUuZGF0ZX0gYW5kIHRpdGxlIHt0aXRsZX0iKQogICAgcmV0dXJuIGYie2RhdGV9Olxue3RpdGxlfVxue2N1cnJfZGF0YVsnVGV4dCddLnZhbHVlc1swXX0i)1@dataclass2class  Date:3  """Represents  a  date."""4  date:  str  #  Date  in  the  format  ’YYYY-MM-DD’5  #  Example:  Date("2022-01-01")67  def  __init__(self,  date:  str):8  #  check  type9  if  not  isinstance(date,  str):10  raise  ValueError(f"Attribute  ’date’  of  class  Date  must  be  a  string  in  the  format  ’YYYY-MM-DD’,  but  received:  {date}  in  type  {type(date)}")1112  #  check  if  date  is  in  the  correct  format  by  trying  to  convert  it  to  a  date  object13  try:14  datetime.datetime.strptime(date,  ’%Y-%m-%d’)15  except  ValueError:16  raise  ValueError(f"Date  must  be  in  the  format  ’YYYY-MM-DD’,  but  received:  {date}")17  if  date  <  DEFAULT_START_DATE:18  raise  ValueError(f"Date  must  be  on  or  after  {DEFAULT_START_DATE},  but  received:  {date}")19  if  DEFAULT_END_DATE  and  date  >  DEFAULT_END_DATE:20  raise  ValueError(f"Date  must  be  on  or  before  the  current  date  {DEFAULT_END_DATE},  but  received:  {date}")2122  self.date  =  date2324  def  __str__(self):25  return  f"Date(’{self.date}’)"2627  def  __hash__(self):28  return  hash(self.date)2930  def  __eq__(self,  other):31  if  isinstance(other,  Date):32  return  self.date  ==  other.date33  return  False3435@dataclass36class  DateRange:37  """Represents  a  range  of  dates  (inclusive)."""38  start_date:  Optional[Date]  #  If  None,  the  earliest  date  is  used39  end_date:  Optional[Date]  #  If  None,  the  current  date  is  used40  #  Example:  DateRange(start_date=Date("2022-01-01"),  end_date=Date("2022-01-31"))4142  def  __init__(self,  start_date:  Optional[Date]  =  None,  end_date:  Optional[Date]  =  None):43  #  check  type44  if  start_date  and  not  isinstance(start_date,  Date):45  raise  ValueError(f"Attribute  ’start_date’  of  class  DateRange  must  be  a  Date  object,  but  received  type  {type(start_date)}")46  if  end_date  and  not  isinstance(end_date,  Date):47  raise  ValueError(f"Attribute  ’end_date’  of  class  DateRange  must  be  a  Date  object,  but  received  type  {type(end_date)}")4849  self.start_date  =  start_date  if  start_date  else  Date(DEFAULT_START_DATE)50  self.end_date  =  end_date  if  end_date  else  Date(DEFAULT_END_DATE)51  if  start_date  and  end_date  and  start_date.date  >  end_date.date:52  raise  ValueError("Start  date  must  be  before  or  equal  to  end  date,  but  received:  start_date={},  end_date={}".format(start_date.date,  end_date.date))5354  def  __str__(self):55  return  f"DateRange(start_date={self.start_date},  end_date={self.end_date})"5657  def  __hash__(self):58  return  hash((self.start_date,  self.end_date))5960  def  __eq__(self,  other):61  if  isinstance(other,  DateRange):62  return  self.start_date  ==  other.start_date  and  self.end_date  ==  other.end_date63  return  False6465@dataclass66class  ISOCode:67  """Represents  an  ISO  alpha-3  country  code."""68  code:  str  #  3-letter  ISO  code69  #  Example:  ISOCode("USA")7071  def  __init__(self,  code:  str):72  #  check  type73  if  not  isinstance(code,  str):74  raise  ValueError(f"Attribute  ’code’  of  class  ISOCode  must  be  a  string,  but  received  type  {type(code)}")7576  if  len(code)  !=  3:77  raise  ValueError(f"ISO  code  must  be  a  3-letter  string,  but  received:  {code}")78  if  code  not  in  dict_iso2alternames:79  raise  ValueError(f"ISO  code  must  be  a  valid  ISO  alpha-3  country  code,  but  received:  {code}")80  self.code  =  code8182  def  __str__(self):83  return  f"ISOCode(’{self.code}’)"8485  def  __hash__(self):86  return  hash(self.code)8788  def  __eq__(self,  other):89  if  isinstance(other,  ISOCode):90  return  self.code  ==  other.code91  return  False9293@dataclass94class  Country:95  """Represents  a  country  entity."""96  iso_code:  ISOCode97  name:  str98  #  Example:  Country(iso_code=ISOCode("USA"),  name="United  States")99100  def  __init__(self,  iso_code:  ISOCode,  name:  str):101  #  check  type102  if  not  isinstance(iso_code,  ISOCode):103  raise  ValueError(f"Attribute  ’iso_code’  of  class  Country  must  be  an  ISOCode  object,  but  received  type  {type(iso_code)}")104  if  not  isinstance(name,  str):105  raise  ValueError(f"Attribute  ’name’  of  class  Country  must  be  a  string,  but  received  type  {type(name)}")106107  if  dict_iso2alternames[iso_code.code][0]  !=  name:108  raise  ValueError(f"Country  name  must  match  the  name  corresponding  to  the  ISO  code,  but  received:  {name}  for  ISO  code:  {iso_code.code}")109  self.iso_code  =  iso_code110  self.name  =  name111112  def  __str__(self):113  return  f"Country(iso_code={self.iso_code},  name=’{self.name}’)"114115  def  __hash__(self):116  return  hash((self.iso_code,  self.name))117118  def  __eq__(self,  other):119  if  isinstance(other,  Country):120  return  self.iso_code  ==  other.iso_code  and  self.name  ==  other.name121  return  False122123@dataclass124class  CAMEOCode:125  """Represents  a  CAMEO  verb  code."""126  code:  str  #  2-digit  CAMEO  code  for  first  level  relations,  3-digit  CAMEO  code  for  second  level  relations127  #  Example:  CAMEOCode("01"),  CAMEOCode("010")128129  def  __init__(self,  code:  str):130  #  check  type131  if  not  isinstance(code,  str):132  raise  ValueError(f"Attribute  ’code’  of  class  CAMEOCode  must  be  a  string,  but  received  type  {type(code)}")133134  if  len(code)  not  in  [2,  3]:135  raise  ValueError(f"CAMEO  code  must  be  a  valid  2  or  3-digit  string  defined  in  the  ’Conflict  and  Mediation  Event  Observations’  Codebook,  but  received:  {code}")136  if  code  not  in  dict_code2relation:137  raise  ValueError(f"CAMEO  code  must  be  a  valid  CAMEO  code  defined  in  the  ’Conflict  and  Mediation  Event  Observations’  Codebook,  but  received:  {code}")138  self.code  =  code139140  def  __str__(self):141  return  f"CAMEOCode(’{self.code}’)"142143  def  __hash__(self):144  return  hash(self.code)145146  def  __eq__(self,  other):147  if  isinstance(other,  CAMEOCode):148  return  self.code  ==  other.code149  return  False150151@dataclass152class  Relation:153  """Represents  a  relation."""154  cameo_code:  CAMEOCode155  name:  str156  description:  str  #  A  brief  description  of  what  event  the  relation  represents157  #  Example:  Relation(cameo_code=CAMEOCode("010"),  name="Make  statement,  not  specified",  description="All  public  statements  expressed  verbally  or  in  action,  not  otherwise  specified."158159  def  __init__(self,  cameo_code:  CAMEOCode,  name:  str,  description:  str):160  #  check  type161  if  not  isinstance(cameo_code,  CAMEOCode):162  raise  ValueError(f"Attribute  ’cameo_code’  of  class  Relation  must  be  a  CAMEOCode  object,  but  received  type  {type(cameo_code)}")163  if  not  isinstance(name,  str):164  raise  ValueError(f"Attribute  ’name’  of  class  Relation  must  be  a  string,  but  received  type  {type(name)}")165  if  not  isinstance(description,  str):166  raise  ValueError(f"Attribute  ’description’  of  class  Relation  must  be  a  string,  but  received  type  {type(description)}")167168  if  dict_code2relation[cameo_code.code][’Name’]  !=  name:169  raise  ValueError(f"Relation  name  must  match  the  name  corresponding  to  the  CAMEO  code,  but  received:  {name}  for  CAMEO  code  {cameo_code.code}")170  if  dict_code2relation[cameo_code.code][’Description’]  !=  description:171  raise  ValueError(f"Relation  description  must  match  the  description  corresponding  to  the  CAMEO  code,  but  received:  {description}  for  CAMEO  code  {cameo_code.code}")172  self.cameo_code  =  cameo_code173  self.name  =  name174  self.description  =  description175176  def  __str__(self):177  return  f"Relation(cameo_code={self.cameo_code},  name=’{self.name}’,  description=’{self.description}’)"178179  def  __hash__(self):180  return  hash((self.cameo_code,  self.name,  self.description))181182  def  __eq__(self,  other):183  if  isinstance(other,  Relation):184  return  self.cameo_code  ==  other.cameo_code  and  self.name  ==  other.name  and  self.description  ==  other.description185  return  False186187@dataclass188class  Event:189  """Represents  an  event  characterized  by  date,  head  entity,  relation,  and  tail  entity."""190  date:  Date191  head_entity:  ISOCode192  relation:  CAMEOCode193  tail_entity:  ISOCode194  #  Example:  Event(date=Date("2022-01-01"),  head_entity=ISOCode("USA"),  relation=CAMEOCode("010"),  tail_entity=ISOCode("CAN"))195196  def  __init__(self,  date:  Date,  head_entity:  ISOCode,  relation:  CAMEOCode,  tail_entity:  ISOCode):197  #  check  type198  if  not  isinstance(date,  Date):199  raise  ValueError(f"Attribute  ’date’  of  class  Event  must  be  a  Date  object,  but  received  type  {type(date)}")200  if  not  isinstance(head_entity,  ISOCode):201  raise  ValueError(f"Attribute  ’head_entity’  of  class  Event  must  be  an  ISOCode  object,  but  received  type  {type(head_entity)}")202  if  not  isinstance(relation,  CAMEOCode):203  raise  ValueError(f"Attribute  ’relation’  of  class  Event  must  be  a  CAMEOCode  object,  but  received  type  {type(relation)}")204  if  not  isinstance(tail_entity,  ISOCode):205  raise  ValueError(f"Attribute  ’tail_entity’  of  class  Event  must  be  an  ISOCode  object,  but  received  type  {type(tail_entity)}")206207  self.date  =  date208  self.head_entity  =  head_entity209  self.relation  =  relation210  self.tail_entity  =  tail_entity211212  def  __str__(self):213  return  f"Event(date={self.date},  head_entity={self.head_entity},  relation={self.relation},  tail_entity={self.tail_entity})"214215  def  __hash__(self):216  return  hash((self.date,  self.head_entity,  self.relation,  self.tail_entity))217218  def  __eq__(self,  other):219  if  isinstance(other,  Event):220  return  self.date  ==  other.date  and  self.head_entity  ==  other.head_entity  and  self.relation  ==  other.relation  and  self.tail_entity  ==  other.tail_entity221  return  False222223@dataclass224class  NewsArticle:225  """Represents  a  news  article,  including  metadata  and  content."""226  date:  Date227  title:  str228  content:  str  #  Full  text  content  of  the  news  article229  events:  List[Event]  #  List  of  events  mentioned  in  the  article230  #  Example:  NewsArticle(date=Date("2022-01-01"),  title="Trade  agreement  between  USA  and  China",  content="On  January  1,  2022,  a  trade  agreement  was  signed  between  the  USA  and  China...",  events=[Event(date=Date("2022-01-01"),  head_entity=ISOCode("USA"),  relation=CAMEOCode("010"),  tail_entity=ISOCode("CHN")])231232  def  __init__(self,  date:  Date,  title:  str,  content:  str,  events:  List[Event]):233  #  check  type234  if  not  isinstance(date,  Date):235  raise  ValueError(f"Attribute  ’date’  of  class  NewsArticle  must  be  a  Date  object,  but  received  type  {type(date)}")236  if  not  isinstance(title,  str):237  raise  ValueError(f"Attribute  ’title’  of  class  NewsArticle  must  be  a  string,  but  received  type  {type(title)}")238  if  not  isinstance(content,  str):239  raise  ValueError(f"Attribute  ’content’  of  class  NewsArticle  must  be  a  string,  but  received  type  {type(content)}")240  if  not  isinstance(events,  list):241  raise  ValueError(f"Attribute  ’events’  of  class  NewsArticle  must  be  a  list,  but  received  type  {type(events)}")242243  self.date  =  date244  self.title  =  title245  self.content  =  content246  self.events  =  events247248  def  __str__(self):249  return  f"{self.date}:\n{self.title}\n{self.content}"250251  def  __hash__(self):252  return  hash((self.date,  self.title,  self.content))253254  def  __eq__(self,  other):255  if  isinstance(other,  NewsArticle):256  return  self.date  ==  other.date  and  self.title  ==  other.title  and  self.content  ==  other.content257  return  False258259def  map_country_name_to_iso(name:  str)  ->  List[Country]:260  """261  Maps  a  country  name  to  the  most  likely  corresponding  Country  objects  with  ISO  codes.262263  Parameters:264  name  (str):  The  country  name  to  map.265266  Returns:267  List[Country]:  A  list  of  5  most  likely  Country  objects  sorted  by  relevance.268269  Example:270  >>>  map_country_name_to_iso("Korea")271  [Country(iso_code=ISOCode("KOR"),  name="Republic  of  Korea"),  Country(iso_code=ISOCode("PRK"),  name="Democratic  People’s  Republic  of  Korea")]272  """273  #  check  type274  if  not  isinstance(name,  str):275  raise  ValueError(f"Input  ’name’  must  be  a  string,  but  received  type  {type(name)}")276277  if  name  in  dict_countryname2iso:278  return  [Country(iso_code=ISOCode(dict_countryname2iso[name]),  name=name)]279  else:280  #  get  top  5  ISO  codes  with  the  highest  cosine  similarity281  name_embeddings  =  get_embedding(name)282  similarities  =  cosine_similarity(country_embeddings,  name_embeddings)283  top_indices  =  np.argsort(similarities)[::-1][:5]284  countries  =  []285  for  idx  in  top_indices:286  iso_code  =  list(dict_iso2alternames.keys())[idx]287  curr_name  =  dict_iso2alternames[iso_code][0]288  countries.append(Country(iso_code=ISOCode(iso_code),  name=curr_name))289  return  countries290291def  map_iso_to_country_name(iso_code:  ISOCode)  ->  str:292  """293  Maps  an  ISO  code  to  a  country  name.294295  Parameters:296  iso_code  (ISOCode):  The  ISO  code  to  map.297298  Returns:299  str:  The  corresponding  country  name.300301  Example:302  >>>  map_iso_to_country_name(ISOCode("CHN"))303  "China"304  """305  #  check  type306  if  not  isinstance(iso_code,  ISOCode):307  raise  ValueError(f"Input  ’iso_code’  must  be  an  ISOCode  object,  but  received  type  {type(iso_code)}")308309  return  dict_iso2alternames[iso_code.code][0]310311def  map_relation_description_to_cameo(description:  str)  ->  List[Relation]:312  """313  Maps  a  relation  description  to  the  most  likely  Relation  objects.314315  Parameters:316  description  (str):  The  relation  description  to  map.317318  Returns:319  List[Relation]:  A  list  of  5  most  likely  Relations  sorted  by  relevance.320321  Example:322  >>>  map_relation_description_to_cameo("Fight  with  guns")323  [Reltion(cameo_code=CAMEOCode("19"),  name="Fight",  description="All  uses  of  conventional  force  and  acts  of  war  typically  by  organized  armed  groups."),  Relation(cameo_code=CAMEOCode("193"),  name="Fight  with  small  arms  and  light  weapons",  description="Attack  using  small  arms  and  light  weapons  such  as  rifles,  machine-guns,  and  mortar  shells."),  Relation(cameo_code=CAMEOCode("190"),  name="Use  conventional  military  force,  not  specified",  description="All  uses  of  conventional  force  and  acts  of  war  typically  by  organized  armed  groups,  not  otherwise  specified.")]324  """325  #  check  type326  if  not  isinstance(description,  str):327  raise  ValueError(f"Input  ’description’  must  be  a  string,  but  received  type  {type(description)}")328329  if  description  in  dict_relation2code:330  code  =  dict_relation2code[description]331  return  [Relation(cameo_code=CAMEOCode(code),  name=dict_code2relation[code][’Name’],  description=dict_code2relation[code][’Description’])]332  else:333  #  get  top  5  CAMEO  codes  with  the  highest  cosine  similarity334  description_embedding  =  get_embedding(description)335  similarities  =  cosine_similarity(relation_embeddings,  description_embedding)336  top_indices  =  np.argsort(similarities)[::-1][:5]337  relations  =  []338  for  idx  in  top_indices:339  code  =  list(dict_code2relation.keys())[idx]340  relations.append(Relation(cameo_code=CAMEOCode(code),  name=dict_code2relation[code][’Name’],  description=dict_code2relation[code][’Description’]))341  return  relations342343def  map_cameo_to_relation(cameo_code:  CAMEOCode)  ->  Relation:344  """345  Maps  a  CAMEO  code  to  a  relation,  including  its  name  and  description.346347  Parameters:348  cameo_code  (CAMEOCode):  The  CAMEO  code  to  map.349350  Returns:351  Relation:  The  corresponding  relation.352353  Example:354  >>>  map_cameo_to_relation(CAMEOCode("190"))355  Relation(cameo_code=CAMEOCode("190"),  name="Use  conventional  military  force,  not  specified",  description="All  uses  of  conventional  force  and  acts  of  war  typically  by  organized  armed  groups,  not  otherwise  specified.")356  """357  #  check  type358  if  not  isinstance(cameo_code,  CAMEOCode):359  raise  ValueError(f"Input  ’cameo_code’  must  be  a  CAMEOCode  object,  but  received  type  {type(cameo_code)}")360361  info  =  dict_code2relation[cameo_code.code]362  return  Relation(cameo_code=cameo_code,  name=info[’Name’],  description=info[’Description’])363364def  get_parent_relation(cameo_code:  CAMEOCode)  ->  Relation:365  """366  Retrieves  the  parent  relation  of  a  given  relation  identified  by  CAMEO  code.367368  Parameters:369  cameo_code  (CAMEOCode):  The  CAMEO  code  of  the  relation  whose  parent  is  sought.  Only  second  level  relations  are  accepted.370371  Returns:372  Relation:  The  first  level  parent  relation.373374  Example:375  >>>  get_parent_relation(CAMEOCode("193"))376  Relation(cameo_code=CAMEOCode("19"),  name="Fight",  description="All  uses  of  conventional  force  and  acts  of  war  typically  by  organized  armed  groups.")377  """378  #  check  type379  if  not  isinstance(cameo_code,  CAMEOCode):380  raise  ValueError(f"Input  ’cameo_code’  must  be  a  CAMEOCode  object,  but  received  type  {type(cameo_code)}")381382  if  len(cameo_code.code)  !=  3:383  raise  ValueError("Only  second  level  relations  are  accepted,  but  received:  {}".format(cameo_code.code))384  parent_code  =cameo_code.code[:2]385  return  map_cameo_to_relation(CAMEOCode(parent_code))386387def  get_child_relations(cameo_code:  CAMEOCode)  ->  List[Relation]:388  """389  Retrieves  child  relations  of  a  given  relation  identified  by  CAMEO  code.390391  Parameters:392  cameo_code  (CAMEOCode):  The  CAMEO  code  of  the  relation  whose  children  are  sought.  Only  first  level  relations  are  accepted.393394  Returns:395  List[Relation]:  A  list  of  second  level  child  relations.396397  Example:398  >>>  get_child_relations(CAMEOCode("19"))399  [Relation(caemo_code=CAMEOCode("190"),  name="Use  conventional  military  force,  not  specified",  description="All  uses  of  conventional  force  and  acts  of  war  typically  by  organized  armed  groups,  not  otherwise  specified."),  Relation(cameo_code=CAMEOCode("191"),  name="Impose  blockade  or  restrict  movement",  description="Prevent  entry  into  and/or  exit  from  a  territory  using  armed  forces."),  ...]400  """401  #  check  type402  if  not  isinstance(cameo_code,  CAMEOCode):403  raise  ValueError(f"Input  ’cameo_code’  must  be  a  CAMEOCode  object,  but  received  type  {type(cameo_code)}")404405  if  len(cameo_code.code)  !=  2:406  raise  ValueError("Only  first  level  relations  are  accepted,  but  received:  {}".format(cameo_code.code))407  children  =  []408  for  code,  info  in  dict_code2relation.items():409  if  code[:2]  ==  cameo_code.code  and  len(code)  ==  3:410  children.append(Relation(cameo_code=CAMEOCode(code),  name=info[’Name’],  description=info[’Description’]))411  return  children412413def  get_sibling_relations(cameo_code:  CAMEOCode)  ->  List[Relation]:414  """415  Retrieves  sibling  relations  of  a  given  relation  identified  by  CAMEO  code.416417  Parameters:418  cameo_code  (CAMEOCode):  The  CAMEO  code  of  the  relation  whose  siblings  are  sought.  Both  first  and  second  level  relations  are  accepted.419420  Returns:421  List[Relation]:  A  list  of  sibling  relations  at  the  same  level.422423  Example:424  >>>  get_sibling_relations(CAMEOCode("193"))425  [Relation(caemo_code=CAMEOCode("190"),  name="Use  conventional  military  force,  not  specified",  description="All  uses  of  conventional  force  and  acts  of  war  typically  by  organized  armed  groups,  not  otherwise  specified."),  Relation(cameo_code=CAMEOCode("191"),  name="Impose  blockade  or  restrict  movement",  description="Prevent  entry  into  and/or  exit  from  a  territory  using  armed  forces."),  ...]426  """427  #  check  type428  if  not  isinstance(cameo_code,  CAMEOCode):429  raise  ValueError(f"Input  ’cameo_code’  must  be  a  CAMEOCode  object,  but  received  type  {type(cameo_code)}")430431  if  len(cameo_code.code)  ==  3:432  return  get_child_relations(get_parent_relation(cameo_code).cameo_code)433  elif  len(cameo_code.code)  ==  2:434  #  get  ’01’  to  ’20’  relations435  first_level_codes  =  [str(i).zfill(2)  for  i  in  range(1,  21)]436  relations  =  []437  for  code  in  first_level_codes:438  relations.append(map_cameo_to_relation(CAMEOCode(code)))439  return  relations440441def  count_events(date_range:  Optional[DateRange]  =  None,  head_entities:  Optional[List[ISOCode]]  =  None,  tail_entities:  Optional[List[ISOCode]]  =  None,  relations:  Optional[List[CAMEOCode]]  =  None)  ->  int:442  """443  Counts  the  number  of  events  in  the  knowledge  graph  based  on  specified  conditions.444445  Parameters:446  date_range  (Optional[DateRange]):  Range  of  dates  to  filter  the  events.  If  None,  all  dates  are  included.447  head_entities  (Optional[List[ISOCode]]):  List  of  head  entity  ISO  codes  to  be  included.  If  None,  all  countries  are  included.448  tail_entities  (Optional[List[ISOCode]]):  List  of  tail  entity  ISO  codes  to  be  included.  If  None,  all  countries  are  included.449  relations  (Optional[List[CAMEOCode]]):  List  of  relation  CAMEO  codes  to  be  included.  If  first  level  relations  are  listed,  all  second  level  relations  under  them  are  included.  If  None,  all  relations  are  included.450451  Returns:452  int:  Count  of  unique  events  matching  the  conditions.453454  Example:455  >>>  count_events(date_range=DateRange(start_date=Date("2022-01-01"),  end_date=Date("2022-01-31")),  head_entities=[ISOCode("USA"),  ISOCode("CHN")],  tail_entities=None,  relations=[CAMEOCode("010")])456  4457  """458  #  check  type459  if  date_range  and  not  isinstance(date_range,  DateRange):460  raise  ValueError(f"Input  ’date_range’  must  be  a  DateRange  object,  but  received  type  {type(date_range)}")461  if  head_entities  and  not  isinstance(head_entities,  list):462  raise  ValueError(f"Input  ’head_entities’  must  be  a  list,  but  received  type  {type(head_entities)}")463  if  head_entities  and  not  all(isinstance(iso,  ISOCode)  for  iso  in  head_entities):464  raise  ValueError(f"Elements  in  ’head_entities’  must  be  ISOCode  objects")465  if  tail_entities  and  not  isinstance(tail_entities,  list):466  raise  ValueError(f"Input  ’tail_entities’  must  be  a  list,  but  received  type  {type(tail_entities)}")467  if  tail_entities  and  not  all(isinstance(iso,  ISOCode)  for  iso  in  tail_entities):468  raise  ValueError(f"Elements  in  ’tail_entities’  must  be  ISOCode  objects")469  if  relations  and  not  isinstance(relations,  list):470  raise  ValueError(f"Input  ’relations’  must  be  a  list,  but  received  type  {type(relations)}")471  if  relations  and  not  all(isinstance(code,  CAMEOCode)  for  code  in  relations):472  raise  ValueError(f"Elements  in  ’relations’  must  be  CAMEOCode  objects")473474  #  process  data_kg  by  filtering  based  on  the  specified  conditions475  curr_data  =  data_kg.copy()476  curr_data.drop_duplicates(subset=[’QuadEventCode’],  inplace=True)477  curr_data  =  curr_data[curr_data[’DateStr’]  <=  DEFAULT_END_DATE]478  if  date_range:479  curr_data  =  curr_data[(curr_data[’DateStr’]  >=  date_range.start_date.date)  &  (curr_data[’DateStr’]  <=  date_range.end_date.date)]480  if  head_entities:481  curr_data  =  curr_data[curr_data[’Actor1CountryCode’].isin([iso.code  for  iso  in  head_entities])]482  if  tail_entities:483  curr_data  =  curr_data[curr_data[’Actor2CountryCode’].isin([iso.code  for  iso  in  tail_entities])]484  if  relations:485  #  if  first  level  relations  are  listed,  include  all  second  level  relations  under  them486  for  code  in  relations:487  if  len(code.code)  ==  2:488  relations.extend([CAMEOCode(c)  for  c  in  dict_code2relation  if  c[:2]  ==  code.code  and  len(c)  ==  3])489  curr_data  =  curr_data[curr_data[’EventBaseCode’].isin([code.code  for  code  in  relations])]490  return  len(curr_data)491492def  get_events(date_range:  Optional[DateRange]  =  None,  head_entities:  Optional[List[ISOCode]]  =  None,  tail_entities:  Optional[List[ISOCode]]  =  None,  relations:  Optional[List[CAMEOCode]]  =  None,  text_description:  Optional[str]  =  None)  ->  List[Event]:493  """494  Retrieves  events  from  the  knowledge  graph  based  on  specified  conditions.495  Inherits  common  filter  parameters  from  count_events.  See  count_events  for  more  details  on  these  parameters.496497  Additional  Parameters:498  text_description  (Optional[str]):  Textual  description  to  match  with  the  source  news  articles  of  events.  If  None,  the  returned  events  are  sorted  by  date  in  descending  order;  otherwise,  sorted  by  relevance  of  the  source  news  article  to  the  description.499500  Returns:501  List[Event]:  A  list  of  maximum  30  events  matching  the  specified  conditions.502503  Example:504  >>>  get_events(date_range=DateRange(start_date=Date("2022-01-01"),  end_date=Date("2022-01-31")),  head_entities=[ISOCode("USA"),  ISOCode("CHN")],  tail_entities=None,  relations=[CAMEOCode("010")],  text_description="economic  trade")505  [Event(date=Date("2022-01-15"),  head_entity=ISOCode("USA"),  relation=CAMEOCode("010"),  tail_entity=ISOCode("CAN"),  Event(date=Date("2022-01-10"),  head_entity=ISOCode("CHN"),  relation=CAMEOCode("010"),  tail_entity=ISOCode("USA"),  ...]506  """507  #  check  type508  if  date_range  and  not  isinstance(date_range,  DateRange):509  raise  ValueError(f"Input  ’date_range’  must  be  a  DateRange  object,  but  received  type  {type(date_range)}")510  if  head_entities  and  not  isinstance(head_entities,  list):511  raise  ValueError(f"Input  ’head_entities’  must  be  a  list,  but  received  type  {type(head_entities)}")512  if  head_entities  and  not  all(isinstance(iso,  ISOCode)  for  iso  in  head_entities):513  raise  ValueError(f"Elements  in  ’head_entities’  must  be  ISOCode  objects")514  if  tail_entities  and  not  isinstance(tail_entities,  list):515  raise  ValueError(f"Input  ’tail_entities’  must  be  a  list,  but  received  type  {type(tail_entities)}")516  if  tail_entities  and  not  all(isinstance(iso,  ISOCode)  for  iso  in  tail_entities):517  raise  ValueError(f"Elements  in  ’tail_entities’  must  be  ISOCode  objects")518  if  relations  and  not  isinstance(relations,  list):519  raise  ValueError(f"Input  ’relations’  must  be  a  list,  but  received  type  {type(relations)}")520  if  relations  and  not  all(isinstance(code,  CAMEOCode)  for  code  in  relations):521  raise  ValueError(f"Elements  in  ’relations’  must  be  CAMEOCode  objects")522  if  text_description  and  not  isinstance(text_description,  str):523  raise  ValueError(f"Input  ’text_description’  must  be  a  string,  but  received  type  {type(text_description)}")524525  #  process  data_kg  by  filtering  based  on  the  specified  conditions526  curr_data  =  data_kg.copy()527  curr_data  =  curr_data[curr_data[’DateStr’]  <=  DEFAULT_END_DATE]528  if  date_range:529  curr_data  =  curr_data[(curr_data[’DateStr’]  >=  date_range.start_date.date)  &  (curr_data[’DateStr’]  <=  date_range.end_date.date)]530  if  head_entities:531  curr_data  =  curr_data[curr_data[’Actor1CountryCode’].isin([iso.code  for  iso  in  head_entities])]532  if  tail_entities:533  curr_data  =  curr_data[curr_data[’Actor2CountryCode’].isin([iso.code  for  iso  in  tail_entities])]534  if  relations:535  #  if  first  level  relations  are  listed,  include  all  second  level  relations  under  them536  for  code  in  relations:537  if  len(code.code)  ==  2:538  relations.extend([CAMEOCode(c)  for  c  in  dict_code2relation  if  c[:2]  ==  code.code  and  len(c)  ==  3])539  curr_data  =  curr_data[curr_data[’EventBaseCode’].isin([code.code  for  code  in  relations])]540  if  not  text_description:541  #  get  max  30  events  from  the  filtered  data542  events  =  []543  curr_data.drop_duplicates(subset=[’QuadEventCode’],  inplace=True)544  #  sorted  by  date  in  descending  order545  curr_data.sort_values(by=’DateStr’,  ascending=False,  inplace=True)546  count  =  0547  for  _,  row  in  curr_data.iterrows():548  if  count  >=  30:549  break550  events.append(Event(date=Date(row[’DateStr’]),  head_entity=ISOCode(row[’Actor1CountryCode’]),  relation=CAMEOCode(row[’EventBaseCode’]),  tail_entity=ISOCode(row[’Actor2CountryCode’])))551  return  events[:30]552  else:553  #  concat  the  Docids  list  of  current  data  to  get  the  news  articles554  docids_list  =  [eval(docids)  for  docids  in  curr_data[’Docids’].unique().tolist()]555  docids  =  list(set([item  for  sublist  in  docids_list  for  item  in  sublist]))556  docids  =  [str(docid)  for  docid  in  docids]557  news_articles  =  data_news[data_news[’Docid’].isin(docids)]558  #  get  the  max  30  docids  with  the  highest  BM25  score  to  the  text_description559  corpus  =  news_articles[’Title’]  +  ’  ’  +  news_articles[’Text’]560  tokenized_corpus  =  [doc.split("  ")  for  doc  in  corpus]561  bm25  =  BM25Okapi(tokenized_corpus)562  tokenized_query  =  text_description.split("  ")563  doc_scores  =  bm25.get_scores(tokenized_query)564  top_indices  =  np.argsort(doc_scores)[::-1][:30]565  news_articles  =  news_articles.iloc[top_indices]566  docids  =  news_articles[’Docid’].tolist()567  #  get  max  30  events  from  the  filtered  data568  events  =  set()569  for  docid  in  docids:570  if  len(events)  >=  30:571  break572  doc_curr_data  =  curr_data[curr_data[’Docid’]  ==  docid]573  #  reverse  the  order  of  the  events  to  get  the  latest  events  first574  doc_curr_data  =  doc_curr_data.sort_values(by=’DateStr’,  ascending=False)575  for  _,  row  in  doc_curr_data.iterrows():576  events.add(Event(date=Date(row[’DateStr’]),  head_entity=ISOCode(row[’Actor1CountryCode’]),  relation=CAMEOCode(row[’EventBaseCode’]),  tail_entity=ISOCode(row[’Actor2CountryCode’])))577  return  list(events)578579def  get_entity_distribution(date_range:  Optional[DateRange]  =  None,  involved_relations:  Optional[List[CAMEOCode]]  =  None,  interacted_entities:  Optional[List[ISOCode]]  =  None,  entity_role:  Optional[str]  =  None)  ->  Dict[ISOCode,  int]:580  """581  Gets  the  distribution  of  entities  in  the  knowledge  graph  under  specified  conditions.582583  Parameters:584  date_range  (Optional[DateRange]):  Range  of  dates  to  filter  the  events.  If  None,  all  dates  are  included.585  involved_relations  (Optional[List[CAMEOCode]]):  List  of  relations  that  the  returned  entities  must  be  involved  in  any  of.  If  first  level  relations  are  listed,  all  second  level  relations  under  them  are  included.  If  None,  all  relations  are  included.586  interacted_entities  (Optional[List[ISOCode]]):  List  of  entities  that  the  returned  entities  must  have  interacted  with  any  of.  If  None,  all  entities  are  included.587  entity_role  (Optional[EntityRole]):  Specifies  the  role  of  the  returned  entity  in  the  events.  Options  are  ’head’,  ’tail’,  or  ’both’.  If  ’both’  or  None,  the  returned  entity  can  be  either  head  or  tail.588589  Returns:590  Dict[ISOCode,  int]:  A  dictionary  mapping  returned  entities’  ISO  codes  to  the  number  of  events  with  the  specified  conditions  in  which  they  are  involved,  sorted  by  counts  in  descending  order.591592  Example:593  >>>  get_entity_distribution(date_range=DateRange(start_date=Date("2022-01-01"),  end_date=Date("2022-01-31")),  involved_relations=[CAMEOCode("010")],  interacted_entities=[ISOCode("USA"),  ISOCode("CHN")],  entity_role="tail")594  {ISOCode("USA"):  3,  ISOCode("CHN"):  1}595  """596  #  check  type597  if  date_range  and  not  isinstance(date_range,  DateRange):598  raise  ValueError(f"Input  ’date_range’  must  be  a  DateRange  object,  but  received  type  {type(date_range)}")599  if  involved_relations  and  not  isinstance(involved_relations,  list):600  raise  ValueError(f"Input  ’involved_relations’  must  be  a  list,  but  received  type  {type(involved_relations)}")601  if  involved_relations  and  not  all(isinstance(code,  CAMEOCode)  for  code  in  involved_relations):602  raise  ValueError(f"Elements  in  ’involved_relations’  must  be  CAMEOCode  objects")603  if  interacted_entities  and  not  isinstance(interacted_entities,  list):604  raise  ValueError(f"Input  ’interacted_entities’  must  be  a  list,  but  received  type  {type(interacted_entities)}")605  if  interacted_entities  and  not  all(isinstance(iso,  ISOCode)  for  iso  in  interacted_entities):606  raise  ValueError(f"Elements  in  ’interacted_entities’  must  be  ISOCode  objects")607  if  entity_role  and  entity_role  not  in  [’head’,  ’tail’,  ’both’]:608  raise  ValueError(f"Input  ’entity_role’  must  be  a  string  ’head’,  ’tail’,  or  ’both’,  but  received:  {entity_role}")609610  #  process  data_kg  by  filtering  based  on  the  specified  conditions611  curr_data  =  data_kg.copy()612  curr_data.drop_duplicates(subset=[’QuadEventCode’],  inplace=True)613  curr_data  =  curr_data[curr_data[’DateStr’]  <=  DEFAULT_END_DATE]614  if  date_range:615  curr_data  =  curr_data[(curr_data[’DateStr’]  >=  date_range.start_date.date)  &  (curr_data[’DateStr’]  <=  date_range.end_date.date)]616  if  involved_relations:617  #  if  first  level  relations  are  listed,  include  all  second  level  relations  under  them618  for  code  in  involved_relations:619  if  len(code.code)  ==  2:620  involved_relations.extend([CAMEOCode(c)  for  c  in  dict_code2relation  if  c[:2]  ==  code.code  and  len(c)  ==  3])621  curr_data  =  curr_data[curr_data[’EventBaseCode’].isin([code.code  for  code  in  involved_relations])]622  if  interacted_entities:623  if  entity_role==’head’:624  curr_data  =  curr_data[curr_data[’Actor2CountryCode’].isin([iso.code  for  iso  in  interacted_entities])]625  elif  entity_role==’tail’:626  curr_data  =  curr_data[curr_data[’Actor1CountryCode’].isin([iso.code  for  iso  in  interacted_entities])]627  else:628  curr_data  =  curr_data[(curr_data[’Actor1CountryCode’].isin([iso.code  for  iso  in  interacted_entities]))  |  (curr_data[’Actor2CountryCode’].isin([iso.code  for  iso  in  interacted_entities]))]629  #  count  the  number  of  events  for  each  entity630  entity_counts  =  curr_data[’Actor1CountryCode’]._append(curr_data[’Actor2CountryCode’]).value_counts()631  entity_counts  =  entity_counts.to_dict()632  #  sort  the  dictionary  by  values  in  descending  order633  entity_counts  =  dict(sorted(entity_counts.items(),  key=lambda  item:  item[1],  reverse=True))634  entity_counts  =  {ISOCode(key):  value  for  key,  value  in  entity_counts.items()}635  return  entity_counts636637def  get_relation_distribution(date_range:  Optional[DateRange]  =  None,  head_entities:  Optional[List[ISOCode]]  =  None,  tail_entities:  Optional[List[ISOCode]]  =  None)  ->  Dict[CAMEOCode,  int]:638  """639  Gets  the  distribution  of  second  level  relations  in  the  knowledge  graph  under  specified  conditions.640641  Parameters:642  date_range  (Optional[DateRange]):  Range  of  dates  to  filter  the  events.  If  None,  all  dates  are  included.643  head_entities  (Optional[List[ISOCode]]):  List  of  head  entities  that  the  events  must  involve  any  of.  If  None,  all  head  entities  are  included.644  tail_entities  (Optional[List[ISOCode]]):  List  of  tail  entities  that  the  events  must  involve  any  of.  If  None,  all  tail  entities  are  included.645646  Returns:647  Dict[CAMEOCode,  int]:  A  dictionary  mapping  second  level  relations’  CAMEO  codes  to  the  number  of  events  with  the  specified  conditions  in  which  they  are  involved,  sorted  by  counts  in  descending  order.648649  Example:650  >>>  get_relation_distribution(date_range=DateRange(start_date=Date("2022-01-01"),  end_date=Date("2022-01-31")),  head_entities=[ISOCode("USA"),  ISOCode("CHN")],  tail_entities=None)651  {CAMEOCode("010"):  3,  CAMEOCode("011"):  1}652  """653  #  check  type654  if  date_range  and  not  isinstance(date_range,  DateRange):655  raise  ValueError(f"Input  ’date_range’  must  be  a  DateRange  object,  but  received  type  {type(date_range)}")656  if  head_entities  and  not  isinstance(head_entities,  list):657  raise  ValueError(f"Input  ’head_entities’  must  be  a  list,  but  received  type  {type(head_entities)}")658  if  head_entities  and  not  all(isinstance(iso,  ISOCode)  for  iso  in  head_entities):659  raise  ValueError(f"Elements  in  ’head_entities’  must  be  ISOCode  objects")660  if  tail_entities  and  not  isinstance(tail_entities,  list):661  raise  ValueError(f"Input  ’tail_entities’  must  be  a  list,  but  received  type  {type(tail_entities)}")662  if  tail_entities  and  not  all(isinstance(iso,  ISOCode)  for  iso  in  tail_entities):663  raise  ValueError(f"Elements  in  ’tail_entities’  must  be  ISOCode  objects")664665  #  process  data_kg  by  filtering  based  on  the  specified  conditions666  curr_data  =  data_kg.copy()667  curr_data.drop_duplicates(subset=[’QuadEventCode’],  inplace=True)668  curr_data  =  curr_data[curr_data[’DateStr’]  <=  DEFAULT_END_DATE]669  if  date_range:670  curr_data  =  curr_data[(curr_data[’DateStr’]  >=  date_range.start_date.date)  &  (curr_data[’DateStr’]  <=  date_range.end_date.date)]671  if  head_entities:672  curr_data  =  curr_data[curr_data[’Actor1CountryCode’].isin([iso.code  for  iso  in  head_entities])]673  if  tail_entities:674  curr_data  =  curr_data[curr_data[’Actor2CountryCode’].isin([iso.code  for  iso  in  tail_entities])]675  #  count  the  number  of  events  for  each  relation676  relation_counts  =  curr_data[’EventBaseCode’].value_counts()677  relation_counts  =  relation_counts.to_dict()678  #  sort  the  dictionary  by  values  in  descending  order679  relation_counts  =  dict(sorted(relation_counts.items(),  key=lambda  item:  item[1],  reverse=True))680  relation_counts  =  {CAMEOCode(key):  value  for  key,  value  in  relation_counts.items()}681  return  relation_counts682683def  count_news_articles(date_range:  Optional[DateRange]  =  None,  head_entities:  Optional[List[ISOCode]]  =  None,  tail_entities:  Optional[List[ISOCode]]  =  None,  relations:  Optional[List[CAMEOCode]]  =  None,  keywords:  Optional[List[str]]  =  None)  ->  int:684  """685  Counts  the  number  of  news  articles  based  on  specified  conditions.686687  Parameters:688  date_range  (Optional[DateRange]):  Range  of  dates  to  filter  the  news  articles.  If  None,  all  dates  are  included.689  head_entities  (Optional[List[ISOCode]]):  At  least  one  of  the  entities  must  be  mentioned  in  the  articles  and  be  the  head  entity  in  the  events.  If  None,  all  entities  are  included.690  tail_entities  (Optional[List[ISOCode]]):  At  least  one  of  the  entities  must  be  mentioned  in  the  articles  and  be  the  tail  entity  in  the  events.  If  None,  all  entities  are  included.691  relations  (Optional[List[CAMEOCode]]):  At  least  one  of  the  relations  must  be  mentioned  in  the  articles.  If  first  level  relations  are  listed,  all  second  level  relations  under  them  are  included.  If  None,  all  relations  are  included.692  keywords  (Optional[List[str]]):  At  least  one  of  the  keywords  must  be  present  in  the  articles.  If  None,  all  articles  are  included.693694  Returns:695  int:  The  count  of  news  articles  matching  the  conditions.696697  Example:698  >>>  count_news_articles(date_range=DateRange(start_date=Date("2022-01-01"),  end_date=Date("2022-01-31")),  head_entities=[ISOCode("USA"),  ISOCode("CHN")],  tail_entities=[ISOCode("USA"),  ISOCode("CHN")],  relations=[CAMEOCode("010")],  keywords=["trade"])699  2700  """701  #  check  type702  if  date_range  and  not  isinstance(date_range,  DateRange):703  raise  ValueError(f"Input  ’date_range’  must  be  a  DateRange  object,  but  received  type  {type(date_range)}")704  if  head_entities  and  not  isinstance(head_entities,  list):705  raise  ValueError(f"Input  ’head_entities’  must  be  a  list,  but  received  type  {type(head_entities)}")706  if  head_entities  and  not  all(isinstance(iso,  ISOCode)  for  iso  in  head_entities):707  raise  ValueError(f"Elements  in  ’head_entities’  must  be  ISOCode  objects")708  if  tail_entities  and  not  isinstance(tail_entities,  list):709  raise  ValueError(f"Input  ’tail_entities’  must  be  a  list,  but  received  type  {type(tail_entities)}")710  if  tail_entities  and  not  all(isinstance(iso,  ISOCode)  for  iso  in  tail_entities):711  raise  ValueError(f"Elements  in  ’tail_entities’  must  be  ISOCode  objects")712  if  relations  and  not  isinstance(relations,  list):713  raise  ValueError(f"Input  ’relations’  must  be  a  list,  but  received  type  {type(relations)}")714  if  relations  and  not  all(isinstance(code,  CAMEOCode)  for  code  in  relations):715  raise  ValueError(f"Elements  in  ’relations’  must  be  CAMEOCode  objects")716  if  keywords  and  not  isinstance(keywords,  list):717  raise  ValueError(f"Input  ’keywords’  must  be  a  list,  but  received  type  {type(keywords)}")718  if  keywords  and  not  all(isinstance(keyword,  str)  for  keyword  in  keywords):719  raise  ValueError(f"Elements  in  ’keywords’  must  be  strings")720721  #  process  data_kg  by  filtering  based  on  the  specified  conditions722  curr_data  =  data_kg.copy()723  curr_data.drop_duplicates(subset=[’QuadEventCode’],  inplace=True)724  curr_data  =  curr_data[curr_data[’DateStr’]  <=  DEFAULT_END_DATE]725  if  date_range:726  curr_data  =  curr_data[(curr_data[’DateStr’]  >=  date_range.start_date.date)  &  (curr_data[’DateStr’]  <=  date_range.end_date.date)]727  if  head_entities:728  curr_data  =  curr_data[curr_data[’Actor1CountryCode’].isin([iso.code  for  iso  in  head_entities])]729  if  tail_entities:730  curr_data  =  curr_data[curr_data[’Actor2CountryCode’].isin([iso.code  for  iso  in  tail_entities])]731  if  relations:732  #  if  first  level  relations  are  listed,  include  all  second  level  relations  under  them733  for  code  in  relations:734  if  len(code.code)  ==  2:735  relations.extend([CAMEOCode(c)  for  c  in  dict_code2relation  if  c[:2]  ==  code.code  and  len(c)  ==  3])736  curr_data  =  curr_data[curr_data[’EventBaseCode’].isin([code.code  for  code  in  relations])]737  #  concat  the  Docids  list  of  current  data  to  get  the  news  articles738  docids_list  =  [eval(docids)  for  docids  in  curr_data[’Docids’].unique().tolist()]739  docids  =  list(set([item  for  sublist  in  docids_list  for  item  in  sublist]))740  docids  =  [str(docid)  for  docid  in  docids]741  news_articles  =  data_news[data_news[’Docid’].isin(docids)]742  if  keywords:743  #  filter  the  news  articles  that  contain  at  least  one  of  the  keywords  in  the  title  or  text  string744  news_articles  =  news_articles[news_articles[’Title’].str.contains(’|’.join(keywords),  case=False)  |  news_articles[’Text’].str.contains(’|’.join(keywords),  case=False)]745  return  len(news_articles)746747def  get_news_articles(date_range:  Optional[DateRange]  =  None,  head_entities:  Optional[List[ISOCode]]  =  None,  tail_entities:  Optional[List[ISOCode]]  =  None,  relations:  Optional[List[CAMEOCode]]  =  None,  keywords:  Optional[List[str]]  =  None,  text_description:  Optional[str]  =  None)  ->  List[Tuple[Date,  str]]:748  """749  Retrieves  news  articles  based  on  specified  conditions.750  Inherits  common  filter  parameters  from  count_news_articles.  See  count_news_articles  for  more  details  on  these  parameters.751752  Additional  Parameters:753  text_description  (Optional[str]):  Textual  description  to  match  with  the  news  articles.  If  None,  the  returned  articles  are  sorted  by  date  in  descending  order;  otherwise,  sorted  by  relevance  to  the  description.754755  Returns:756  List[Tuple[Date,  str]]:  A  list  of  maximum  15  news  articles  matching  the  specified  conditions,  each  represented  by  a  tuple  of  date  and  title.757758  Example:759  >>>  get_news_articles(date_range=DateRange(start_date=Date("2022-01-01"),  end_date=Date("2022-01-31")),  head_entities=[ISOCode("USA"),  ISOCode("CHN")],  tail_entities=[ISOCode("USA"),  ISOCode("CHN")],  relations=[CAMEOCode("010")],  keywords=["trade"],  text_description="Economic  trade  is  encouraged  between  USA  and  China.")760  [(NewsArticle.date=Date("2022-01-15"),  NewsArticle.title="China  and  USA  sign  trade  deal"),  (NewsArticle.date=Date("2022-01-10"),  NewsArticle.title="Trade  agreement  between  USA  and  China")]761  """762  #  check  type763  if  date_range  and  not  isinstance(date_range,  DateRange):764  raise  ValueError(f"Input  ’date_range’  must  be  a  DateRange  object,  but  received  type  {type(date_range)}")765  if  head_entities  and  not  isinstance(head_entities,  list):766  raise  ValueError(f"Input  ’head_entities’  must  be  a  list,  but  received  type  {type(head_entities)}")767  if  head_entities  and  not  all(isinstance(iso,  ISOCode)  for  iso  in  head_entities):768  raise  ValueError(f"Elements  in  ’head_entities’  must  be  ISOCode  objects")769  if  tail_entities  and  not  isinstance(tail_entities,  list):770  raise  ValueError(f"Input  ’tail_entities’  must  be  a  list,  but  received  type  {type(tail_entities)}")771  if  tail_entities  and  not  all(isinstance(iso,  ISOCode)  for  iso  in  tail_entities):772  raise  ValueError(f"Elements  in  ’tail_entities’  must  be  ISOCode  objects")773  if  relations  and  not  isinstance(relations,  list):774  raise  ValueError(f"Input  ’relations’  must  be  a  list,  but  received  type  {type(relations)}")775  if  relations  and  not  all(isinstance(code,  CAMEOCode)  for  code  in  relations):776  raise  ValueError(f"Elements  in  ’relations’  must  be  CAMEOCode  objects")777  if  keywords  and  not  isinstance(keywords,  list):778  raise  ValueError(f"Input  ’keywords’  must  be  a  list,  but  received  type  {type(keywords)}")779  if  keywords  and  not  all(isinstance(keyword,  str)  for  keyword  in  keywords):780  raise  ValueError(f"Elements  in  ’keywords’  must  be  strings")781  if  text_description  and  not  isinstance(text_description,  str):782  raise  ValueError(f"Input  ’text_description’  must  be  a  string,  but  received  type  {type(text_description)}")783784  #  process  data_kg  by  filtering  based  on  the  specified  conditions785  curr_data  =  data_kg.copy()786  curr_data.drop_duplicates(subset=[’QuadEventCode’],  inplace=True)787  curr_data  =  curr_data[curr_data[’DateStr’]  <=  DEFAULT_END_DATE]788  if  date_range:789  curr_data  =  curr_data[790  (curr_data[’DateStr’]  >=  date_range.start_date.date)  &  (curr_data[’DateStr’]  <=  date_range.end_date.date)]791  if  head_entities:792  curr_data  =  curr_data[curr_data[’Actor1CountryCode’].isin([iso.code  for  iso  in  head_entities])]793  if  tail_entities:794  curr_data  =  curr_data[curr_data[’Actor2CountryCode’].isin([iso.code  for  iso  in  tail_entities])]795  if  relations:796  #  if  first  level  relations  are  listed,  include  all  second  level  relations  under  them797  for  code  in  relations:798  if  len(code.code)  ==  2:799  relations.extend([CAMEOCode(c)  for  c  in  dict_code2relation  if  c[:2]  ==  code.code  and  len(c)  ==  3])800  curr_data  =  curr_data[curr_data[’EventBaseCode’].isin([code.code  for  code  in  relations])]801  docids_list  =  [eval(docids)  for  docids  in  curr_data[’Docids’].unique().tolist()]802  docids  =  list(set([item  for  sublist  in  docids_list  for  item  in  sublist]))803  docids  =  [str(docid)  for  docid  in  docids]804  news_articles  =  data_news[data_news[’Docid’].isin(docids)]805  if  keywords:806  #  filter  the  news  articles  that  contain  at  least  one  of  the  keywords  in  the  title  or  text  string807  news_articles  =  news_articles[news_articles[’Title’].str.contains(’|’.join(keywords),  case=False)  |  news_articles[’Text’].str.contains(’|’.join(keywords),  case=False)]808  if  not  text_description:809  #  get  max  15  news  articles  from  the  filtered  data810  #  sorted  by  date  in  descending  order811  news_articles.sort_values(by=’Date’,  ascending=False,  inplace=True)812  news_articles  =  news_articles[[’Date’,  ’Title’]].head(15)813  return  [(Date(row[’Date’]),  row[’Title’])  for  _,  row  in  news_articles.iterrows()]814  else:815  #  get  the  max  15  news  articles  with  the  highest  BM25  score  to  the  text_description816  corpus  =  news_articles[’Title’]  +  ’  ’  +  news_articles[’Text’]817  tokenized_corpus  =  [doc.split("  ")  for  doc  in  corpus]818  bm25  =  BM25Okapi(tokenized_corpus)819  tokenized_query  =  text_description.split("  ")820  doc_scores  =  bm25.get_scores(tokenized_query)821  top_indices  =  np.argsort(doc_scores)[::-1][:15]822  news_articles  =  news_articles.iloc[top_indices]823  return  [(Date(row[’Date’]),  row[’Title’])  for  _,  row  in  news_articles.iterrows()]824825def  browse_news_article(date:  Date,  title:  str)  ->  str:826  """827  Retrieves  the  full  text  of  a  news  article  by  its  title.828829  Parameters:830  date  (Date):  The  date  of  the  news  article  to  retrieve.831  title  (str):  The  title  of  the  news  article  to  retrieve.832833  Returns:834  str:  The  date,  the  title  and  full  contents  of  the  news  article.835836  Example:837  >>>  browse_news_article(Date("2022-01-10"),  "Trade  agreement  between  USA  and  China")838  2022-01-10:839  Trade  agreement  between  USA  and  China840  On  January  10,  2022,  a  trade  agreement  was  signed  between  the  USA  and  China  to  promote  economic  cooperation...841  """842  #  check  type843  if  not  isinstance(date,  Date):844  raise  ValueError(f"Input  ’date’  must  be  a  Date  object,  but  received  type  {type(date)}")845  if  not  isinstance(title,  str):846  raise  ValueError(f"Input  ’title’  must  be  a  string,  but  received  type  {type(title)}")847848  #  process  data_news  to  find  the  news  article  with  the  specified  date  and  title849  curr_data  =  data_news[(data_news[’Date’]  ==  date.date)  &  (data_news[’Title’]  ==  title)]850  if  len(curr_data)  ==  0:851  raise  ValueError(f"No  news  article  found  with  the  specified  date  {date.date}  and  title  {title}")852  return  f"{date}:\n{title}\n{curr_data[’Text’].values[0]}"’'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
